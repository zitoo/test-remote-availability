import { a as getAugmentedNamespace, c as commonjsGlobal, g as getDefaultExportFromCjs$1 } from './_commonjsHelpers-BAGoDD49.js';
import { _ as __vitePreload } from './preload-helper-D9CReCkA.js';
import { s as scoping__loadShare__react__loadShare__, R as React } from './scoping__loadShare__react__loadShare__-yNMJNsYw.js';
import { s as scoping__mf_v__runtimeInit__mf_v__, i as index_cjs } from './scoping__mf_v__runtimeInit__mf_v__-DCCaJgep.js';

// src/subscribable.ts
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$3() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject$2(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));
  }
  return false;
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (array || isPlainObject$2(a) && isPlainObject$2(b)) {
    const aItems = array ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {
        copy[key] = void 0;
        equalItems++;
      } else {
        copy[key] = replaceEqualDeep(a[key], b[key]);
        if (copy[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$2(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function keepPreviousData(previousData) {
  return previousData;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}

// src/focusManager.ts
var FocusManager = class extends Subscribable {
  #focused;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.#focused !== focused;
    if (changed) {
      this.#focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof this.#focused === "boolean") {
      return this.#focused;
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
};
var focusManager = new FocusManager();

// src/onlineManager.ts
var OnlineManager = class extends Subscribable {
  #online = true;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup(this.setOnline.bind(this));
  }
  setOnline(online) {
    const changed = this.#online !== online;
    if (changed) {
      this.#online = online;
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return this.#online;
  }
};
var onlineManager = new OnlineManager();

// src/thenable.ts
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// src/retryer.ts
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options?.revert;
    this.silent = options?.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config.abort?.();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onSuccess?.(value);
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config.onError?.(value);
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      config.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// src/notifyManager.ts
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb) => setTimeout(cb, 0);
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// src/removable.ts
var Removable = class {
  #gcTimeout;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      this.#gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime);
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (this.#gcTimeout) {
      clearTimeout(this.#gcTimeout);
      this.#gcTimeout = void 0;
    }
  }
};

var Query = class extends Removable {
  #initialState;
  #revertState;
  #cache;
  #client;
  #retryer;
  #defaultOptions;
  #abortSignalConsumed;
  constructor(config) {
    super();
    this.#abortSignalConsumed = false;
    this.#defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.#client = config.client;
    this.#cache = this.#client.getQueryCache();
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.#initialState = getDefaultState$1(this.options);
    this.state = config.state ?? this.#initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#retryer?.promise;
  }
  setOptions(options) {
    this.options = { ...this.#defaultOptions, ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.#cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.#dispatch({
      data,
      type: "success",
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.#dispatch({ type: "setState", state, setStateOptions });
  }
  cancel(options) {
    const promise = this.#retryer?.promise;
    this.#retryer?.cancel(options);
    return promise ? promise.then(noop$3).catch(noop$3) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(this.#initialState);
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.#cache.notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.#retryer) {
          if (this.#abortSignalConsumed) {
            this.#retryer.cancel({ revert: true });
          } else {
            this.#retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.#cache.notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.#dispatch({ type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (this.#retryer) {
        this.#retryer.continueRetry();
        return this.#retryer.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          this.#abortSignalConsumed = true;
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        client: this.#client,
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      this.#abortSignalConsumed = false;
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      client: this.#client,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    this.options.behavior?.onFetch(
      context,
      this
    );
    this.#revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
    }
    const onError = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.#dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        this.#cache.config.onError?.(
          error,
          this
        );
        this.#cache.config.onSettled?.(
          this.state.data,
          error,
          this
        );
      }
      this.scheduleGc();
    };
    this.#retryer = createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        if (data === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        this.#cache.config.onSuccess?.(data, this);
        this.#cache.config.onSettled?.(
          data,
          this.state.error,
          this
        );
        this.scheduleGc();
      },
      onError,
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue: () => {
        this.#dispatch({ type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    });
    return this.#retryer.start();
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.#revertState) {
            return { ...this.#revertState, fetchStatus: "idle" };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      this.#cache.notify({ query: this, type: "updated", action });
    });
  }
};
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// src/queryCache.ts
var QueryCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#queries = /* @__PURE__ */ new Map();
  }
  #queries;
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.#queries.has(query.queryHash)) {
      this.#queries.set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.#queries.get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        this.#queries.delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.#queries.get(queryHash);
  }
  getAll() {
    return [...this.#queries.values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// src/mutation.ts
var Mutation = class extends Removable {
  #observers;
  #mutationCache;
  #retryer;
  constructor(config) {
    super();
    this.mutationId = config.mutationId;
    this.#mutationCache = config.mutationCache;
    this.#observers = [];
    this.state = config.state || getDefaultState();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!this.#observers.includes(observer)) {
      this.#observers.push(observer);
      this.clearGcTimeout();
      this.#mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.#observers = this.#observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.#mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.#observers.length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        this.#mutationCache.remove(this);
      }
    }
  }
  continue() {
    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    this.#retryer = createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue: () => {
        this.#dispatch({ type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#mutationCache.canRun(this)
    });
    const restored = this.state.status === "pending";
    const isPaused = !this.#retryer.canStart();
    try {
      if (!restored) {
        this.#dispatch({ type: "pending", variables, isPaused });
        await this.#mutationCache.config.onMutate?.(
          variables,
          this
        );
        const context = await this.options.onMutate?.(variables);
        if (context !== this.state.context) {
          this.#dispatch({
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await this.#retryer.start();
      await this.#mutationCache.config.onSuccess?.(
        data,
        variables,
        this.state.context,
        this
      );
      await this.options.onSuccess?.(data, variables, this.state.context);
      await this.#mutationCache.config.onSettled?.(
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      );
      await this.options.onSettled?.(data, null, variables, this.state.context);
      this.#dispatch({ type: "success", data });
      return data;
    } catch (error) {
      try {
        await this.#mutationCache.config.onError?.(
          error,
          variables,
          this.state.context,
          this
        );
        await this.options.onError?.(
          error,
          variables,
          this.state.context
        );
        await this.#mutationCache.config.onSettled?.(
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        );
        await this.options.onSettled?.(
          void 0,
          error,
          variables,
          this.state.context
        );
        throw error;
      } finally {
        this.#dispatch({ type: "error", error });
      }
    } finally {
      this.#mutationCache.runNext(this);
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.#observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.#mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// src/mutationCache.ts
var MutationCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#mutations = /* @__PURE__ */ new Set();
    this.#scopes = /* @__PURE__ */ new Map();
    this.#mutationId = 0;
  }
  #mutations;
  #scopes;
  #mutationId;
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++this.#mutationId,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.#mutations.add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = this.#scopes.get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        this.#scopes.set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (this.#mutations.delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = this.#scopes.get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index = scopedMutations.indexOf(mutation);
            if (index !== -1) {
              scopedMutations.splice(index, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            this.#scopes.delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = this.#scopes.get(scope);
      const firstPendingMutation = mutationsWithSameScope?.find(
        (m) => m.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);
      return foundMutation?.continue() ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.#mutations.forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      this.#mutations.clear();
      this.#scopes.clear();
    });
  }
  getAll() {
    return Array.from(this.#mutations);
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$3))
      )
    );
  }
};
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}

// src/infiniteQueryBehavior.ts
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            client: context.client,
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}
function hasNextPage(options, data) {
  if (!data)
    return false;
  return getNextPageParam(options, data) != null;
}
function hasPreviousPage(options, data) {
  if (!data || !options.getPreviousPageParam)
    return false;
  return getPreviousPageParam(options, data) != null;
}

// src/queryClient.ts
var QueryClient = class {
  #queryCache;
  #mutationCache;
  #defaultOptions;
  #queryDefaults;
  #mutationDefaults;
  #mountCount;
  #unsubscribeFocus;
  #unsubscribeOnline;
  constructor(config = {}) {
    this.#queryCache = config.queryCache || new QueryCache();
    this.#mutationCache = config.mutationCache || new MutationCache();
    this.#defaultOptions = config.defaultOptions || {};
    this.#queryDefaults = /* @__PURE__ */ new Map();
    this.#mutationDefaults = /* @__PURE__ */ new Map();
    this.#mountCount = 0;
  }
  mount() {
    this.#mountCount++;
    if (this.#mountCount !== 1)
      return;
    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        this.#queryCache.onFocus();
      }
    });
    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        this.#queryCache.onOnline();
      }
    });
  }
  unmount() {
    this.#mountCount--;
    if (this.#mountCount !== 0)
      return;
    this.#unsubscribeFocus?.();
    this.#unsubscribeFocus = void 0;
    this.#unsubscribeOnline?.();
    this.#unsubscribeOnline = void 0;
  }
  isFetching(filters) {
    return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(options.queryHash)?.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = this.#queryCache.build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = this.#queryCache.get(
      defaultedOptions.queryHash
    );
    const prevData = query?.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(
      options.queryHash
    )?.state;
  }
  removeQueries(filters) {
    const queryCache = this.#queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = this.#queryCache;
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(
        {
          type: "active",
          ...filters
        },
        options
      );
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$3).catch(noop$3);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      this.#queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters?.refetchType === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries(
        {
          ...filters,
          type: filters?.refetchType ?? filters?.type ?? "active"
        },
        options
      );
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$3);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$3);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = this.#queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$3).catch(noop$3);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$3).catch(noop$3);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return this.#mutationCache.resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return this.#queryCache;
  }
  getMutationCache() {
    return this.#mutationCache;
  }
  getDefaultOptions() {
    return this.#defaultOptions;
  }
  setDefaultOptions(options) {
    this.#defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    this.#queryDefaults.set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...this.#queryDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    this.#mutationDefaults.set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...this.#mutationDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.#defaultOptions.queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options?._defaulted) {
      return options;
    }
    return {
      ...this.#defaultOptions.mutations,
      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.#queryCache.clear();
    this.#mutationCache.clear();
  }
};

// src/queryObserver.ts
var QueryObserver = class extends Subscribable {
  constructor(client, options) {
    super();
    this.options = options;
    this.#client = client;
    this.#selectError = null;
    this.#currentThenable = pendingThenable();
    if (!this.options.experimental_prefetchInRender) {
      this.#currentThenable.reject(
        new Error("experimental_prefetchInRender feature flag is not enabled")
      );
    }
    this.bindMethods();
    this.setOptions(options);
  }
  #client;
  #currentQuery = void 0;
  #currentQueryInitialState = void 0;
  #currentResult = void 0;
  #currentResultState;
  #currentResultOptions;
  #currentThenable;
  #selectError;
  #selectFn;
  #selectResult;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #lastQueryWithDefinedData;
  #staleTimeoutId;
  #refetchIntervalId;
  #currentRefetchInterval;
  #trackedProps = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.#currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.#currentQuery, this.options)) {
        this.#executeFetch();
      } else {
        this.updateResult();
      }
      this.#updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.#clearStaleTimeout();
    this.#clearRefetchInterval();
    this.#currentQuery.removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.#currentQuery;
    this.options = this.#client.defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    this.#updateQuery();
    this.#currentQuery.setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.#currentQuery,
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      this.#currentQuery,
      prevQuery,
      this.options,
      prevOptions
    )) {
      this.#executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {
      this.#updateStaleTimeout();
    }
    const nextRefetchInterval = this.#computeRefetchInterval();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
      this.#updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.#client.getQueryCache().build(this.#client, options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      this.#currentResult = result;
      this.#currentResultOptions = this.options;
      this.#currentResultState = this.#currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key);
          onPropTracked?.(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key) {
    this.#trackedProps.add(key);
  }
  getCurrentQuery() {
    return this.#currentQuery;
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.#client.defaultQueryOptions(options);
    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return this.#executeFetch({
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return this.#currentResult;
    });
  }
  #executeFetch(fetchOptions) {
    this.#updateQuery();
    let promise = this.#currentQuery.fetch(
      this.options,
      fetchOptions
    );
    if (!fetchOptions?.throwOnError) {
      promise = promise.catch(noop$3);
    }
    return promise;
  }
  #updateStaleTimeout() {
    this.#clearStaleTimeout();
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      this.#currentQuery
    );
    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);
    const timeout = time + 1;
    this.#staleTimeoutId = setTimeout(() => {
      if (!this.#currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  #computeRefetchInterval() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
  }
  #updateRefetchInterval(nextInterval) {
    this.#clearRefetchInterval();
    this.#currentRefetchInterval = nextInterval;
    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
      return;
    }
    this.#refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.#executeFetch();
      }
    }, this.#currentRefetchInterval);
  }
  #updateTimers() {
    this.#updateStaleTimeout();
    this.#updateRefetchInterval(this.#computeRefetchInterval());
  }
  #clearStaleTimeout() {
    if (this.#staleTimeoutId) {
      clearTimeout(this.#staleTimeoutId);
      this.#staleTimeoutId = void 0;
    }
  }
  #clearRefetchInterval() {
    if (this.#refetchIntervalId) {
      clearInterval(this.#refetchIntervalId);
      this.#refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.#currentQuery;
    const prevOptions = this.options;
    const prevResult = this.#currentResult;
    const prevResultState = this.#currentResultState;
    const prevResultOptions = this.#currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {
        data = this.#selectResult;
      } else {
        try {
          this.#selectFn = options.select;
          data = options.select(newState.data);
          data = replaceData(prevResult?.data, data, options);
          this.#selectResult = data;
          this.#selectError = null;
        } catch (selectError) {
          this.#selectError = selectError;
        }
      }
    } else {
      data = newState.data;
    }
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          this.#lastQueryWithDefinedData?.state.data,
          this.#lastQueryWithDefinedData
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            this.#selectError = null;
          } catch (selectError) {
            this.#selectError = selectError;
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult?.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (this.#selectError) {
      error = this.#selectError;
      data = this.#selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: this.#currentThenable
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = this.#currentThenable = nextResult.promise = pendingThenable();
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = this.#currentThenable;
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult(notifyOptions) {
    const prevResult = this.#currentResult;
    const nextResult = this.createResult(this.#currentQuery, this.options);
    this.#currentResultState = this.#currentQuery.state;
    this.#currentResultOptions = this.options;
    if (this.#currentResultState.data !== void 0) {
      this.#lastQueryWithDefinedData = this.#currentQuery;
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.#currentResult = nextResult;
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? this.#trackedProps
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(this.#currentResult).some((key) => {
        const typedKey = key;
        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });
  }
  #updateQuery() {
    const query = this.#client.getQueryCache().build(this.#client, this.options);
    if (query === this.#currentQuery) {
      return;
    }
    const prevQuery = this.#currentQuery;
    this.#currentQuery = query;
    this.#currentQueryInitialState = query.state;
    if (this.hasListeners()) {
      prevQuery?.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      this.#updateTimers();
    }
  }
  #notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.#currentResult);
        });
      }
      this.#client.getQueryCache().notify({
        query: this.#currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
};
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// src/infiniteQueryObserver.ts
var InfiniteQueryObserver = class extends QueryObserver {
  constructor(client, options) {
    super(client, options);
  }
  bindMethods() {
    super.bindMethods();
    this.fetchNextPage = this.fetchNextPage.bind(this);
    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(options, notifyOptions) {
    super.setOptions(
      {
        ...options,
        behavior: infiniteQueryBehavior()
      },
      notifyOptions
    );
  }
  getOptimisticResult(options) {
    options.behavior = infiniteQueryBehavior();
    return super.getOptimisticResult(options);
  }
  fetchNextPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(query, options) {
    const { state } = query;
    const parentResult = super.createResult(query, options);
    const { isFetching, isRefetching, isError, isRefetchError } = parentResult;
    const fetchDirection = state.fetchMeta?.fetchMore?.direction;
    const isFetchNextPageError = isError && fetchDirection === "forward";
    const isFetchingNextPage = isFetching && fetchDirection === "forward";
    const isFetchPreviousPageError = isError && fetchDirection === "backward";
    const isFetchingPreviousPage = isFetching && fetchDirection === "backward";
    const result = {
      ...parentResult,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hasNextPage(options, state.data),
      hasPreviousPage: hasPreviousPage(options, state.data),
      isFetchNextPageError,
      isFetchingNextPage,
      isFetchPreviousPageError,
      isFetchingPreviousPage,
      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,
      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
    };
    return result;
  }
};

// src/mutationObserver.ts
var MutationObserver$1 = class MutationObserver extends Subscribable {
  #client;
  #currentResult = void 0;
  #currentMutation;
  #mutateOptions;
  constructor(client, options) {
    super();
    this.#client = client;
    this.setOptions(options);
    this.bindMethods();
    this.#updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = this.#client.defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.#currentMutation,
        observer: this
      });
    }
    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (this.#currentMutation?.state.status === "pending") {
      this.#currentMutation.setOptions(this.options);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#currentMutation?.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.#updateResult();
    this.#notify(action);
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  reset() {
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = void 0;
    this.#updateResult();
    this.#notify();
  }
  mutate(variables, options) {
    this.#mutateOptions = options;
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);
    this.#currentMutation.addObserver(this);
    return this.#currentMutation.execute(variables);
  }
  #updateResult() {
    const state = this.#currentMutation?.state ?? getDefaultState();
    this.#currentResult = {
      ...state,
      isPending: state.status === "pending",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
  }
  #notify(action) {
    notifyManager.batch(() => {
      if (this.#mutateOptions && this.hasListeners()) {
        const variables = this.#currentResult.variables;
        const context = this.#currentResult.context;
        if (action?.type === "success") {
          this.#mutateOptions.onSuccess?.(action.data, variables, context);
          this.#mutateOptions.onSettled?.(action.data, null, variables, context);
        } else if (action?.type === "error") {
          this.#mutateOptions.onError?.(action.error, variables, context);
          this.#mutateOptions.onSettled?.(
            void 0,
            action.error,
            variables,
            context
          );
        }
      }
      this.listeners.forEach((listener) => {
        listener(this.#currentResult);
      });
    });
  }
};

// dev uses dynamic import to separate chunks
    
    const {loadShare: loadShare$2} = index_cjs;
    const {initPromise: initPromise$2} = scoping__mf_v__runtimeInit__mf_v__;
    const res$2 = initPromise$2.then(_ => loadShare$2("react/jsx-runtime", {
    customShareInfo: {shareConfig:{
      singleton: false,
      strictVersion: false,
      requiredVersion: "^18.3.1"
    }}}));
    const exportModule$2 = await res$2.then(factory => factory());
    var scoping__loadShare__react_mf_1_jsx_mf_2_runtime__loadShare__ = exportModule$2;

var QueryClientContext = scoping__loadShare__react__loadShare__.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = scoping__loadShare__react__loadShare__.useContext(QueryClientContext);
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  scoping__loadShare__react__loadShare__.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return /* @__PURE__ */ scoping__loadShare__react_mf_1_jsx_mf_2_runtime__loadShare__.jsx(QueryClientContext.Provider, { value: client, children });
};

var IsRestoringContext = scoping__loadShare__react__loadShare__.createContext(false);
var useIsRestoring = () => scoping__loadShare__react__loadShare__.useContext(IsRestoringContext);
IsRestoringContext.Provider;

function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = scoping__loadShare__react__loadShare__.createContext(createValue());
var useQueryErrorResetBoundary = () => scoping__loadShare__react__loadShare__.useContext(QueryErrorResetBoundaryContext);

// src/utils.ts
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop$2() {
}

var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  scoping__loadShare__react__loadShare__.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};

// src/suspense.ts
var ensureSuspenseTimers = (defaultedOptions) => {
  const originalStaleTime = defaultedOptions.staleTime;
  if (defaultedOptions.suspense) {
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

function useBaseQuery(options, Observer, queryClient) {
  const client = useQueryClient();
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client.defaultQueryOptions(options);
  client.getDefaultOptions().queries?._experimental_beforeQuery?.(
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = scoping__loadShare__react__loadShare__.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  scoping__loadShare__react__loadShare__.useSyncExternalStore(
    scoping__loadShare__react__loadShare__.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop$2;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  scoping__loadShare__react__loadShare__.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  client.getDefaultOptions().queries?._experimental_afterQuery?.(
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      client.getQueryCache().get(defaultedOptions.queryHash)?.promise
    );
    promise?.catch(noop$2).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

function useQuery(options, queryClient) {
  return useBaseQuery(options, QueryObserver);
}

function useMutation(options, queryClient) {
  const client = useQueryClient();
  const [observer] = scoping__loadShare__react__loadShare__.useState(
    () => new MutationObserver$1(
      client,
      options
    )
  );
  scoping__loadShare__react__loadShare__.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = scoping__loadShare__react__loadShare__.useSyncExternalStore(
    scoping__loadShare__react__loadShare__.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = scoping__loadShare__react__loadShare__.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$2);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

function useInfiniteQuery(options, queryClient) {
  return useBaseQuery(
    options,
    InfiniteQueryObserver);
}

function bind$3(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray: isArray$5} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString$3 = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction$1 = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber$1 = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject$1 = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean$1 = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject$1 = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate$2 = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction$1(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction$1(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray$5(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge$1(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$1(result[targetKey]) && isPlainObject$1(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject$1(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$5(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend$1 = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a[key] = bind$3(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray$5(thing)) return thing;
  let i = thing.length;
  if (!isNumber$1(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty$2 = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp$2 = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction$1(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction$1(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray$5(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop$1 = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray$5(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction$1(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************

const utils$4 = {
  isArray: isArray$5,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$3,
  isNumber: isNumber$1,
  isBoolean: isBoolean$1,
  isObject: isObject$1,
  isPlainObject: isPlainObject$1,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate: isDate$2,
  isFile,
  isBlob,
  isRegExp: isRegExp$2,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend: extend$1,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$2,
  hasOwnProp: hasOwnProperty$2, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$4.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$4.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$4.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

// eslint-disable-next-line strict
const httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$4.isPlainObject(thing) || utils$4.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$4.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$4.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$4.toFlatObject(utils$4, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$4.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$4.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$4.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$4.isSpecCompliantForm(formData);

  if (!utils$4.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$4.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$4.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$4.isArrayBuffer(value) || utils$4.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$4.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$4.isArray(value) && isFlatArray(value)) ||
        ((utils$4.isFileList(value) || utils$4.endsWith(key, '[]')) && (arr = utils$4.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$4.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$4.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$4.forEach(value, function each(el, key) {
      const result = !(utils$4.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$4.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$4.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$2(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$2);
  } : encode$2;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode$1(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode$1;

  if (utils$4.isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$4.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$4.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

const URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

const FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

const Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

const utils$3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: 'Module' }));

const platform = {
  ...utils$3,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$4.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$4.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject$1(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$4.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$4.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$4.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$4.isArray(target[name])) {
      target[name] = arrayToObject$1(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$4.isFormData(formData) && utils$4.isFunction(formData.entries)) {
    const obj = {};

    utils$4.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$4.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$4.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults$3 = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$4.isObject(data);

    if (isObjectPayload && utils$4.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$4.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$4.isArrayBuffer(data) ||
      utils$4.isBuffer(data) ||
      utils$4.isStream(data) ||
      utils$4.isFile(data) ||
      utils$4.isBlob(data) ||
      utils$4.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$4.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$4.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$4.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults$3.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$4.isResponse(data) || utils$4.isReadableStream(data)) {
      return data;
    }

    if (data && utils$4.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$4.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults$3.headers[method] = {};
});

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$4.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
const parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$4.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$4.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$4.isString(value)) return;

  if (utils$4.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$4.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$4.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$4.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$4.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$4.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$4.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$4.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$4.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$4.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$4.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$4.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$4.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$4.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$4.forEach(this, (value, header) => {
      const key = utils$4.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$4.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$4.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$4.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$4.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$4.freezeMethods(AxiosHeaders);

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$3;
  const context = response || config;
  const headers = AxiosHeaders.from(context.headers);
  let data = context.data;

  utils$4.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$4.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$4.asap(() => fn(...args));

const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, platform.origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;

const cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$4.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$4.isString(path) && cookie.push('path=' + path);

      utils$4.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig$1(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (utils$4.isPlainObject(target) && utils$4.isPlainObject(source)) {
      return utils$4.merge.call({caseless}, target, source);
    } else if (utils$4.isPlainObject(source)) {
      return utils$4.merge({}, source);
    } else if (utils$4.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!utils$4.isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$4.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$4.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  utils$4.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$4.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$4.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$4.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

const xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$4.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$4.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils$4.asap(unsubscribe);

    return signal;
  }
};

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$4.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$4.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$4.isBlob(body)) {
    return body.size;
  }

  if(utils$4.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils$4.isArrayBufferView(body) || utils$4.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$4.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$4.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$4.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$4.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils$4.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$4.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$4.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$4.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$4.isFunction(adapter) || adapter === null || adapter === false;

const adapters = {
  getAdapter: (adapters) => {
    adapters = utils$4.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$3.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const VERSION = "1.8.4";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

const validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig$1(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$4.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    validator.assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$4.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$4.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$4.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$4.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$4.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind$3(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils$4.extend(instance, Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$4.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$3);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig$1;

axios.AxiosHeaders = AxiosHeaders;

axios.formToJSON = thing => formDataToJSON(utils$4.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode;

axios.default = axios;

/** @type {import('./type')} */
var type = TypeError;

const __viteBrowserExternal = {};

const __viteBrowserExternal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0 = /*@__PURE__*/getAugmentedNamespace(__viteBrowserExternal$1);

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString$1 = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace$1 = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat$1 = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1e3 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace$1.call(intStr, sepRegex, '$&_') + '.' + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace$1.call(str, sepRegex, '$&_');
}

var utilInspect = require$$0;
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol$1(inspectCustom) ? inspectCustom : null;

var quotes = {
    __proto__: null,
    'double': '"',
    single: "'"
};
var quoteREs = {
    __proto__: null,
    'double': /(["\\])/g,
    single: /(['\\])/g
};

var objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has$3(opts, 'quoteStyle') && !has$3(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has$3(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has$3(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has$3(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has$3(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray$4(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has$3(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp$1(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol$1(obj)) {
        var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray$4(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat$1.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap$1(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet$1(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString$2(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (
        (typeof globalThis !== 'undefined' && obj === globalThis)
        || (typeof commonjsGlobal !== 'undefined' && obj === commonjsGlobal)
    ) {
        return '{ [object globalThis] }';
    }
    if (!isDate$1(obj) && !isRegExp$1(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat$1.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace$1.call(String(s), /"/g, '&quot;');
}

function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
}
function isArray$4(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
function isDate$1(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
function isRegExp$1(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
function isString$2(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol$1(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn$2 = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has$3(obj, key) {
    return hasOwn$2.call(obj, key);
}

function toStr(obj) {
    return objectToString$1.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap$1(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet$1(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
    quoteRE.lastIndex = 0;
    // eslint-disable-next-line no-control-regex
    var s = $replace$1.call($replace$1.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray$4(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has$3(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has$3(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}

var inspect$3 = objectInspect;

var $TypeError$5 = type;

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode} */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	// eslint-disable-next-line eqeqeq
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
			}
			return curr;
		}
	}
};

/** @type {import('./list.d.ts').listGet} */
var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	}
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('./list.d.ts').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('./list.d.ts').listHas} */
var listHas = function (objects, key) {
	if (!objects) {
		return false;
	}
	return !!listGetNode(objects, key);
};
/** @type {import('./list.d.ts').listDelete} */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	}
};

/** @type {import('.')} */
var sideChannelList = function getSideChannelList() {
	/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError$5('Side channel does not contain ' + inspect$3(key));
			}
		},
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			}
			return !!deletedNode;
		},
		get: function (key) {
			return listGet($o, key);
		},
		has: function (key) {
			return listHas($o, key);
		},
		set: function (key, value) {
			if (!$o) {
				// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
				$o = {
					next: void undefined
				};
			}
			// eslint-disable-next-line no-extra-parens
			listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};

/** @type {import('.')} */
var esObjectAtoms = Object;

/** @type {import('.')} */
var esErrors = Error;

/** @type {import('./eval')} */
var _eval = EvalError;

/** @type {import('./range')} */
var range$1 = RangeError;

/** @type {import('./ref')} */
var ref = ReferenceError;

/** @type {import('./syntax')} */
var syntax = SyntaxError;

/** @type {import('./uri')} */
var uri = URIError;

/** @type {import('./abs')} */
var abs$1 = Math.abs;

/** @type {import('./floor')} */
var floor$1 = Math.floor;

/** @type {import('./max')} */
var max$1 = Math.max;

/** @type {import('./min')} */
var min$1 = Math.min;

/** @type {import('./pow')} */
var pow$1 = Math.pow;

/** @type {import('./round')} */
var round$1 = Math.round;

/** @type {import('./isNaN')} */
var _isNaN = Number.isNaN || function isNaN(a) {
	return a !== a;
};

var $isNaN = _isNaN;

/** @type {import('./sign')} */
var sign$1 = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : 1;
};

/** @type {import('./gOPD')} */
var gOPD = Object.getOwnPropertyDescriptor;

/** @type {import('.')} */
var $gOPD$1 = gOPD;

if ($gOPD$1) {
	try {
		$gOPD$1([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD$1 = null;
	}
}

var gopd = $gOPD$1;

/** @type {import('.')} */
var $defineProperty$1 = Object.defineProperty || false;
if ($defineProperty$1) {
	try {
		$defineProperty$1({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty$1 = false;
	}
}

var esDefineProperty = $defineProperty$1;

var shams;
var hasRequiredShams;

function requireShams () {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;

	/** @type {import('./shams')} */
	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	shams = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			// eslint-disable-next-line no-extra-parens
			var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};
	return shams;
}

var hasSymbols$1;
var hasRequiredHasSymbols;

function requireHasSymbols () {
	if (hasRequiredHasSymbols) return hasSymbols$1;
	hasRequiredHasSymbols = 1;

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = requireShams();

	/** @type {import('.')} */
	hasSymbols$1 = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return hasSymbolSham();
	};
	return hasSymbols$1;
}

var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;

function requireReflect_getPrototypeOf () {
	if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
	hasRequiredReflect_getPrototypeOf = 1;

	/** @type {import('./Reflect.getPrototypeOf')} */
	Reflect_getPrototypeOf = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;
	return Reflect_getPrototypeOf;
}

var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;

function requireObject_getPrototypeOf () {
	if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
	hasRequiredObject_getPrototypeOf = 1;

	var $Object = esObjectAtoms;

	/** @type {import('./Object.getPrototypeOf')} */
	Object_getPrototypeOf = $Object.getPrototypeOf || null;
	return Object_getPrototypeOf;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';

	var concatty = function concatty(a, b) {
	    var arr = [];

	    for (var i = 0; i < a.length; i += 1) {
	        arr[i] = a[i];
	    }
	    for (var j = 0; j < b.length; j += 1) {
	        arr[j + a.length] = b[j];
	    }

	    return arr;
	};

	var slicy = function slicy(arrLike, offset) {
	    var arr = [];
	    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
	        arr[j] = arrLike[i];
	    }
	    return arr;
	};

	var joiny = function (arr, joiner) {
	    var str = '';
	    for (var i = 0; i < arr.length; i += 1) {
	        str += arr[i];
	        if (i + 1 < arr.length) {
	            str += joiner;
	        }
	    }
	    return str;
	};

	implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slicy(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                concatty(args, arguments)
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        }
	        return target.apply(
	            that,
	            concatty(args, arguments)
	        );

	    };

	    var boundLength = max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs[i] = '$' + i;
	    }

	    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};
	return implementation;
}

var functionBind;
var hasRequiredFunctionBind;

function requireFunctionBind () {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;

	var implementation = requireImplementation();

	functionBind = Function.prototype.bind || implementation;
	return functionBind;
}

var functionCall;
var hasRequiredFunctionCall;

function requireFunctionCall () {
	if (hasRequiredFunctionCall) return functionCall;
	hasRequiredFunctionCall = 1;

	/** @type {import('./functionCall')} */
	functionCall = Function.prototype.call;
	return functionCall;
}

var functionApply;
var hasRequiredFunctionApply;

function requireFunctionApply () {
	if (hasRequiredFunctionApply) return functionApply;
	hasRequiredFunctionApply = 1;

	/** @type {import('./functionApply')} */
	functionApply = Function.prototype.apply;
	return functionApply;
}

/** @type {import('./reflectApply')} */
var reflectApply = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;

var bind$2 = requireFunctionBind();

var $apply$1 = requireFunctionApply();
var $call$2 = requireFunctionCall();
var $reflectApply = reflectApply;

/** @type {import('./actualApply')} */
var actualApply = $reflectApply || bind$2.call($call$2, $apply$1);

var bind$1 = requireFunctionBind();
var $TypeError$4 = type;

var $call$1 = requireFunctionCall();
var $actualApply = actualApply;

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
var callBindApplyHelpers = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError$4('a function is required');
	}
	return $actualApply(bind$1, $call$1, args);
};

var get$1;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get$1;
	hasRequiredGet = 1;

	var callBind = callBindApplyHelpers;
	var gOPD = gopd;

	var hasProtoAccessor;
	try {
		// eslint-disable-next-line no-extra-parens, no-proto
		hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
			throw e;
		}
	}

	// eslint-disable-next-line no-extra-parens
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

	var $Object = Object;
	var $getPrototypeOf = $Object.getPrototypeOf;

	/** @type {import('./get')} */
	get$1 = desc && typeof desc.get === 'function'
		? callBind([desc.get])
		: typeof $getPrototypeOf === 'function'
			? /** @type {import('./get')} */ function getDunder(value) {
				// eslint-disable-next-line eqeqeq
				return $getPrototypeOf(value == null ? value : $Object(value));
			}
			: false;
	return get$1;
}

var getProto$2;
var hasRequiredGetProto;

function requireGetProto () {
	if (hasRequiredGetProto) return getProto$2;
	hasRequiredGetProto = 1;

	var reflectGetProto = requireReflect_getPrototypeOf();
	var originalGetProto = requireObject_getPrototypeOf();

	var getDunderProto = /*@__PURE__*/ requireGet();

	/** @type {import('.')} */
	getProto$2 = reflectGetProto
		? function getProto(O) {
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return reflectGetProto(O);
		}
		: originalGetProto
			? function getProto(O) {
				if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
					throw new TypeError('getProto: not an object');
				}
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return originalGetProto(O);
			}
			: getDunderProto
				? function getProto(O) {
					// @ts-expect-error TS can't narrow inside a closure, for some reason
					return getDunderProto(O);
				}
				: null;
	return getProto$2;
}

var hasown;
var hasRequiredHasown;

function requireHasown () {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;

	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = requireFunctionBind();

	/** @type {import('.')} */
	hasown = bind.call(call, $hasOwn);
	return hasown;
}

var undefined$1;

var $Object = esObjectAtoms;

var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range$1;
var $ReferenceError = ref;
var $SyntaxError = syntax;
var $TypeError$3 = type;
var $URIError = uri;

var abs = abs$1;
var floor = floor$1;
var max = max$1;
var min = min$1;
var pow = pow$1;
var round = round$1;
var sign = sign$1;

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = gopd;
var $defineProperty = esDefineProperty;

var throwTypeError = function () {
	throw new $TypeError$3();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = requireHasSymbols()();

var getProto$1 = requireGetProto();
var $ObjectGPO = requireObject_getPrototypeOf();
var $ReflectGPO = requireReflect_getPrototypeOf();

var $apply = requireFunctionApply();
var $call = requireFunctionCall();

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
	'%AsyncFromSyncIteratorPrototype%': undefined$1,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined$1 : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
	'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto$1 ? getProto$1(''[Symbol.iterator]()) : undefined$1,
	'%Symbol%': hasSymbols ? Symbol : undefined$1,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError$3,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto$1) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto$1(getProto$1(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto$1) {
			value = getProto$1(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = requireFunctionBind();
var hasOwn$1 = /*@__PURE__*/ requireHasown();
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn$1(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError$3('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

var getIntrinsic = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError$3('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError$3('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError$3('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined$1;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn$1(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

var GetIntrinsic$2 = getIntrinsic;

var callBindBasic = callBindApplyHelpers;

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic$2('%String.prototype.indexOf%')]);

/** @type {import('.')} */
var callBound$2 = function callBoundIntrinsic(name, allowMissing) {
	/* eslint no-extra-parens: 0 */

	var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic$2(name, !!allowMissing));
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBindBasic(/** @type {const} */ ([intrinsic]));
	}
	return intrinsic;
};

var GetIntrinsic$1 = getIntrinsic;
var callBound$1 = callBound$2;
var inspect$2 = objectInspect;

var $TypeError$2 = type;
var $Map = GetIntrinsic$1('%Map%', true);

/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
var $mapGet = callBound$1('Map.prototype.get', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
var $mapSet = callBound$1('Map.prototype.set', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapHas = callBound$1('Map.prototype.has', true);
/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
var $mapDelete = callBound$1('Map.prototype.delete', true);
/** @type {<K, V>(thisArg: Map<K, V>) => number} */
var $mapSize = callBound$1('Map.prototype.size', true);

/** @type {import('.')} */
var sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
	/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
	/** @typedef {Parameters<Channel['get']>[0]} K */
	/** @typedef {Parameters<Channel['set']>[1]} V */

	/** @type {Map<K, V> | undefined} */ var $m;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError$2('Side channel does not contain ' + inspect$2(key));
			}
		},
		'delete': function (key) {
			if ($m) {
				var result = $mapDelete($m, key);
				if ($mapSize($m) === 0) {
					$m = void undefined;
				}
				return result;
			}
			return false;
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($m) {
				return $mapGet($m, key);
			}
		},
		has: function (key) {
			if ($m) {
				return $mapHas($m, key);
			}
			return false;
		},
		set: function (key, value) {
			if (!$m) {
				// @ts-expect-error TS can't handle narrowing a variable inside a closure
				$m = new $Map();
			}
			$mapSet($m, key, value);
		}
	};

	// @ts-expect-error TODO: figure out why TS is erroring here
	return channel;
};

var GetIntrinsic = getIntrinsic;
var callBound = callBound$2;
var inspect$1 = objectInspect;
var getSideChannelMap$1 = sideChannelMap;

var $TypeError$1 = type;
var $WeakMap = GetIntrinsic('%WeakMap%', true);

/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
var $weakMapGet = callBound('WeakMap.prototype.get', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
var $weakMapSet = callBound('WeakMap.prototype.set', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapHas = callBound('WeakMap.prototype.has', true);
/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

/** @type {import('.')} */
var sideChannelWeakmap = $WeakMap
	? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
		/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
		/** @type {Channel | undefined} */ var $m;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError$1('Side channel does not contain ' + inspect$1(key));
				}
			},
			'delete': function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapDelete($wm, key);
					}
				} else if (getSideChannelMap$1) {
					if ($m) {
						return $m['delete'](key);
					}
				}
				return false;
			},
			get: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				}
				return $m && $m.get(key);
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				}
				return !!$m && $m.has(key);
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if (getSideChannelMap$1) {
					if (!$m) {
						$m = getSideChannelMap$1();
					}
					// eslint-disable-next-line no-extra-parens
					/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
				}
			}
		};

		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	}
	: getSideChannelMap$1;

var $TypeError = type;
var inspect = objectInspect;
var getSideChannelList = sideChannelList;
var getSideChannelMap = sideChannelMap;
var getSideChannelWeakMap = sideChannelWeakmap;

var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

/** @type {import('.')} */
var sideChannel = function getSideChannel() {
	/** @typedef {ReturnType<typeof getSideChannel>} Channel */

	/** @type {Channel | undefined} */ var $channelData;

	/** @type {Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		'delete': function (key) {
			return !!$channelData && $channelData['delete'](key);
		},
		get: function (key) {
			return $channelData && $channelData.get(key);
		},
		has: function (key) {
			return !!$channelData && $channelData.has(key);
		},
		set: function (key, value) {
			if (!$channelData) {
				$channelData = makeChannel();
			}

			$channelData.set(key, value);
		}
	};
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
};

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

var formats$3 = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};

var formats$2 = formats$3;

var has$2 = Object.prototype.hasOwnProperty;
var isArray$3 = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray$3(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object' && typeof source !== 'function') {
        if (isArray$3(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if (
                (options && (options.plainObjects || options.allowPrototypes))
                || !has$2.call(Object.prototype, source)
            ) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray$3(target) && !isArray$3(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray$3(target) && isArray$3(source)) {
        source.forEach(function (item, i) {
            if (has$2.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has$2.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats$2.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray$3(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

var utils$2 = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};

var getSideChannel = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray$2 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats$1['default'];
var defaults$2 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils$1.encode,
    encodeValuesOnly: false,
    filter: void undefined,
    format: defaultFormat,
    formatter: formats$1.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify$1 = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray$2(obj)) {
        obj = utils$1.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults$2.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$2.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$2.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray$2(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils$1.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray$2(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);

    var adjustedPrefix = commaRoundTrip && isArray$2(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray$2(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'
            ? key.value
            : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
        var keyPrefix = isArray$2(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray$2(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults$2;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults$2.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats$1['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has$1.call(formats$1.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats$1.formatters[format];

    var filter = defaults$2.filter;
    if (typeof opts.filter === 'function' || isArray$2(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults$2.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults$2.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults$2.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults$2.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$2.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults$2.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults$2.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults$2.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults$2.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults$2.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults$2.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults$2.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$2.strictNullHandling
    };
};

var stringify_1 = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray$2(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];

        if (options.skipNulls && value === null) {
            continue;
        }
        pushToArray(keys, stringify$1(
            value,
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};

var utils = utils$2;

var has = Object.prototype.hasOwnProperty;
var isArray$1 = Array.isArray;

var defaults$1 = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options, currentArrayLength) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');

    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
    );

    if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
    }

    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key;
        var val;
        if (pos === -1) {
            key = options.decoder(part, defaults$1.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, 'key');

            val = utils.maybeMap(
                parseArrayValue(
                    part.slice(pos + 1),
                    options,
                    isArray$1(obj[key]) ? obj[key].length : 0
                ),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults$1.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(String(val));
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray$1(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
        var parentKey = chain.slice(0, -1).join('');
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }

    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
                ? []
                : utils.combine([], leaf);
        } else {
            obj = options.plainObjects ? { __proto__: null } : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
        if (options.strictDepth === true) {
            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
        }
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults$1;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
    }

    var charset = typeof opts.charset === 'undefined' ? defaults$1.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults$1.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults$1.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults$1.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults$1.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults$1.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults$1.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults$1.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults$1.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults$1.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults$1.plainObjects,
        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults$1.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
    };
};

var parse$2 = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? { __proto__: null } : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};

var stringify = stringify_1;
var parse$1 = parse$2;
var formats = formats$3;

var lib = {
    formats: formats,
    parse: parse$1,
    stringify: stringify
};

const qs = /*@__PURE__*/getDefaultExportFromCjs$1(lib);

/**
* @vue/shared v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$1(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

/**
* @vue/reactivity v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  const dep = computed2.dep;
  computed2.flags |= 2;
  if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
    computed2.flags &= -3;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0);
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getInnerChild$1(oldChild);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString$1(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback)],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || ([]),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data)) ; else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ; else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ; else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) ; else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function initFeatureFlags() {
  if (typeof __VUE_OPTIONS_API__ !== "boolean") {
    getGlobalThis().__VUE_OPTIONS_API__ = true;
  }
  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
    getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance);
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    instance.render = Component.render || NOOP;
  }
  if (__VUE_OPTIONS_API__ && true) {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h$b(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version = "3.5.12";

/**
* @vue/runtime-dom v3.5.12
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt$2 = typeof window !== "undefined" && window.trustedTypes;
if (tt$2) {
  try {
    policy = /* @__PURE__ */ tt$2.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h$b(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      addTransitionClass(el, leaveActiveClass);
      forceReflow();
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$1(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$a = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$a.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  const Comp = defineComponent(options, extraOptions);
  if (isPlainObject(Comp)) extend(Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    this._instance = null;
    this._app = null;
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if (_def.shadowRoot !== false) {
        this.attachShadow({ mode: "open" });
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
    if (!this._def.__asyncLoader) {
      this._resolveProps(this._def);
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._setParent();
        this._update();
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._instance.provides = parent._instance.provides;
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def;
      let numberProps;
      if (props && !isArray(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def);
      }
      if (this.shadowRoot) {
        this._applyStyles(styles);
      }
      this._mount(def);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then(
        (def) => resolve(this._def = def, true)
      );
    } else {
      resolve(this._def);
    }
  }
  _mount(def) {
    this._app = this._createApp(def);
    if (def.configureApp) {
      def.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!hasOwn(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => unref(exposed[key])
        });
      }
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = camelize(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = createVNode(this._def, extend(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              isPlainObject(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = (this._teleportTarget || this).querySelectorAll("slot");
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
const assignKey = Symbol("_assign");
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}

const r$9 = (t) => {
  const n = document?.querySelector('meta[name="csp-nonce"]')?.getAttribute("content") || "";
  return defineCustomElement(t, { nonce: n });
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var g$8 = function() {
  return g$8 = Object.assign || function(e) {
    for (var r, l = 1, a = arguments.length; l < a; l++) {
      r = arguments[l];
      for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }, g$8.apply(this, arguments);
};
function v$8(t, e) {
  return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t)) + t;
}
var c$b = 0, o$c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", s$7 = {
  genUID: function() {
    return c$b++, c$b + "_" + [1, 2, 3, 4, 5].map(function() {
      return o$c[v$8(0, o$c.length)];
    }).join("");
  }
}, u$9 = {
  defaultWidth: "",
  defaultHeight: "",
  classPrefix: "svg",
  isStroke: false,
  isOriginalDefault: false
};
function w$a(t) {
  return t = g$8({}, t), Object.keys(t).forEach(function(e) {
    t[e] === void 0 && delete t[e];
  }), typeof t.original == "string" && (t.original = true), typeof t.fill == "string" && (t.fill = true), g$8({
    width: u$9.defaultWidth,
    height: u$9.defaultHeight,
    fill: !u$9.isStroke,
    original: !!u$9.isOriginalDefault
  }, t);
}
function y$d(t) {
  return Array.isArray(t.color) ? t.color : t.color ? t.color.split(" ") : [];
}
function x$2(t) {
  var e = u$9.classPrefix + "-icon";
  return t.fill && (e += " " + u$9.classPrefix + "-fill"), t.dir && (e += " " + u$9.classPrefix + "-" + t.dir), e;
}
function b$8(t, e) {
  if (e.title) {
    var r = e.title.replace(/</gi, "&lt;").replace(/>/gi, "&gt;").replace(/&/g, "&amp;");
    return "<title>" + r + "</title>" + t;
  }
  return t;
}
function m$e(t) {
  var e = /_fill="|_stroke="/gi;
  return t.replace(e, function(r) {
    return r && r.slice(1);
  });
}
function _$4(t, e, r) {
  if (e.original && r.length > 0) {
    var l = /<(path|rect|circle|polygon|line|polyline|ellipse)(\sfill|\sstroke)([="\w\s.\-+#$&>]+)(fill|stroke)/gi;
    t = t.replace(l, function(a, i, n, f, h) {
      return "<" + i + n + f + "_" + h;
    });
  }
  return t;
}
function C$8(t, e, r) {
  var l = /<(path|rect|circle|polygon|line|polyline|ellipse)\s/gi, a = 0;
  return t.replace(l, function(i) {
    var n = r[a++] || r[r.length - 1], f = e.fill;
    if (n && n === "_")
      return i;
    n && /^r-/.test(n) && (f = !f, n = n.substr(2));
    var h = f ? "fill" : "stroke", d = f ? "stroke" : "fill";
    return i + (h + '="' + n + '" ' + d + '="none" ');
  });
}
function P$5(t, e) {
  var r = /stop-color="([\w,#\s'()-_]+)"/gi, l = e.stopColors || [], a = 0;
  return t.replace(r, function(i, n) {
    return n = l[a++] || n, 'stop-color="' + n + '"';
  });
}
function S$6(t, e, r) {
  var l, a = s$7.genUID(), i = "";
  if (r) {
    i = r.data, i = b$8(i, t), t.original && (i = m$e(i)), e.length > 0 && (i = C$8(i, t, e)), !((l = t.stopColors) === null || l === void 0) && l.length && (i = P$5(i, t));
    var n = /svgiconid([\w-/\\]+)/g;
    i = i.replace(n, function(f, h) {
      return "svgiconid" + h + "_" + a;
    }), t.replace && (i = t.replace(i));
  }
  return _$4(i, t, e);
}
function O$3(t, e) {
  if (e)
    return e.viewBox ? e.viewBox : "0 0 " + e.width + " " + e.height;
  var r = typeof t.width == "number" ? t.width : parseFloat(t.width || "16"), l = typeof t.height == "number" ? t.height : parseFloat(t.height || "16");
  return "0 0 " + r + " " + l;
}
function k$7(t, e) {
  var r = /^\d+$/, l = t.scale, a = l !== "" && l !== void 0 && l !== null, i, n;
  a && e && e.width && e.height ? (i = Number(e.width) * Number(l) + "px", n = Number(e.height) * Number(l) + "px") : (i = r.test(String(t.width || "")) ? t.width + "px" : t.width || u$9.defaultWidth, n = r.test(String(t.height || "")) ? t.height + "px" : t.height || u$9.defaultHeight);
  var f = {};
  return i && (f.width = i), n && (f.height = n), f;
}
function N$4(t) {
  u$9 = g$8(g$8({}, u$9), t);
}
function j$3() {
  return [
    "data",
    "color",
    "stopColors",
    "dir",
    "fill",
    "height",
    "width",
    "title",
    "scale",
    "original",
    "replace"
  ];
}
function I$4(t) {
  t = w$a(t);
  var e = y$d(t), r = t.data && t.data.data ? t.data.data : null, l = S$6(t, e, r), a = x$2(t), i = O$3(t, r), n = k$7(t, r);
  return {
    path: l,
    box: i,
    className: a,
    style: n
  };
}

/*! @license DOMPurify 3.0.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.6/LICENSE */
const {
  entries: st$1,
  setPrototypeOf: tt$1,
  isFrozen: vt$1,
  getPrototypeOf: Ut,
  getOwnPropertyDescriptor: ct$1
} = Object;
let {
  freeze: E$7,
  seal: L$4,
  create: ft$1
} = Object, {
  apply: ye,
  construct: be
} = typeof Reflect < "u" && Reflect;
E$7 || (E$7 = function(i) {
  return i;
});
L$4 || (L$4 = function(i) {
  return i;
});
ye || (ye = function(i, s, r) {
  return i.apply(s, r);
});
be || (be = function(i, s) {
  return new i(...s);
});
const ee = R$3(Array.prototype.forEach), nt$1 = R$3(Array.prototype.pop), Y$1 = R$3(Array.prototype.push), oe = R$3(String.prototype.toLowerCase), Re = R$3(String.prototype.toString), Ft$1 = R$3(String.prototype.match), X$1 = R$3(String.prototype.replace), Ht = R$3(String.prototype.indexOf), zt = R$3(String.prototype.trim), S$5 = R$3(RegExp.prototype.test), V$2 = Gt(TypeError);
function R$3(l) {
  return function(i) {
    for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), _ = 1; _ < s; _++)
      r[_ - 1] = arguments[_];
    return ye(l, i, r);
  };
}
function Gt(l) {
  return function() {
    for (var i = arguments.length, s = new Array(i), r = 0; r < i; r++)
      s[r] = arguments[r];
    return be(l, s);
  };
}
function a$j(l, i) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : oe;
  tt$1 && tt$1(l, null);
  let r = i.length;
  for (; r--; ) {
    let _ = i[r];
    if (typeof _ == "string") {
      const D = s(_);
      D !== _ && (vt$1(i) || (i[r] = D), _ = D);
    }
    l[_] = true;
  }
  return l;
}
function H$2(l) {
  const i = ft$1(null);
  for (const [s, r] of st$1(l))
    ct$1(l, s) !== void 0 && (i[s] = r);
  return i;
}
function te(l, i) {
  for (; l !== null; ) {
    const r = ct$1(l, i);
    if (r) {
      if (r.get)
        return R$3(r.get);
      if (typeof r.value == "function")
        return R$3(r.value);
    }
    l = Ut(l);
  }
  function s(r) {
    return console.warn("fallback value for", r), null;
  }
  return s;
}
const ot = E$7(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Le = E$7(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Ne = E$7(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Wt = E$7(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), De = E$7(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Bt = E$7(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), it$1 = E$7(["#text"]), at$1 = E$7(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), Oe = E$7(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), rt$1 = E$7(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), ne = E$7(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Yt = L$4(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Xt = L$4(/<%[\w\W]*|[\w\W]*%>/gm), Vt = L$4(/\${[\w\W]*}/gm), jt = L$4(/^data-[\-\w.\u00B7-\uFFFF]/), qt = L$4(/^aria-[\-\w]+$/), ut$1 = L$4(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), $t = L$4(/^(?:\w+script|data):/i), Kt = L$4(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), mt$1 = L$4(/^html$/i);
var lt$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: Yt,
  ERB_EXPR: Xt,
  TMPLIT_EXPR: Vt,
  DATA_ATTR: jt,
  ARIA_ATTR: qt,
  IS_ALLOWED_URI: ut$1,
  IS_SCRIPT_OR_DATA: $t,
  ATTR_WHITESPACE: Kt,
  DOCTYPE_NAME: mt$1
});
const Zt = function() {
  return typeof window > "u" ? null : window;
}, Jt = function(i, s) {
  if (typeof i != "object" || typeof i.createPolicy != "function")
    return null;
  let r = null;
  const _ = "data-tt-policy-suffix";
  s && s.hasAttribute(_) && (r = s.getAttribute(_));
  const D = "dompurify" + (r ? "#" + r : "");
  try {
    return i.createPolicy(D, {
      createHTML(w) {
        return w;
      },
      createScriptURL(w) {
        return w;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + D + " could not be created."), null;
  }
};
function pt$1() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Zt();
  const i = (o) => pt$1(o);
  if (i.version = "3.0.6", i.removed = [], !l || !l.document || l.document.nodeType !== 9)
    return i.isSupported = false, i;
  let {
    document: s
  } = l;
  const r = s, _ = r.currentScript, {
    DocumentFragment: D,
    HTMLTemplateElement: w,
    Node: ie,
    Element: Ie,
    NodeFilter: ae,
    NamedNodeMap: dt = l.NamedNodeMap || l.MozNamedAttrMap,
    HTMLFormElement: Tt,
    DOMParser: _t,
    trustedTypes: j
  } = l, q = Ie.prototype, gt = te(q, "cloneNode"), Et = te(q, "nextSibling"), ht = te(q, "childNodes"), re = te(q, "parentNode");
  if (typeof w == "function") {
    const o = s.createElement("template");
    o.content && o.content.ownerDocument && (s = o.content.ownerDocument);
  }
  let g, z = "";
  const {
    implementation: le,
    createNodeIterator: At,
    createDocumentFragment: St,
    getElementsByTagName: Rt
  } = s, {
    importNode: Lt
  } = r;
  let N = {};
  i.isSupported = typeof st$1 == "function" && typeof re == "function" && le && le.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: se,
    ERB_EXPR: ce,
    TMPLIT_EXPR: fe,
    DATA_ATTR: Nt,
    ARIA_ATTR: Dt,
    IS_SCRIPT_OR_DATA: Ot,
    ATTR_WHITESPACE: Ce
  } = lt$1;
  let {
    IS_ALLOWED_URI: Me
  } = lt$1, u = null;
  const we = a$j({}, [...ot, ...Le, ...Ne, ...De, ...it$1]);
  let m = null;
  const xe = a$j({}, [...at$1, ...Oe, ...rt$1, ...ne]);
  let f = Object.seal(ft$1(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  })), G = null, ue = null, Pe = true, me = true, ke = false, ve = true, x = false, b = false, pe = false, de = false, P = false, $ = false, K = false, Ue = true, Fe = false;
  const yt = "user-content-";
  let Te = true, W = false, k = {}, v = null;
  const He = a$j({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let ze = null;
  const Ge = a$j({}, ["audio", "video", "img", "source", "image", "track"]);
  let _e = null;
  const We = a$j({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Z = "http://www.w3.org/1998/Math/MathML", J = "http://www.w3.org/2000/svg", O = "http://www.w3.org/1999/xhtml";
  let U = O, ge = false, Ee = null;
  const bt = a$j({}, [Z, J, O], Re);
  let I = null;
  const It = ["application/xhtml+xml", "text/html"], Ct = "text/html";
  let p = null, F = null;
  const Mt = s.createElement("form"), Be = function(e) {
    return e instanceof RegExp || e instanceof Function;
  }, he = function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(F && F === e)) {
      if ((!e || typeof e != "object") && (e = {}), e = H$2(e), I = // eslint-disable-next-line unicorn/prefer-includes
      It.indexOf(e.PARSER_MEDIA_TYPE) === -1 ? I = Ct : I = e.PARSER_MEDIA_TYPE, p = I === "application/xhtml+xml" ? Re : oe, u = "ALLOWED_TAGS" in e ? a$j({}, e.ALLOWED_TAGS, p) : we, m = "ALLOWED_ATTR" in e ? a$j({}, e.ALLOWED_ATTR, p) : xe, Ee = "ALLOWED_NAMESPACES" in e ? a$j({}, e.ALLOWED_NAMESPACES, Re) : bt, _e = "ADD_URI_SAFE_ATTR" in e ? a$j(
        H$2(We),
        // eslint-disable-line indent
        e.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        p
        // eslint-disable-line indent
      ) : We, ze = "ADD_DATA_URI_TAGS" in e ? a$j(
        H$2(Ge),
        // eslint-disable-line indent
        e.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        p
        // eslint-disable-line indent
      ) : Ge, v = "FORBID_CONTENTS" in e ? a$j({}, e.FORBID_CONTENTS, p) : He, G = "FORBID_TAGS" in e ? a$j({}, e.FORBID_TAGS, p) : {}, ue = "FORBID_ATTR" in e ? a$j({}, e.FORBID_ATTR, p) : {}, k = "USE_PROFILES" in e ? e.USE_PROFILES : false, Pe = e.ALLOW_ARIA_ATTR !== false, me = e.ALLOW_DATA_ATTR !== false, ke = e.ALLOW_UNKNOWN_PROTOCOLS || false, ve = e.ALLOW_SELF_CLOSE_IN_ATTR !== false, x = e.SAFE_FOR_TEMPLATES || false, b = e.WHOLE_DOCUMENT || false, P = e.RETURN_DOM || false, $ = e.RETURN_DOM_FRAGMENT || false, K = e.RETURN_TRUSTED_TYPE || false, de = e.FORCE_BODY || false, Ue = e.SANITIZE_DOM !== false, Fe = e.SANITIZE_NAMED_PROPS || false, Te = e.KEEP_CONTENT !== false, W = e.IN_PLACE || false, Me = e.ALLOWED_URI_REGEXP || ut$1, U = e.NAMESPACE || O, f = e.CUSTOM_ELEMENT_HANDLING || {}, e.CUSTOM_ELEMENT_HANDLING && Be(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (f.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && Be(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (f.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (f.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), x && (me = false), $ && (P = true), k && (u = a$j({}, [...it$1]), m = [], k.html === true && (a$j(u, ot), a$j(m, at$1)), k.svg === true && (a$j(u, Le), a$j(m, Oe), a$j(m, ne)), k.svgFilters === true && (a$j(u, Ne), a$j(m, Oe), a$j(m, ne)), k.mathMl === true && (a$j(u, De), a$j(m, rt$1), a$j(m, ne))), e.ADD_TAGS && (u === we && (u = H$2(u)), a$j(u, e.ADD_TAGS, p)), e.ADD_ATTR && (m === xe && (m = H$2(m)), a$j(m, e.ADD_ATTR, p)), e.ADD_URI_SAFE_ATTR && a$j(_e, e.ADD_URI_SAFE_ATTR, p), e.FORBID_CONTENTS && (v === He && (v = H$2(v)), a$j(v, e.FORBID_CONTENTS, p)), Te && (u["#text"] = true), b && a$j(u, ["html", "head", "body"]), u.table && (a$j(u, ["tbody"]), delete G.tbody), e.TRUSTED_TYPES_POLICY) {
        if (typeof e.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw V$2('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof e.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw V$2('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        g = e.TRUSTED_TYPES_POLICY, z = g.createHTML("");
      } else
        g === void 0 && (g = Jt(j, _)), g !== null && typeof z == "string" && (z = g.createHTML(""));
      E$7 && E$7(e), F = e;
    }
  }, Ye = a$j({}, ["mi", "mo", "mn", "ms", "mtext"]), Xe = a$j({}, ["foreignobject", "desc", "title", "annotation-xml"]), wt = a$j({}, ["title", "style", "font", "a", "script"]), Q = a$j({}, Le);
  a$j(Q, Ne), a$j(Q, Wt);
  const Ae = a$j({}, De);
  a$j(Ae, Bt);
  const xt = function(e) {
    let t = re(e);
    (!t || !t.tagName) && (t = {
      namespaceURI: U,
      tagName: "template"
    });
    const n = oe(e.tagName), c = oe(t.tagName);
    return Ee[e.namespaceURI] ? e.namespaceURI === J ? t.namespaceURI === O ? n === "svg" : t.namespaceURI === Z ? n === "svg" && (c === "annotation-xml" || Ye[c]) : !!Q[n] : e.namespaceURI === Z ? t.namespaceURI === O ? n === "math" : t.namespaceURI === J ? n === "math" && Xe[c] : !!Ae[n] : e.namespaceURI === O ? t.namespaceURI === J && !Xe[c] || t.namespaceURI === Z && !Ye[c] ? false : !Ae[n] && (wt[n] || !Q[n]) : !!(I === "application/xhtml+xml" && Ee[e.namespaceURI]) : false;
  }, C = function(e) {
    Y$1(i.removed, {
      element: e
    });
    try {
      e.parentNode.removeChild(e);
    } catch {
      e.remove();
    }
  }, Se = function(e, t) {
    try {
      Y$1(i.removed, {
        attribute: t.getAttributeNode(e),
        from: t
      });
    } catch {
      Y$1(i.removed, {
        attribute: null,
        from: t
      });
    }
    if (t.removeAttribute(e), e === "is" && !m[e])
      if (P || $)
        try {
          C(t);
        } catch {
        }
      else
        try {
          t.setAttribute(e, "");
        } catch {
        }
  }, Ve = function(e) {
    let t = null, n = null;
    if (de)
      e = "<remove></remove>" + e;
    else {
      const T = Ft$1(e, /^[\r\n\t ]+/);
      n = T && T[0];
    }
    I === "application/xhtml+xml" && U === O && (e = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e + "</body></html>");
    const c = g ? g.createHTML(e) : e;
    if (U === O)
      try {
        t = new _t().parseFromString(c, I);
      } catch {
      }
    if (!t || !t.documentElement) {
      t = le.createDocument(U, "template", null);
      try {
        t.documentElement.innerHTML = ge ? z : c;
      } catch {
      }
    }
    const d = t.body || t.documentElement;
    return e && n && d.insertBefore(s.createTextNode(n), d.childNodes[0] || null), U === O ? Rt.call(t, b ? "html" : "body")[0] : b ? t.documentElement : d;
  }, je = function(e) {
    return At.call(
      e.ownerDocument || e,
      e,
      // eslint-disable-next-line no-bitwise
      ae.SHOW_ELEMENT | ae.SHOW_COMMENT | ae.SHOW_TEXT,
      null
    );
  }, Pt = function(e) {
    return e instanceof Tt && (typeof e.nodeName != "string" || typeof e.textContent != "string" || typeof e.removeChild != "function" || !(e.attributes instanceof dt) || typeof e.removeAttribute != "function" || typeof e.setAttribute != "function" || typeof e.namespaceURI != "string" || typeof e.insertBefore != "function" || typeof e.hasChildNodes != "function");
  }, qe = function(e) {
    return typeof ie == "function" && e instanceof ie;
  }, y = function(e, t, n) {
    N[e] && ee(N[e], (c) => {
      c.call(i, t, n, F);
    });
  }, $e = function(e) {
    let t = null;
    if (y("beforeSanitizeElements", e, null), Pt(e))
      return C(e), true;
    const n = p(e.nodeName);
    if (y("uponSanitizeElement", e, {
      tagName: n,
      allowedTags: u
    }), e.hasChildNodes() && !qe(e.firstElementChild) && S$5(/<[/\w]/g, e.innerHTML) && S$5(/<[/\w]/g, e.textContent))
      return C(e), true;
    if (!u[n] || G[n]) {
      if (!G[n] && Ze(n) && (f.tagNameCheck instanceof RegExp && S$5(f.tagNameCheck, n) || f.tagNameCheck instanceof Function && f.tagNameCheck(n)))
        return false;
      if (Te && !v[n]) {
        const c = re(e) || e.parentNode, d = ht(e) || e.childNodes;
        if (d && c) {
          const T = d.length;
          for (let h = T - 1; h >= 0; --h)
            c.insertBefore(gt(d[h], true), Et(e));
        }
      }
      return C(e), true;
    }
    return e instanceof Ie && !xt(e) || (n === "noscript" || n === "noembed" || n === "noframes") && S$5(/<\/no(script|embed|frames)/i, e.innerHTML) ? (C(e), true) : (x && e.nodeType === 3 && (t = e.textContent, ee([se, ce, fe], (c) => {
      t = X$1(t, c, " ");
    }), e.textContent !== t && (Y$1(i.removed, {
      element: e.cloneNode()
    }), e.textContent = t)), y("afterSanitizeElements", e, null), false);
  }, Ke = function(e, t, n) {
    if (Ue && (t === "id" || t === "name") && (n in s || n in Mt))
      return false;
    if (!(me && !ue[t] && S$5(Nt, t))) {
      if (!(Pe && S$5(Dt, t))) {
        if (!m[t] || ue[t]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Ze(e) && (f.tagNameCheck instanceof RegExp && S$5(f.tagNameCheck, e) || f.tagNameCheck instanceof Function && f.tagNameCheck(e)) && (f.attributeNameCheck instanceof RegExp && S$5(f.attributeNameCheck, t) || f.attributeNameCheck instanceof Function && f.attributeNameCheck(t)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            t === "is" && f.allowCustomizedBuiltInElements && (f.tagNameCheck instanceof RegExp && S$5(f.tagNameCheck, n) || f.tagNameCheck instanceof Function && f.tagNameCheck(n)))
          ) return false;
        } else if (!_e[t]) {
          if (!S$5(Me, X$1(n, Ce, ""))) {
            if (!((t === "src" || t === "xlink:href" || t === "href") && e !== "script" && Ht(n, "data:") === 0 && ze[e])) {
              if (!(ke && !S$5(Ot, X$1(n, Ce, "")))) {
                if (n)
                  return false;
              }
            }
          }
        }
      }
    }
    return true;
  }, Ze = function(e) {
    return e.indexOf("-") > 0;
  }, Je = function(e) {
    y("beforeSanitizeAttributes", e, null);
    const {
      attributes: t
    } = e;
    if (!t)
      return;
    const n = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: m
    };
    let c = t.length;
    for (; c--; ) {
      const d = t[c], {
        name: T,
        namespaceURI: h,
        value: M
      } = d, B = p(T);
      let A = T === "value" ? M : zt(M);
      if (n.attrName = B, n.attrValue = A, n.keepAttr = true, n.forceKeepAttr = void 0, y("uponSanitizeAttribute", e, n), A = n.attrValue, n.forceKeepAttr || (Se(T, e), !n.keepAttr))
        continue;
      if (!ve && S$5(/\/>/i, A)) {
        Se(T, e);
        continue;
      }
      x && ee([se, ce, fe], (et) => {
        A = X$1(A, et, " ");
      });
      const Qe = p(e.nodeName);
      if (Ke(Qe, B, A)) {
        if (Fe && (B === "id" || B === "name") && (Se(T, e), A = yt + A), g && typeof j == "object" && typeof j.getAttributeType == "function" && !h)
          switch (j.getAttributeType(Qe, B)) {
            case "TrustedHTML": {
              A = g.createHTML(A);
              break;
            }
            case "TrustedScriptURL": {
              A = g.createScriptURL(A);
              break;
            }
          }
        try {
          h ? e.setAttributeNS(h, T, A) : e.setAttribute(T, A), nt$1(i.removed);
        } catch {
        }
      }
    }
    y("afterSanitizeAttributes", e, null);
  }, kt = function o(e) {
    let t = null;
    const n = je(e);
    for (y("beforeSanitizeShadowDOM", e, null); t = n.nextNode(); )
      y("uponSanitizeShadowNode", t, null), !$e(t) && (t.content instanceof D && o(t.content), Je(t));
    y("afterSanitizeShadowDOM", e, null);
  };
  return i.sanitize = function(o) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = null, n = null, c = null, d = null;
    if (ge = !o, ge && (o = "<!-->"), typeof o != "string" && !qe(o))
      if (typeof o.toString == "function") {
        if (o = o.toString(), typeof o != "string")
          throw V$2("dirty is not a string, aborting");
      } else
        throw V$2("toString is not a function");
    if (!i.isSupported)
      return o;
    if (pe || he(e), i.removed = [], typeof o == "string" && (W = false), W) {
      if (o.nodeName) {
        const M = p(o.nodeName);
        if (!u[M] || G[M])
          throw V$2("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (o instanceof ie)
      t = Ve("<!---->"), n = t.ownerDocument.importNode(o, true), n.nodeType === 1 && n.nodeName === "BODY" || n.nodeName === "HTML" ? t = n : t.appendChild(n);
    else {
      if (!P && !x && !b && // eslint-disable-next-line unicorn/prefer-includes
      o.indexOf("<") === -1)
        return g && K ? g.createHTML(o) : o;
      if (t = Ve(o), !t)
        return P ? null : K ? z : "";
    }
    t && de && C(t.firstChild);
    const T = je(W ? o : t);
    for (; c = T.nextNode(); )
      $e(c) || (c.content instanceof D && kt(c.content), Je(c));
    if (W)
      return o;
    if (P) {
      if ($)
        for (d = St.call(t.ownerDocument); t.firstChild; )
          d.appendChild(t.firstChild);
      else
        d = t;
      return (m.shadowroot || m.shadowrootmode) && (d = Lt.call(r, d, true)), d;
    }
    let h = b ? t.outerHTML : t.innerHTML;
    return b && u["!doctype"] && t.ownerDocument && t.ownerDocument.doctype && t.ownerDocument.doctype.name && S$5(mt$1, t.ownerDocument.doctype.name) && (h = "<!DOCTYPE " + t.ownerDocument.doctype.name + `>
` + h), x && ee([se, ce, fe], (M) => {
      h = X$1(h, M, " ");
    }), g && K ? g.createHTML(h) : h;
  }, i.setConfig = function() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    he(o), pe = true;
  }, i.clearConfig = function() {
    F = null, pe = false;
  }, i.isValidAttribute = function(o, e, t) {
    F || he({});
    const n = p(o), c = p(e);
    return Ke(n, c, t);
  }, i.addHook = function(o, e) {
    typeof e == "function" && (N[o] = N[o] || [], Y$1(N[o], e));
  }, i.removeHook = function(o) {
    if (N[o])
      return nt$1(N[o]);
  }, i.removeHooks = function(o) {
    N[o] && (N[o] = []);
  }, i.removeAllHooks = function() {
    N = {};
  }, i;
}
var Qt = pt$1();

const b$7 = defineComponent({
  props: {
    // Include all the default svgicon props
    ...Object.fromEntries(
      j$3().map((t) => [
        t,
        { type: [String, Object, Array, Number, Boolean] }
      ])
    ),
    // Add our custom props with types
    rotate: {
      type: Number,
      default: 0
    },
    outline: {
      type: Boolean,
      default: false
    }
  },
  render() {
    N$4({
      defaultWidth: "16px",
      defaultHeight: "auto",
      isStroke: this.$props.outline
    });
    const t = typeof this.$props.data == "string" ? this.$props.data : this.$props.data?.path;
    if (!t)
      return;
    const a = { ...this.$props }, e = I$4(a);
    e.path = t;
    let o = {};
    if (typeof t == "string" && t.trim().startsWith("<svg")) {
      const s = new DOMParser().parseFromString(t, "image/svg+xml").querySelector("svg");
      s && (o = Array.from(s.attributes).reduce(
        (r, i) => (r[i.name] = i.value, r),
        {}
      ), e.path = s.innerHTML);
    }
    const n = this.$props.data?.viewBox || o.viewBox;
    e.box = n || "0 0 24 24", this.$props.rotate && (e.style.transform = `rotate(${this.$props.rotate}deg)`), this.$props.color ? e.fill = this.$props.color : this.$props.original || (e.fill = "currentColor"), this.$props.outline && (e.style.stroke = e.fill || "currentColor", e.style.fill = "none"), e.style.display = "block";
    const l = Qt.sanitize(`<svg>${e.path}</svg>`, {
      ALLOWED_TAGS: [
        "svg",
        "path",
        "title",
        "stop",
        "linearGradient",
        "rect",
        "defs",
        "circle",
        "ellipse",
        "line",
        "polyline",
        "polygon",
        "g",
        "text",
        "tspan",
        "textPath",
        "image",
        "use",
        "clipPath",
        "mask",
        "pattern",
        "filter",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "animate",
        "animateMotion",
        "animateTransform",
        "set",
        "desc",
        "metadata",
        "symbol",
        "foreignObject"
      ]
    }).replace(/<svg>|<\/svg>/g, "");
    return h$b("svg", {
      ...o,
      ...this.$attrs,
      viewBox: e.box,
      style: e.style,
      fill: e.fill,
      class: e.className,
      innerHTML: l
    });
  }
});

let o$b = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((r, e) => (e &= 63, e < 36 ? r += e.toString(36) : e < 62 ? r += (e - 26).toString(36).toUpperCase() : e > 62 ? r += "-" : r += "_", r), "");

const o$a = defineComponent({
  name: "JamfSpinner",
  props: {
    /** Sets size for the SVG.
     * Sets both width and height to keep the spinner square.
     * @values 24, 64 */
    size: {
      type: Number,
      default: 24
    },
    /** Sets spinner color.
     * Defaults to `currentColor` which inherits from the parent.
     * To use Nebula color variables, wrap the name in `var()`.
     * For example: `var(--color-action-primary-active)` */
    color: {
      type: String,
      default: "currentColor"
    },
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula--spinner"
    },
    /** Optional component identifier that can be set as a unique value on a page for web analytics targeting. */
    waId: String
  },
  data() {
    return {
      noMotionPreference: true
    };
  },
  computed: {
    tailId() {
      return `tail_spinner_${o$b()}`;
    },
    headId() {
      return `head_spinner_${o$b()}`;
    },
    setColor() {
      return this.color ? this.color : "currentColor";
    }
  },
  mounted() {
    typeof window < "u" && window.matchMedia && (this.noMotionPreference = !window.matchMedia(
      "(prefers-reduced-motion: reduce)"
    ).matches);
  }
});

const s$6 = (t, e) => {
  const o = t.__vccOpts || t;
  for (const [r, c] of e)
    o[r] = c;
  return o;
};

const i$6 = ["width", "height", "data-wa", "data-wa-id"], l$6 = ["id"], a$i = ["stop-color"], d$5 = ["stop-color"], p$9 = ["id"], c$a = ["stop-color"], f$k = ["stop-color"], h$a = {
  "stroke-width": "4",
  fill: "none"
}, u$8 = ["stroke"], m$d = ["stroke"], _$3 = ["fill"], w$9 = ["dur"];
function y$c(o, C, k, g, I, v) {
  return openBlock(), createElementBlock("svg", {
    class: "spinner",
    xmlns: "http://www.w3.org/2000/svg",
    width: o.size,
    height: o.size,
    viewBox: "0 0 64 64",
    "data-wa": o.waComponent,
    "data-wa-id": o.waId,
    part: "container"
  }, [
    createBaseVNode("defs", null, [
      createBaseVNode("linearGradient", {
        id: o.tailId,
        x1: "59.1861422%",
        y1: "50%",
        x2: "0%",
        y2: "50%"
      }, [
        createBaseVNode("stop", {
          "stop-color": o.setColor,
          "stop-opacity": "0",
          offset: "0%"
        }, null, 8, a$i),
        createBaseVNode("stop", {
          "stop-color": o.setColor,
          "stop-opacity": "0.5",
          offset: "100%"
        }, null, 8, d$5)
      ], 8, l$6),
      createBaseVNode("linearGradient", {
        id: o.headId,
        x1: "100%",
        y1: "50%",
        x2: "0%",
        y2: "50%"
      }, [
        createBaseVNode("stop", {
          "stop-color": o.setColor,
          offset: "0%"
        }, null, 8, c$a),
        createBaseVNode("stop", {
          "stop-color": o.setColor,
          "stop-opacity": "0.5",
          offset: "100%"
        }, null, 8, f$k)
      ], 8, p$9)
    ]),
    createBaseVNode("g", h$a, [
      createBaseVNode("path", {
        stroke: "url(#" + o.tailId + ")",
        d: "M4,32 c0,15,12,28,28,28c8,0,16-4,21-9"
      }, null, 8, u$8),
      createBaseVNode("path", {
        stroke: "url(#" + o.headId + ")",
        d: "M60 32C60 16 47.464 4 32 4S4 16 4 32"
      }, null, 8, m$d),
      createBaseVNode("circle", {
        fill: o.setColor,
        cx: "60",
        cy: "32",
        r: "2"
      }, null, 8, _$3),
      createBaseVNode("animateTransform", {
        values: "0,32,32;360,32,32",
        attributeName: "transform",
        type: "rotate",
        repeatCount: "indefinite",
        dur: o.noMotionPreference ? "750ms" : "1100ms"
      }, null, 8, w$9)
    ])
  ], 8, i$6);
}
const z$3 = /* @__PURE__ */ s$6(o$a, [["render", y$c]]);

const r$8 = {
  SPACE: ["Space", "32"],
  ENTER: ["Enter", "13"],
  LEFT: ["ArrowLeft", "37"],
  RIGHT: ["ArrowRight", "39"]};

const X1 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M9.36 2.34c-1.772.243-3.392 1.057-4.697 2.363-.839.838-1.407 1.699-1.821 2.757-.908 2.322-.762 4.789.41 6.96.455.842.987 1.507 1.812 2.263 1.538 1.413 3.896 2.213 6.012 2.043a8.46 8.46 0 004.384-1.641l.32-.24 2.3 2.289c1.265 1.26 2.381 2.354 2.48 2.433.099.079.24.157.314.172.335.072.744-.194.843-.548.067-.241.027-.409-.15-.631-.079-.099-1.173-1.215-2.433-2.48l-2.289-2.3.182-.24c1.44-1.894 2.021-4.339 1.569-6.6-.337-1.684-1.084-3.075-2.294-4.272-1.355-1.34-2.968-2.119-4.861-2.347-.458-.055-1.614-.045-2.081.019m2.604 1.573c.563.132.945.273 1.536.568.72.358 1.212.71 1.76 1.26.906.908 1.491 1.966 1.825 3.299.088.354.095.455.094 1.46 0 .971-.009 1.116-.088 1.44a7.497 7.497 0 01-1.122 2.5c-.34.48-1.041 1.18-1.531 1.529-.727.519-1.781.977-2.698 1.173-.458.098-2.022.098-2.48 0-.916-.196-1.966-.652-2.7-1.173-.486-.344-1.184-1.042-1.53-1.529-.308-.433-.775-1.346-.931-1.82-.232-.707-.267-.939-.288-1.931-.023-1.106.022-1.461.291-2.28A6.65 6.65 0 015.74 5.741c.957-.96 2.071-1.555 3.492-1.864.304-.066.477-.074 1.368-.06.843.013 1.08.03 1.364.096"  fill-rule="evenodd"/>'
}, b4 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M5.8 5.287c-.196.056-.398.22-.464.377a1.206 1.206 0 00-.056.375v.241l.428.45c.235.247 1.508 1.534 2.83 2.86L10.94 12l-2.402 2.41a358.08 358.08 0 00-2.824 2.854c-.47.495-.509.583-.417.938.093.358.322.518.742.518h.242l.469-.448c.259-.246 1.545-1.519 2.858-2.828l2.389-2.38 2.691 2.678c1.481 1.474 2.778 2.749 2.883 2.834.168.137.217.155.402.155.262 0 .478-.098.619-.283.088-.116.11-.191.122-.43l.014-.289-.431-.455c-.238-.25-1.512-1.538-2.833-2.862l-2.4-2.408 2.678-2.692c1.473-1.481 2.749-2.778 2.834-2.883.137-.168.155-.217.155-.402 0-.262-.098-.478-.283-.619-.116-.088-.191-.11-.43-.122l-.289-.014-.455.431c-.25.238-1.538 1.512-2.862 2.832l-2.408 2.4-2.82-2.805C6.657 5.616 6.348 5.322 6.212 5.299c-.084-.014-.179-.032-.212-.038a.6.6 0 00-.2.026"/>'
}, R7 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M11.02 2.304c-.757.11-1.037.163-1.49.278-1.144.292-2.377.885-3.379 1.626-.39.289-1.416 1.285-1.762 1.712a9.793 9.793 0 00-1.807 3.614c-.256.986-.281 1.207-.281 2.466 0 1.259.025 1.48.281 2.466a9.793 9.793 0 001.807 3.614c.298.368 1.343 1.397 1.674 1.649A9.862 9.862 0 009.54 21.42c.991.252 1.214.278 2.4.279.698.001 1.2-.018 1.42-.052 1.661-.257 2.988-.794 4.37-1.767.413-.291 1.511-1.341 1.882-1.8a9.807 9.807 0 001.808-3.62c.255-1.001.278-1.207.278-2.46s-.023-1.459-.278-2.46a9.778 9.778 0 00-1.809-3.62c-.355-.44-1.418-1.465-1.811-1.747-1.307-.938-2.78-1.556-4.28-1.793-.403-.064-2.205-.119-2.5-.076m1.812 1.498c3.251.353 5.958 2.523 6.982 5.598a8.204 8.204 0 01-1.973 8.402c-.703.704-1.343 1.167-2.181 1.579a8.196 8.196 0 01-6.34.412c-2.514-.854-4.495-2.94-5.237-5.515a8.517 8.517 0 01-.161-3.918c.602-3.019 2.989-5.56 5.939-6.32.948-.245 2.076-.335 2.971-.238m-1.097 3.759c-.147.046-.402.312-.439.46-.045.178.005.535.091.651.287.387.818.43 1.14.092.326-.343.287-.861-.084-1.107-.173-.115-.503-.159-.708-.096m-.675 2.954c-.088.04-.221.124-.295.187-.497.419-.193 1.278.452 1.278.112 0 .244-.015.295-.033.081-.03.089-.023.07.06-.011.051-.155.651-.319 1.333-.443 1.837-.45 1.911-.237 2.386.137.306.483.633.803.758.293.115.827.126 1.069.021.405-.174.611-.475.569-.832a.702.702 0 00-.323-.544c-.139-.096-.191-.108-.446-.103-.249.005-.286-.003-.274-.06l.292-1.226c.401-1.675.417-1.76.391-2.012-.051-.495-.464-1.031-.929-1.205-.296-.111-.883-.115-1.118-.008"/>'
}, A8 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M2.8 2.287c-.196.056-.398.22-.464.377a1.206 1.206 0 00-.056.375v.241l1.267 1.29a3322.142 3322.142 0 0015.459 15.473l1.706 1.677h.278c.316 0 .48-.081.639-.317.1-.148.126-.506.051-.704-.023-.059-.648-.718-1.39-1.466l-1.35-1.36.3-.263c1.195-1.049 2.161-2.278 2.796-3.554.326-.656.618-1.385.712-1.776.063-.263.063-.298 0-.563-.173-.72-.751-1.968-1.286-2.777-1.923-2.911-4.743-4.674-8.162-5.106-.595-.075-2.129-.064-2.74.02-1.409.194-2.511.536-3.696 1.147l-.524.271-1.483-1.473C3.527 2.478 3.358 2.324 3.217 2.3L3 2.261a.6.6 0 00-.2.026m10.74 3.089c1.783.328 3.253.983 4.563 2.03.453.362 1.182 1.108 1.568 1.603a10.105 10.105 0 011.465 2.599l.144.387-.148.413c-.511 1.428-1.588 2.958-2.83 4.021l-.438.375-1.359-1.359-1.36-1.36.183-.392c.316-.68.392-1.016.392-1.735 0-.74-.196-1.389-.61-2.025-.382-.586-.781-.927-1.49-1.277-.632-.311-.828-.354-1.62-.355-.767 0-.925.033-1.633.348l-.455.203-1.24-1.24-1.239-1.24.513-.231a10.195 10.195 0 012.734-.802c.537-.078 2.365-.054 2.86.037M3.735 7.522c-.26.079-.942.938-1.477 1.861-.431.742-.913 1.875-1.021 2.4-.062.303-.006.557.292 1.314 1.061 2.701 3.225 4.98 5.836 6.149a11.389 11.389 0 006.861.77c.945-.191 1.141-.28 1.291-.589.245-.508-.102-1.045-.671-1.037-.125.002-.379.04-.566.084a9.696 9.696 0 01-4.885-.09c-2.241-.618-4.157-2.003-5.483-3.964-.346-.512-.868-1.529-1.068-2.08l-.121-.335.094-.273c.3-.872.835-1.836 1.554-2.803.382-.512.419-.669.254-1.064-.113-.27-.563-.443-.89-.343m8.992 2.353c.725.25 1.348.984 1.475 1.736.068.406-.012 1.181-.129 1.253-.021.013-.109-.026-.196-.086-.178-.124-2.797-2.76-2.797-2.816 0-.045.232-.123.496-.165.313-.05.894-.011 1.151.078"/>'
}, b8 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M10.86 3.824c-3.637.383-6.81 2.458-8.653 5.66a12.738 12.738 0 00-.831 1.836 1.975 1.975 0 000 1.36c.173.512.557 1.359.831 1.836 1.778 3.088 4.753 5.112 8.273 5.626.549.081 2.341.094 2.88.021 2.731-.366 5.084-1.588 6.939-3.603a11.071 11.071 0 002.155-3.44c.36-.905.38-1.19.131-1.902-.805-2.305-2.494-4.397-4.645-5.756a13.403 13.403 0 00-2.083-1.018c-1.208-.429-2.042-.587-3.393-.644-1.07-.044-.939-.046-1.604.024m2.7 1.553c.502.087 1.214.268 1.66.423.438.152 1.388.607 1.849.885 1.815 1.097 3.326 2.925 4.067 4.923l.144.388-.105.292c-.318.892-1.008 2.106-1.629 2.868-.364.447-1.198 1.257-1.628 1.581a10.168 10.168 0 01-4.481 1.902c-.629.102-2.1.113-2.757.02-2.751-.391-5.238-1.947-6.76-4.229-.366-.549-.845-1.474-1.055-2.038l-.145-.388.127-.352c.184-.507.703-1.525 1.027-2.012C5.297 7.499 7.5 5.995 9.967 5.48c.823-.172 1.122-.197 2.193-.183.708.01 1.136.034 1.4.08m-2.339 2.967c-1.436.321-2.59 1.473-2.88 2.875-.079.387-.079 1.175 0 1.562.142.685.609 1.509 1.116 1.967 1.049.95 2.58 1.24 3.886.736a3.563 3.563 0 001.872-1.604c.371-.643.505-1.152.505-1.918a3.716 3.716 0 00-2.74-3.571c-.392-.107-1.371-.134-1.759-.047m1.506 1.531c.318.11.612.31.904.617a2.175 2.175 0 01-.017 3.032c-.308.318-.543.48-.877.603-.196.072-.323.087-.737.087s-.541-.015-.737-.087c-.334-.123-.569-.285-.877-.603a2.17 2.17 0 01-.388-2.507c.126-.256.226-.387.473-.624.345-.329.618-.484 1.011-.574.339-.077.939-.05 1.245.056"/>'
}, D8 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M11.519 1.556c-.716.101-1.523.596-1.897 1.162-.511.776-7.255 12.434-7.68 13.277a2.868 2.868 0 00-.261 1.63c.131 1.059.888 2.02 1.913 2.429l.306.122 1.36.028c1.764.037 11.716.037 13.48 0l1.36-.028.306-.122c1.277-.51 2.08-1.826 1.916-3.141-.059-.467-.105-.609-.344-1.059-.491-.925-4.826-8.446-6.993-12.132-.714-1.215-.873-1.412-1.409-1.746a2.68 2.68 0 00-1.397-.432 4.892 4.892 0 00-.66.012m.981 1.546c.442.124.534.244 1.64 2.118a1257.88 1257.88 0 016.423 11.18l.257.46v.38c0 .329-.015.411-.107.609a1.678 1.678 0 01-.764.771l-.28.14H4.331l-.28-.14c-.654-.327-1.014-1.039-.854-1.688.065-.265 1.512-2.817 5.654-9.972 2.203-3.805 2.047-3.566 2.474-3.782.345-.176.731-.2 1.175-.076m-.861 5.252a.801.801 0 00-.358.481c-.025.088-.041.923-.041 2.128v1.983l.122.185c.336.507 1.041.448 1.328-.111.08-.157.081-.199.06-2.215l-.022-2.055-.115-.165a.855.855 0 00-.254-.235c-.186-.094-.539-.092-.72.004m.148 6.685c-.179.056-.39.239-.455.395-.088.21-.055.593.065.762.179.251.626.359.942.227.182-.076.37-.343.405-.575.024-.158.011-.217-.085-.401a.898.898 0 00-.256-.308c-.162-.106-.449-.152-.616-.1"/>'
}, y8 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M11.02 2.304c-.757.11-1.037.163-1.49.278-1.144.292-2.377.885-3.379 1.626-.39.289-1.416 1.285-1.762 1.712a9.793 9.793 0 00-1.807 3.614c-.256.986-.281 1.207-.281 2.466 0 1.259.025 1.48.281 2.466a9.793 9.793 0 001.807 3.614c.298.368 1.343 1.397 1.674 1.649A9.862 9.862 0 009.54 21.42c.991.252 1.214.278 2.4.279.698.001 1.2-.018 1.42-.052 1.661-.257 2.988-.794 4.37-1.767.413-.291 1.511-1.341 1.882-1.8a9.807 9.807 0 001.808-3.62c.255-1.001.278-1.207.278-2.46s-.023-1.459-.278-2.46a9.778 9.778 0 00-1.809-3.62c-.355-.44-1.418-1.465-1.811-1.747-1.307-.938-2.78-1.556-4.28-1.793-.403-.064-2.205-.119-2.5-.076m1.812 1.498c3.251.353 5.958 2.523 6.982 5.598a8.204 8.204 0 01-1.973 8.402c-.703.704-1.343 1.167-2.181 1.579a8.196 8.196 0 01-6.34.412c-2.514-.854-4.495-2.94-5.237-5.515a8.517 8.517 0 01-.161-3.918c.602-3.019 2.989-5.56 5.939-6.32.948-.245 2.076-.335 2.971-.238m-1.193 4.552a.801.801 0 00-.358.481c-.025.088-.041.923-.041 2.129v1.984l.09.132c.05.073.159.188.244.256.138.111.181.124.426.124s.288-.013.426-.124c.085-.068.196-.194.247-.28l.092-.156-.018-2.075-.019-2.075-.115-.165a.855.855 0 00-.254-.235c-.186-.094-.539-.092-.72.004m.148 6.685c-.179.056-.39.239-.455.395-.088.21-.055.593.065.762.179.251.626.359.942.227.182-.076.37-.343.405-.575.024-.158.011-.217-.085-.401a.898.898 0 00-.256-.308c-.162-.106-.449-.152-.616-.1"/>'
}, I9 = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M10.02 1.559c-.588.067-1.14.355-1.644.858a3.28 3.28 0 00-.451.547l-.126.223-.529.049c-1.162.107-1.612.21-2.05.466a3.111 3.111 0 00-.772.668c-.279.328-.426.59-.57 1.016l-.118.349v14.311l.122.345c.153.436.294.681.575 1.006.462.532 1.035.905 1.563 1.013.348.072 11.612.072 11.96 0 .528-.108 1.101-.481 1.563-1.013.281-.324.417-.564.574-1.011l.124-.354-.011-7.206-.01-7.206-.141-.36a2.923 2.923 0 00-.719-1.094c-.613-.62-1.089-.788-2.63-.93l-.529-.049-.126-.223c-.17-.302-.712-.834-1.055-1.035a4.097 4.097 0 00-.6-.276l-.32-.111-1.9-.007c-1.045-.004-2.026.007-2.18.024m4.145 1.626c.151.08.339.217.419.305.18.199.367.591.401.841l.026.189H9v-.093c0-.163.123-.521.247-.716.139-.219.314-.381.575-.534.264-.155.576-.175 2.453-.154l1.615.018.275.144M7.527 4.83c.214.528.446.813.81.998.299.152.668.169 3.663.169 3 0 3.364-.017 3.666-.17.274-.139.626-.527.731-.807.045-.123.083-.242.083-.266 0-.091 1.176.077 1.456.208.27.127.477.328.624.605.134.25.135.259.171.993.02.407.027 3.567.017 7.023l-.019 6.283-.109.231c-.141.297-.464.619-.782.778l-.251.125H6.413l-.251-.125c-.318-.159-.641-.481-.782-.779l-.11-.232-.019-6.302c-.01-3.577-.002-6.613.019-7.022.033-.658.046-.738.141-.924.275-.538.628-.739 1.493-.85.511-.066.572-.06.623.064"/>'
}, oc = {
  height: 24,
  width: 24,
  viewBox: "0 0 24 24",
  path: '<path d="M11.02 2.304c-.757.11-1.037.163-1.49.278-1.144.292-2.377.885-3.379 1.626-.39.289-1.416 1.285-1.762 1.712a9.793 9.793 0 00-1.807 3.614c-.256.986-.281 1.207-.281 2.466 0 1.259.025 1.48.281 2.466a9.793 9.793 0 001.807 3.614c.298.368 1.343 1.397 1.674 1.649A9.862 9.862 0 009.54 21.42c.991.252 1.214.278 2.4.279.698.001 1.2-.018 1.42-.052 1.661-.257 2.988-.794 4.37-1.767.413-.291 1.511-1.341 1.882-1.8a9.807 9.807 0 001.808-3.62c.255-1.001.278-1.207.278-2.46s-.023-1.459-.278-2.46a9.778 9.778 0 00-1.809-3.62c-.355-.44-1.418-1.465-1.811-1.747-1.307-.938-2.78-1.556-4.28-1.793-.403-.064-2.205-.119-2.5-.076m1.812 1.498c3.251.353 5.958 2.523 6.982 5.598a8.204 8.204 0 01-1.973 8.402c-.703.704-1.343 1.167-2.181 1.579a8.196 8.196 0 01-6.34.412c-2.514-.854-4.495-2.94-5.237-5.515a8.517 8.517 0 01-.161-3.918c.602-3.019 2.989-5.56 5.939-6.32.948-.245 2.076-.335 2.971-.238m1.948 5.24c-.266.085-.264.083-2.436 3.13l-1.192 1.673-.806-.794c-1.025-1.009-1.052-1.03-1.35-1.03-.425 0-.716.3-.716.739 0 .151.026.264.083.36.098.166 2.233 2.299 2.479 2.477.14.101.208.123.386.123.342 0 .477-.095.84-.589.754-1.025 3.527-4.932 3.607-5.081.071-.133.055-.493-.029-.651-.15-.282-.564-.453-.866-.357"/>'
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function p$8(o, f, n, r) {
  var c = arguments.length, e = c < 3 ? f : r, t;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") e = Reflect.decorate(o, f, n, r);
  else for (var l = o.length - 1; l >= 0; l--) (t = o[l]) && (e = (c < 3 ? t(e) : c > 3 ? t(f, n, e) : t(f, n)) || e);
  return c > 3 && e && Object.defineProperty(f, n, e), e;
}

const r$7 = function() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof global < "u")
    return global;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  try {
    return new Function("return this")();
  } catch {
    return {};
  }
}();
r$7.trustedTypes === void 0 && (r$7.trustedTypes = { createPolicy: (t, n) => n });
const l$5 = {
  configurable: false,
  enumerable: false,
  writable: false
};
r$7.FAST === void 0 && Reflect.defineProperty(r$7, "FAST", Object.assign({ value: /* @__PURE__ */ Object.create(null) }, l$5));
const f$j = r$7.FAST;
if (f$j.getById === void 0) {
  const t = /* @__PURE__ */ Object.create(null);
  Reflect.defineProperty(f$j, "getById", Object.assign({ value(n, e) {
    let o = t[n];
    return o === void 0 && (o = e ? t[n] = e() : null), o;
  } }, l$5));
}
const i$5 = Object.freeze([]);
function a$h() {
  const t = /* @__PURE__ */ new WeakMap();
  return function(n) {
    let e = t.get(n);
    if (e === void 0) {
      let o = Reflect.getPrototypeOf(n);
      for (; e === void 0 && o !== null; )
        e = t.get(o), o = Reflect.getPrototypeOf(o);
      e = e === void 0 ? [] : e.slice(0), t.set(n, e);
    }
    return e;
  };
}

const i$4 = r$7.FAST.getById(1, () => {
  const e = [], t = [];
  function o() {
    if (t.length)
      throw t.shift();
  }
  function d(s) {
    try {
      s.call();
    } catch (r) {
      t.push(r), setTimeout(o, 0);
    }
  }
  function u() {
    let r = 0;
    for (; r < e.length; )
      if (d(e[r]), r++, r > 1024) {
        for (let c = 0, f = e.length - r; c < f; c++)
          e[c] = e[c + r];
        e.length -= r, r = 0;
      }
    e.length = 0;
  }
  function p(s) {
    e.length < 1 && r$7.requestAnimationFrame(u), e.push(s);
  }
  return Object.freeze({
    enqueue: p,
    process: u
  });
}), h$9 = r$7.trustedTypes.createPolicy("fast-html", {
  createHTML: (e) => e
});
let l$4 = h$9;
const n$8 = `fast-${Math.random().toString(36).substring(2, 8)}`, y$b = `${n$8}{`, m$c = `}${n$8}`, g$7 = Object.freeze({
  /**
   * Indicates whether the DOM supports the adoptedStyleSheets feature.
   */
  supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) && "replace" in CSSStyleSheet.prototype,
  /**
   * Sets the HTML trusted types policy used by the templating engine.
   * @param policy - The policy to set for HTML.
   * @remarks
   * This API can only be called once, for security reasons. It should be
   * called by the application developer at the start of their program.
   */
  setHTMLPolicy(e) {
    if (l$4 !== h$9)
      throw new Error("The HTML policy can only be set once.");
    l$4 = e;
  },
  /**
   * Turns a string into trusted HTML using the configured trusted types policy.
   * @param html - The string to turn into trusted HTML.
   * @remarks
   * Used internally by the template engine when creating templates
   * and setting innerHTML.
   */
  createHTML(e) {
    return l$4.createHTML(e);
  },
  /**
   * Determines if the provided node is a template marker used by the runtime.
   * @param node - The node to test.
   */
  isMarker(e) {
    return e && e.nodeType === 8 && e.data.startsWith(n$8);
  },
  /**
   * Given a marker node, extract the {@link HTMLDirective} index from the placeholder.
   * @param node - The marker node to extract the index from.
   */
  extractDirectiveIndexFromMarker(e) {
    return parseInt(e.data.replace(`${n$8}:`, ""));
  },
  /**
   * Creates a placeholder string suitable for marking out a location *within*
   * an attribute value or HTML content.
   * @param index - The directive index to create the placeholder for.
   * @remarks
   * Used internally by binding directives.
   */
  createInterpolationPlaceholder(e) {
    return `${y$b}${e}${m$c}`;
  },
  /**
   * Creates a placeholder that manifests itself as an attribute on an
   * element.
   * @param attributeName - The name of the custom attribute.
   * @param index - The directive index to create the placeholder for.
   * @remarks
   * Used internally by attribute directives such as `ref`, `slotted`, and `children`.
   */
  createCustomAttributePlaceholder(e, t) {
    return `${e}="${this.createInterpolationPlaceholder(t)}"`;
  },
  /**
   * Creates a placeholder that manifests itself as a marker within the DOM structure.
   * @param index - The directive index to create the placeholder for.
   * @remarks
   * Used internally by structural directives such as `repeat`.
   */
  createBlockPlaceholder(e) {
    return `<!--${n$8}:${e}-->`;
  },
  /**
   * Schedules DOM update work in the next async batch.
   * @param callable - The callable function or object to queue.
   */
  queueUpdate: i$4.enqueue,
  /**
   * Immediately processes all work previously scheduled
   * through queueUpdate.
   * @remarks
   * This also forces nextUpdate promises
   * to resolve.
   */
  processUpdates: i$4.process,
  /**
   * Resolves with the next DOM update.
   */
  nextUpdate() {
    return new Promise(i$4.enqueue);
  },
  /**
   * Sets an attribute value on an element.
   * @param element - The element to set the attribute value on.
   * @param attributeName - The attribute name to set.
   * @param value - The value of the attribute to set.
   * @remarks
   * If the value is `null` or `undefined`, the attribute is removed, otherwise
   * it is set to the provided value using the standard `setAttribute` API.
   */
  setAttribute(e, t, o) {
    o == null ? e.removeAttribute(t) : e.setAttribute(t, o);
  },
  /**
   * Sets a boolean attribute value.
   * @param element - The element to set the boolean attribute value on.
   * @param attributeName - The attribute name to set.
   * @param value - The value of the attribute to set.
   * @remarks
   * If the value is true, the attribute is added; otherwise it is removed.
   */
  setBooleanAttribute(e, t, o) {
    o ? e.setAttribute(t, "") : e.removeAttribute(t);
  },
  /**
   * Removes all the child nodes of the provided parent node.
   * @param parent - The node to remove the children from.
   */
  removeChildNodes(e) {
    for (let t = e.firstChild; t !== null; t = e.firstChild)
      e.removeChild(t);
  },
  /**
   * Creates a TreeWalker configured to walk a template fragment.
   * @param fragment - The fragment to walk.
   */
  createTemplateWalker(e) {
    return document.createTreeWalker(
      e,
      133,
      // element, text, comment
      null,
      false
    );
  }
});

let o$9 = class o {
  /**
   * Creates an instance of SubscriberSet for the specified source.
   * @param source - The object source that subscribers will receive notifications from.
   * @param initialSubscriber - An initial subscriber to changes.
   */
  constructor(s, i) {
    this.sub1 = void 0, this.sub2 = void 0, this.spillover = void 0, this.source = s, this.sub1 = i;
  }
  /**
   * Checks whether the provided subscriber has been added to this set.
   * @param subscriber - The subscriber to test for inclusion in this set.
   */
  has(s) {
    return this.spillover === void 0 ? this.sub1 === s || this.sub2 === s : this.spillover.indexOf(s) !== -1;
  }
  /**
   * Subscribes to notification of changes in an object's state.
   * @param subscriber - The object that is subscribing for change notification.
   */
  subscribe(s) {
    const i = this.spillover;
    if (i === void 0) {
      if (this.has(s))
        return;
      if (this.sub1 === void 0) {
        this.sub1 = s;
        return;
      }
      if (this.sub2 === void 0) {
        this.sub2 = s;
        return;
      }
      this.spillover = [this.sub1, this.sub2, s], this.sub1 = void 0, this.sub2 = void 0;
    } else
      i.indexOf(s) === -1 && i.push(s);
  }
  /**
   * Unsubscribes from notification of changes in an object's state.
   * @param subscriber - The object that is unsubscribing from change notification.
   */
  unsubscribe(s) {
    const i = this.spillover;
    if (i === void 0)
      this.sub1 === s ? this.sub1 = void 0 : this.sub2 === s && (this.sub2 = void 0);
    else {
      const e = i.indexOf(s);
      e !== -1 && i.splice(e, 1);
    }
  }
  /**
   * Notifies all subscribers.
   * @param args - Data passed along to subscribers during notification.
   */
  notify(s) {
    const i = this.spillover, e = this.source;
    if (i === void 0) {
      const t = this.sub1, u = this.sub2;
      t !== void 0 && t.handleChange(e, s), u !== void 0 && u.handleChange(e, s);
    } else
      for (let t = 0, u = i.length; t < u; ++t)
        i[t].handleChange(e, s);
  }
};
let r$6 = class r {
  /**
   * Creates an instance of PropertyChangeNotifier for the specified source.
   * @param source - The object source that subscribers will receive notifications from.
   */
  constructor(s) {
    this.subscribers = {}, this.sourceSubscribers = null, this.source = s;
  }
  /**
   * Notifies all subscribers, based on the specified property.
   * @param propertyName - The property name, passed along to subscribers during notification.
   */
  notify(s) {
    var i;
    const e = this.subscribers[s];
    e !== void 0 && e.notify(s), (i = this.sourceSubscribers) === null || i === void 0 || i.notify(s);
  }
  /**
   * Subscribes to notification of changes in an object's state.
   * @param subscriber - The object that is subscribing for change notification.
   * @param propertyToWatch - The name of the property that the subscriber is interested in watching for changes.
   */
  subscribe(s, i) {
    var e;
    if (i) {
      let t = this.subscribers[i];
      t === void 0 && (this.subscribers[i] = t = new o$9(this.source)), t.subscribe(s);
    } else
      this.sourceSubscribers = (e = this.sourceSubscribers) !== null && e !== void 0 ? e : new o$9(this.source), this.sourceSubscribers.subscribe(s);
  }
  /**
   * Unsubscribes from notification of changes in an object's state.
   * @param subscriber - The object that is unsubscribing from change notification.
   * @param propertyToUnwatch - The name of the property that the subscriber is no longer interested in watching.
   */
  unsubscribe(s, i) {
    var e;
    if (i) {
      const t = this.subscribers[i];
      t !== void 0 && t.unsubscribe(s);
    } else
      (e = this.sourceSubscribers) === null || e === void 0 || e.unsubscribe(s);
  }
};

const u$7 = f$j.getById(2, () => {
  const l = /(:|&&|\|\||if)/, r = /* @__PURE__ */ new WeakMap(), y = g$7.queueUpdate;
  let n, d = (e) => {
    throw new Error("Must call enableArrayObservation before observing arrays.");
  };
  function a(e) {
    let t = e.$fastController || r.get(e);
    return t === void 0 && (Array.isArray(e) ? t = d(e) : r.set(e, t = new r$6(e))), t;
  }
  const c = a$h();
  class b {
    constructor(t) {
      this.name = t, this.field = `_${t}`, this.callback = `${t}Changed`;
    }
    getValue(t) {
      return n !== void 0 && n.watch(t, this.name), t[this.field];
    }
    setValue(t, i) {
      const s = this.field, h = t[s];
      if (h !== i) {
        t[s] = i;
        const o = t[this.callback];
        typeof o == "function" && o.call(t, h, i), a(t).notify(this.name);
      }
    }
  }
  class x extends o$9 {
    constructor(t, i, s = false) {
      super(t, i), this.binding = t, this.isVolatileBinding = s, this.needsRefresh = true, this.needsQueue = true, this.first = this, this.last = null, this.propertySource = void 0, this.propertyName = void 0, this.notifier = void 0, this.next = void 0;
    }
    observe(t, i) {
      this.needsRefresh && this.last !== null && this.disconnect();
      const s = n;
      n = this.needsRefresh ? this : void 0, this.needsRefresh = this.isVolatileBinding;
      const h = this.binding(t, i);
      return n = s, h;
    }
    disconnect() {
      if (this.last !== null) {
        let t = this.first;
        for (; t !== void 0; )
          t.notifier.unsubscribe(this, t.propertyName), t = t.next;
        this.last = null, this.needsRefresh = this.needsQueue = true;
      }
    }
    watch(t, i) {
      const s = this.last, h = a(t), o = s === null ? this.first : {};
      if (o.propertySource = t, o.propertyName = i, o.notifier = h, h.subscribe(this, i), s !== null) {
        if (!this.needsRefresh) {
          let p;
          n = void 0, p = s.propertySource[s.propertyName], n = this, t === p && (this.needsRefresh = true);
        }
        s.next = o;
      }
      this.last = o;
    }
    handleChange() {
      this.needsQueue && (this.needsQueue = false, y(this));
    }
    call() {
      this.last !== null && (this.needsQueue = true, this.notify(this));
    }
    records() {
      let t = this.first;
      return {
        next: () => {
          const i = t;
          return i === void 0 ? { value: void 0, done: true } : (t = t.next, {
            value: i,
            done: false
          });
        },
        [Symbol.iterator]: function() {
          return this;
        }
      };
    }
  }
  return Object.freeze({
    /**
     * @internal
     * @param factory - The factory used to create array observers.
     */
    setArrayObserverFactory(e) {
      d = e;
    },
    /**
     * Gets a notifier for an object or Array.
     * @param source - The object or Array to get the notifier for.
     */
    getNotifier: a,
    /**
     * Records a property change for a source object.
     * @param source - The object to record the change against.
     * @param propertyName - The property to track as changed.
     */
    track(e, t) {
      n !== void 0 && n.watch(e, t);
    },
    /**
     * Notifies watchers that the currently executing property getter or function is volatile
     * with respect to its observable dependencies.
     */
    trackVolatile() {
      n !== void 0 && (n.needsRefresh = true);
    },
    /**
     * Notifies subscribers of a source object of changes.
     * @param source - the object to notify of changes.
     * @param args - The change args to pass to subscribers.
     */
    notify(e, t) {
      a(e).notify(t);
    },
    /**
     * Defines an observable property on an object or prototype.
     * @param target - The target object to define the observable on.
     * @param nameOrAccessor - The name of the property to define as observable;
     * or a custom accessor that specifies the property name and accessor implementation.
     */
    defineProperty(e, t) {
      typeof t == "string" && (t = new b(t)), c(e).push(t), Reflect.defineProperty(e, t.name, {
        enumerable: true,
        get: function() {
          return t.getValue(this);
        },
        set: function(i) {
          t.setValue(this, i);
        }
      });
    },
    /**
     * Finds all the observable accessors defined on the target,
     * including its prototype chain.
     * @param target - The target object to search for accessor on.
     */
    getAccessors: c,
    /**
     * Creates a {@link BindingObserver} that can watch the
     * provided {@link Binding} for changes.
     * @param binding - The binding to observe.
     * @param initialSubscriber - An initial subscriber to changes in the binding value.
     * @param isVolatileBinding - Indicates whether the binding's dependency list must be re-evaluated on every value evaluation.
     */
    binding(e, t, i = this.isVolatileBinding(e)) {
      return new x(e, t, i);
    },
    /**
     * Determines whether a binding expression is volatile and needs to have its dependency list re-evaluated
     * on every evaluation of the value.
     * @param binding - The binding to inspect.
     */
    isVolatileBinding(e) {
      return l.test(e.toString());
    }
  });
});
function E$6(l, r) {
  u$7.defineProperty(l, r);
}
const v$7 = f$j.getById(3, () => {
  let l = null;
  return {
    get() {
      return l;
    },
    set(r) {
      l = r;
    }
  };
});
let f$i = class f {
  constructor() {
    this.index = 0, this.length = 0, this.parent = null, this.parentContext = null;
  }
  /**
   * The current event within an event handler.
   */
  get event() {
    return v$7.get();
  }
  /**
   * Indicates whether the current item within a repeat context
   * has an even index.
   */
  get isEven() {
    return this.index % 2 === 0;
  }
  /**
   * Indicates whether the current item within a repeat context
   * has an odd index.
   */
  get isOdd() {
    return this.index % 2 !== 0;
  }
  /**
   * Indicates whether the current item within a repeat context
   * is the first item in the collection.
   */
  get isFirst() {
    return this.index === 0;
  }
  /**
   * Indicates whether the current item within a repeat context
   * is somewhere in the middle of the collection.
   */
  get isInMiddle() {
    return !this.isFirst && !this.isLast;
  }
  /**
   * Indicates whether the current item within a repeat context
   * is the last item in the collection.
   */
  get isLast() {
    return this.index === this.length - 1;
  }
  /**
   * Sets the event for the current execution context.
   * @param event - The event to set.
   * @internal
   */
  static setEvent(r) {
    v$7.set(r);
  }
};
u$7.defineProperty(f$i.prototype, "index");
u$7.defineProperty(f$i.prototype, "length");
const P$4 = Object.seal(new f$i());

let h$8 = class h {
  constructor() {
    this.targets = /* @__PURE__ */ new WeakSet();
  }
  /** @internal */
  addStylesTo(e) {
    this.targets.add(e);
  }
  /** @internal */
  removeStylesFrom(e) {
    this.targets.delete(e);
  }
  /** @internal */
  isAttachedTo(e) {
    return this.targets.has(e);
  }
  /**
   * Associates behaviors with this set of styles.
   * @param behaviors - The behaviors to associate.
   */
  withBehaviors(...e) {
    return this.behaviors = this.behaviors === null ? e : this.behaviors.concat(e), this;
  }
};
h$8.create = (() => {
  if (g$7.supportsAdoptedStyleSheets) {
    const t = /* @__PURE__ */ new Map();
    return (e) => (
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new y$a(e, t)
    );
  }
  return (t) => new p$7(t);
})();
function n$7(t) {
  return t.map((e) => e instanceof h$8 ? n$7(e.styles) : [e]).reduce((e, s) => e.concat(s), []);
}
function S$4(t) {
  return t.map((e) => e instanceof h$8 ? e.behaviors : null).reduce((e, s) => s === null ? e : (e === null && (e = []), e.concat(s)), null);
}
let d$4 = (t, e) => {
  t.adoptedStyleSheets = [...t.adoptedStyleSheets, ...e];
}, a$g = (t, e) => {
  t.adoptedStyleSheets = t.adoptedStyleSheets.filter((s) => e.indexOf(s) === -1);
};
if (g$7.supportsAdoptedStyleSheets)
  try {
    document.adoptedStyleSheets.push(), document.adoptedStyleSheets.splice(), d$4 = (t, e) => {
      t.adoptedStyleSheets.push(...e);
    }, a$g = (t, e) => {
      for (const s of e) {
        const l = t.adoptedStyleSheets.indexOf(s);
        l !== -1 && t.adoptedStyleSheets.splice(l, 1);
      }
    };
  } catch {
  }
let y$a = class y extends h$8 {
  constructor(e, s) {
    super(), this.styles = e, this.styleSheetCache = s, this._styleSheets = void 0, this.behaviors = S$4(e);
  }
  get styleSheets() {
    if (this._styleSheets === void 0) {
      const e = this.styles, s = this.styleSheetCache;
      this._styleSheets = n$7(e).map((l) => {
        if (l instanceof CSSStyleSheet)
          return l;
        let o = s.get(l);
        return o === void 0 && (o = new CSSStyleSheet(), o.replaceSync(l), s.set(l, o)), o;
      });
    }
    return this._styleSheets;
  }
  addStylesTo(e) {
    d$4(e, this.styleSheets), super.addStylesTo(e);
  }
  removeStylesFrom(e) {
    a$g(e, this.styleSheets), super.removeStylesFrom(e);
  }
};
let c$9 = 0;
function u$6() {
  return `fast-style-class-${++c$9}`;
}
let p$7 = class p extends h$8 {
  constructor(e) {
    super(), this.styles = e, this.behaviors = null, this.behaviors = S$4(e), this.styleSheets = n$7(e), this.styleClass = u$6();
  }
  addStylesTo(e) {
    const s = this.styleSheets, l = this.styleClass;
    e = this.normalizeTarget(e);
    for (let o = 0; o < s.length; o++) {
      const i = document.createElement("style");
      i.innerHTML = s[o], i.className = l, e.append(i);
    }
    super.addStylesTo(e);
  }
  removeStylesFrom(e) {
    e = this.normalizeTarget(e);
    const s = e.querySelectorAll(`.${this.styleClass}`);
    for (let l = 0, o = s.length; l < o; ++l)
      e.removeChild(s[l]);
    super.removeStylesFrom(e);
  }
  isAttachedTo(e) {
    return super.isAttachedTo(this.normalizeTarget(e));
  }
  normalizeTarget(e) {
    return e === document ? document.body : e;
  }
};

const b$6 = Object.freeze({
  /**
   * Locates all attribute configurations associated with a type.
   */
  locate: a$h()
}), g$6 = {
  toView(s) {
    return s ? "true" : "false";
  },
  fromView(s) {
    return !(s == null || s === "false" || s === false || s === 0);
  }
};
let f$h = class f {
  /**
   * Creates an instance of AttributeDefinition.
   * @param Owner - The class constructor that owns this attribute.
   * @param name - The name of the property associated with the attribute.
   * @param attribute - The name of the attribute in HTML.
   * @param mode - The {@link AttributeMode} that describes the behavior of this attribute.
   * @param converter - A {@link ValueConverter} that integrates with the property getter/setter
   * to convert values to and from a DOM string.
   */
  constructor(t, e, r = e.toLowerCase(), i = "reflect", o) {
    this.guards = /* @__PURE__ */ new Set(), this.Owner = t, this.name = e, this.attribute = r, this.mode = i, this.converter = o, this.fieldName = `_${e}`, this.callbackName = `${e}Changed`, this.hasCallback = this.callbackName in t.prototype, i === "boolean" && o === void 0 && (this.converter = g$6);
  }
  /**
   * Sets the value of the attribute/property on the source element.
   * @param source - The source element to access.
   * @param value - The value to set the attribute/property to.
   */
  setValue(t, e) {
    const r = t[this.fieldName], i = this.converter;
    i !== void 0 && (e = i.fromView(e)), r !== e && (t[this.fieldName] = e, this.tryReflectToAttribute(t), this.hasCallback && t[this.callbackName](r, e), t.$fastController.notify(this.name));
  }
  /**
   * Gets the value of the attribute/property on the source element.
   * @param source - The source element to access.
   */
  getValue(t) {
    return u$7.track(t, this.name), t[this.fieldName];
  }
  /** @internal */
  onAttributeChangedCallback(t, e) {
    this.guards.has(t) || (this.guards.add(t), this.setValue(t, e), this.guards.delete(t));
  }
  tryReflectToAttribute(t) {
    const e = this.mode, r = this.guards;
    r.has(t) || e === "fromView" || g$7.queueUpdate(() => {
      r.add(t);
      const i = t[this.fieldName];
      switch (e) {
        case "reflect":
          const o = this.converter;
          g$7.setAttribute(t, this.attribute, o !== void 0 ? o.toView(i) : i);
          break;
        case "boolean":
          g$7.setBooleanAttribute(t, this.attribute, i);
          break;
      }
      r.delete(t);
    });
  }
  /**
   * Collects all attribute definitions associated with the owner.
   * @param Owner - The class constructor to collect attribute for.
   * @param attributeLists - Any existing attributes to collect and merge with those associated with the owner.
   * @internal
   */
  static collect(t, ...e) {
    const r = [];
    e.push(b$6.locate(t));
    for (let i = 0, o = e.length; i < o; ++i) {
      const c = e[i];
      if (c !== void 0)
        for (let h = 0, n = c.length; h < n; ++h) {
          const a = c[h];
          typeof a == "string" ? r.push(new f(t, a)) : r.push(new f(t, a.property, a.attribute, a.mode, a.converter));
        }
    }
    return r;
  }
};

const c$8 = { mode: "open" }, h$7 = {}, y$9 = f$j.getById(4, () => {
  const r = /* @__PURE__ */ new Map();
  return Object.freeze({
    register(e) {
      return r.has(e.type) ? false : (r.set(e.type, e), true);
    },
    getByType(e) {
      return r.get(e);
    }
  });
});
let v$6 = class v {
  /**
   * Creates an instance of FASTElementDefinition.
   * @param type - The type this definition is being created for.
   * @param nameOrConfig - The name of the element to define or a config object
   * that describes the element to define.
   */
  constructor(e, t = e.definition) {
    typeof t == "string" && (t = { name: t }), this.type = e, this.name = t.name, this.template = t.template;
    const s = f$h.collect(e, t.attributes), p = new Array(s.length), i = {}, n = {};
    for (let l = 0, a = s.length; l < a; ++l) {
      const o = s[l];
      p[l] = o.attribute, i[o.name] = o, n[o.attribute] = o;
    }
    this.attributes = s, this.observedAttributes = p, this.propertyLookup = i, this.attributeLookup = n, this.shadowOptions = t.shadowOptions === void 0 ? c$8 : t.shadowOptions === null ? void 0 : Object.assign(Object.assign({}, c$8), t.shadowOptions), this.elementOptions = t.elementOptions === void 0 ? h$7 : Object.assign(Object.assign({}, h$7), t.elementOptions), this.styles = t.styles === void 0 ? void 0 : Array.isArray(t.styles) ? h$8.create(t.styles) : t.styles instanceof h$8 ? t.styles : h$8.create([t.styles]);
  }
  /**
   * Indicates if this element has been defined in at least one registry.
   */
  get isDefined() {
    return !!y$9.getByType(this.type);
  }
  /**
   * Defines a custom element based on this definition.
   * @param registry - The element registry to define the element in.
   */
  define(e = customElements) {
    const t = this.type;
    if (y$9.register(this)) {
      const s = this.attributes, p = t.prototype;
      for (let i = 0, n = s.length; i < n; ++i)
        u$7.defineProperty(p, s[i]);
      Reflect.defineProperty(t, "observedAttributes", {
        value: this.observedAttributes,
        enumerable: true
      });
    }
    return e.get(this.name) || e.define(this.name, t, this.elementOptions), this;
  }
};
v$6.forType = y$9.getByType;

const u$5 = /* @__PURE__ */ new WeakMap(), C$7 = {
  bubbles: true,
  composed: true,
  cancelable: true
};
function c$7(d) {
  return d.shadowRoot || u$5.get(d) || null;
}
let m$b = class m extends r$6 {
  /**
   * Creates a Controller to control the specified element.
   * @param element - The element to be controlled by this controller.
   * @param definition - The element definition metadata that instructs this
   * controller in how to handle rendering and other platform integrations.
   * @internal
   */
  constructor(e, t) {
    super(e), this.boundObservables = null, this.behaviors = null, this.needsInitialization = true, this._template = null, this._styles = null, this._isConnected = false, this.$fastController = this, this.view = null, this.element = e, this.definition = t;
    const s = t.shadowOptions;
    if (s !== void 0) {
      const o = e.attachShadow(s);
      s.mode === "closed" && u$5.set(e, o);
    }
    const n = u$7.getAccessors(e);
    if (n.length > 0) {
      const o = this.boundObservables = /* @__PURE__ */ Object.create(null);
      for (let i = 0, l = n.length; i < l; ++i) {
        const h = n[i].name, f = e[h];
        f !== void 0 && (delete e[h], o[h] = f);
      }
    }
  }
  /**
   * Indicates whether or not the custom element has been
   * connected to the document.
   */
  get isConnected() {
    return u$7.track(this, "isConnected"), this._isConnected;
  }
  setIsConnected(e) {
    this._isConnected = e, u$7.notify(this, "isConnected");
  }
  /**
   * Gets/sets the template used to render the component.
   * @remarks
   * This value can only be accurately read after connect but can be set at any time.
   */
  get template() {
    return this._template;
  }
  set template(e) {
    this._template !== e && (this._template = e, this.needsInitialization || this.renderTemplate(e));
  }
  /**
   * Gets/sets the primary styles used for the component.
   * @remarks
   * This value can only be accurately read after connect but can be set at any time.
   */
  get styles() {
    return this._styles;
  }
  set styles(e) {
    this._styles !== e && (this._styles !== null && this.removeStyles(this._styles), this._styles = e, !this.needsInitialization && e !== null && this.addStyles(e));
  }
  /**
   * Adds styles to this element. Providing an HTMLStyleElement will attach the element instance to the shadowRoot.
   * @param styles - The styles to add.
   */
  addStyles(e) {
    const t = c$7(this.element) || this.element.getRootNode();
    if (e instanceof HTMLStyleElement)
      t.append(e);
    else if (!e.isAttachedTo(t)) {
      const s = e.behaviors;
      e.addStylesTo(t), s !== null && this.addBehaviors(s);
    }
  }
  /**
   * Removes styles from this element. Providing an HTMLStyleElement will detach the element instance from the shadowRoot.
   * @param styles - the styles to remove.
   */
  removeStyles(e) {
    const t = c$7(this.element) || this.element.getRootNode();
    if (e instanceof HTMLStyleElement)
      t.removeChild(e);
    else if (e.isAttachedTo(t)) {
      const s = e.behaviors;
      e.removeStylesFrom(t), s !== null && this.removeBehaviors(s);
    }
  }
  /**
   * Adds behaviors to this element.
   * @param behaviors - The behaviors to add.
   */
  addBehaviors(e) {
    const t = this.behaviors || (this.behaviors = /* @__PURE__ */ new Map()), s = e.length, n = [];
    for (let o = 0; o < s; ++o) {
      const i = e[o];
      t.has(i) ? t.set(i, t.get(i) + 1) : (t.set(i, 1), n.push(i));
    }
    if (this._isConnected) {
      const o = this.element;
      for (let i = 0; i < n.length; ++i)
        n[i].bind(o, P$4);
    }
  }
  /**
   * Removes behaviors from this element.
   * @param behaviors - The behaviors to remove.
   * @param force - Forces unbinding of behaviors.
   */
  removeBehaviors(e, t = false) {
    const s = this.behaviors;
    if (s === null)
      return;
    const n = e.length, o = [];
    for (let i = 0; i < n; ++i) {
      const l = e[i];
      if (s.has(l)) {
        const h = s.get(l) - 1;
        h === 0 || t ? s.delete(l) && o.push(l) : s.set(l, h);
      }
    }
    if (this._isConnected) {
      const i = this.element;
      for (let l = 0; l < o.length; ++l)
        o[l].unbind(i);
    }
  }
  /**
   * Runs connected lifecycle behavior on the associated element.
   */
  onConnectedCallback() {
    if (this._isConnected)
      return;
    const e = this.element;
    this.needsInitialization ? this.finishInitialization() : this.view !== null && this.view.bind(e, P$4);
    const t = this.behaviors;
    if (t !== null)
      for (const [s] of t)
        s.bind(e, P$4);
    this.setIsConnected(true);
  }
  /**
   * Runs disconnected lifecycle behavior on the associated element.
   */
  onDisconnectedCallback() {
    if (!this._isConnected)
      return;
    this.setIsConnected(false);
    const e = this.view;
    e !== null && e.unbind();
    const t = this.behaviors;
    if (t !== null) {
      const s = this.element;
      for (const [n] of t)
        n.unbind(s);
    }
  }
  /**
   * Runs the attribute changed callback for the associated element.
   * @param name - The name of the attribute that changed.
   * @param oldValue - The previous value of the attribute.
   * @param newValue - The new value of the attribute.
   */
  onAttributeChangedCallback(e, t, s) {
    const n = this.definition.attributeLookup[e];
    n !== void 0 && n.onAttributeChangedCallback(this.element, s);
  }
  /**
   * Emits a custom HTML event.
   * @param type - The type name of the event.
   * @param detail - The event detail object to send with the event.
   * @param options - The event options. By default bubbles and composed.
   * @remarks
   * Only emits events if connected.
   */
  emit(e, t, s) {
    return this._isConnected ? this.element.dispatchEvent(new CustomEvent(e, Object.assign(Object.assign({ detail: t }, C$7), s))) : false;
  }
  finishInitialization() {
    const e = this.element, t = this.boundObservables;
    if (t !== null) {
      const n = Object.keys(t);
      for (let o = 0, i = n.length; o < i; ++o) {
        const l = n[o];
        e[l] = t[l];
      }
      this.boundObservables = null;
    }
    const s = this.definition;
    this._template === null && (this.element.resolveTemplate ? this._template = this.element.resolveTemplate() : s.template && (this._template = s.template || null)), this._template !== null && this.renderTemplate(this._template), this._styles === null && (this.element.resolveStyles ? this._styles = this.element.resolveStyles() : s.styles && (this._styles = s.styles || null)), this._styles !== null && this.addStyles(this._styles), this.needsInitialization = false;
  }
  renderTemplate(e) {
    const t = this.element, s = c$7(t) || t;
    this.view !== null ? (this.view.dispose(), this.view = null) : this.needsInitialization || g$7.removeChildNodes(s), e && (this.view = e.render(t, s, t));
  }
  /**
   * Locates or creates a controller for the specified element.
   * @param element - The element to return the controller for.
   * @remarks
   * The specified element must have a {@link FASTElementDefinition}
   * registered either through the use of the {@link customElement}
   * decorator or a call to `FASTElement.define`.
   */
  static forCustomElement(e) {
    const t = e.$fastController;
    if (t !== void 0)
      return t;
    const s = v$6.forType(e.constructor);
    if (s === void 0)
      throw new Error("Missing FASTElement definition.");
    return e.$fastController = new m(e, s);
  }
};

function o$8(t) {
  return class extends t {
    constructor() {
      super(), m$b.forCustomElement(this);
    }
    $emit(e, n, r) {
      return this.$fastController.emit(e, n, r);
    }
    connectedCallback() {
      this.$fastController.onConnectedCallback();
    }
    disconnectedCallback() {
      this.$fastController.onDisconnectedCallback();
    }
    attributeChangedCallback(e, n, r) {
      this.$fastController.onAttributeChangedCallback(e, n, r);
    }
  };
}
const s$5 = Object.assign(o$8(HTMLElement), {
  /**
   * Creates a new FASTElement base class inherited from the
   * provided base type.
   * @param BaseType - The base element type to inherit from.
   */
  from(t) {
    return o$8(t);
  },
  /**
   * Defines a platform custom element based on the provided type and definition.
   * @param type - The custom element type to define.
   * @param nameOrDef - The name of the element to define or a definition object
   * that describes the element to define.
   */
  define(t, e) {
    return new v$6(t, e).define().type;
  }
});

const w$8 = /* @__PURE__ */ new Map();
"metadata" in Reflect || (Reflect.metadata = function(t, e) {
  return function(r) {
    Reflect.defineMetadata(t, e, r);
  };
}, Reflect.defineMetadata = function(t, e, r) {
  let n = w$8.get(r);
  n === void 0 && w$8.set(r, n = /* @__PURE__ */ new Map()), n.set(t, e);
}, Reflect.getOwnMetadata = function(t, e) {
  const r = w$8.get(e);
  if (r !== void 0)
    return r.get(t);
});
let T$2 = class T {
  /**
   *
   * @param container - The container to create resolvers for.
   * @param key - The key to register resolvers under.
   */
  constructor(e, r) {
    this.container = e, this.key = r;
  }
  /**
   * Creates a resolver for an existing object instance.
   * @param value - The instance to resolve.
   * @returns The resolver.
   */
  instance(e) {
    return this.registerResolver(0, e);
  }
  /**
   * Creates a resolver that enforces a singleton lifetime.
   * @param value - The type to create and cache the singleton for.
   * @returns The resolver.
   */
  singleton(e) {
    return this.registerResolver(1, e);
  }
  /**
   * Creates a resolver that creates a new instance for every dependency request.
   * @param value - The type to create instances of.
   * @returns - The resolver.
   */
  transient(e) {
    return this.registerResolver(2, e);
  }
  /**
   * Creates a resolver that invokes a callback function for every dependency resolution
   * request, allowing custom logic to return the dependency.
   * @param value - The callback to call during resolution.
   * @returns The resolver.
   */
  callback(e) {
    return this.registerResolver(3, e);
  }
  /**
   * Creates a resolver that invokes a callback function the first time that a dependency
   * resolution is requested. The returned value is then cached and provided for all
   * subsequent requests.
   * @param value - The callback to call during the first resolution.
   * @returns The resolver.
   */
  cachedCallback(e) {
    return this.registerResolver(3, F$1(e));
  }
  /**
   * Aliases the current key to a different key.
   * @param destinationKey - The key to point the alias to.
   * @returns The resolver.
   */
  aliasTo(e) {
    return this.registerResolver(5, e);
  }
  registerResolver(e, r) {
    const { container: n, key: s } = this;
    return this.container = this.key = void 0, n.registerResolver(s, new f$g(s, e, r));
  }
};
function h$6(t) {
  const e = t.slice(), r = Object.keys(t), n = r.length;
  let s;
  for (let i = 0; i < n; ++i)
    s = r[i], M$1(s) || (e[s] = t[s]);
  return e;
}
const L$3 = Object.freeze({
  /**
   * Disables auto-registration and throws for all un-registered dependencies.
   * @param key - The key to create the resolver for.
   */
  none(t) {
    throw Error(`${t.toString()} not registered, did you forget to add @singleton()?`);
  },
  /**
   * Provides default singleton resolution behavior during auto-registration.
   * @param key - The key to create the resolver for.
   * @returns The resolver.
   */
  singleton(t) {
    return new f$g(t, 1, t);
  },
  /**
   * Provides default transient resolution behavior during auto-registration.
   * @param key - The key to create the resolver for.
   * @returns The resolver.
   */
  transient(t) {
    return new f$g(t, 2, t);
  }
}), m$a = Object.freeze({
  /**
   * The default configuration used when creating a DOM-disconnected container.
   * @remarks
   * The default creates a root container, with no parent container. It does not handle
   * owner requests and it uses singleton resolution behavior for auto-registration.
   */
  default: Object.freeze({
    parentLocator: () => null,
    responsibleForOwnerRequests: false,
    defaultResolver: L$3.singleton
  })
}), C$6 = /* @__PURE__ */ new Map();
function P$3(t) {
  return (e) => Reflect.getOwnMetadata(t, e);
}
let $$7 = null;
const a$f = Object.freeze({
  /**
   * Creates a new dependency injection container.
   * @param config - The configuration for the container.
   * @returns A newly created dependency injection container.
   */
  createContainer(t) {
    return new g$5(null, Object.assign({}, m$a.default, t));
  },
  /**
   * Finds the dependency injection container responsible for providing dependencies
   * to the specified node.
   * @param node - The node to find the responsible container for.
   * @returns The container responsible for providing dependencies to the node.
   * @remarks
   * This will be the same as the parent container if the specified node
   * does not itself host a container configured with responsibleForOwnerRequests.
   */
  findResponsibleContainer(t) {
    const e = t.$$container$$;
    return e && e.responsibleForOwnerRequests ? e : a$f.findParentContainer(t);
  },
  /**
   * Find the dependency injection container up the DOM tree from this node.
   * @param node - The node to find the parent container for.
   * @returns The parent container of this node.
   * @remarks
   * This will be the same as the responsible container if the specified node
   * does not itself host a container configured with responsibleForOwnerRequests.
   */
  findParentContainer(t) {
    const e = new CustomEvent(D$4, {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: { container: void 0 }
    });
    return t.dispatchEvent(e), e.detail.container || a$f.getOrCreateDOMContainer();
  },
  /**
   * Returns a dependency injection container if one is explicitly owned by the specified
   * node. If one is not owned, then a new container is created and assigned to the node.
   * @param node - The node to find or create the container for.
   * @param config - The configuration for the container if one needs to be created.
   * @returns The located or created container.
   * @remarks
   * This API does not search for a responsible or parent container. It looks only for a container
   * directly defined on the specified node and creates one at that location if one does not
   * already exist.
   */
  getOrCreateDOMContainer(t, e) {
    return t ? t.$$container$$ || new g$5(t, Object.assign({}, m$a.default, e, {
      parentLocator: a$f.findParentContainer
    })) : $$7 || ($$7 = new g$5(null, Object.assign({}, m$a.default, e, {
      parentLocator: () => null
    })));
  },
  /**
   * Gets the "design:paramtypes" metadata for the specified type.
   * @param Type - The type to get the metadata for.
   * @returns The metadata array or undefined if no metadata is found.
   */
  getDesignParamtypes: P$3("design:paramtypes"),
  /**
   * Gets the "di:paramtypes" metadata for the specified type.
   * @param Type - The type to get the metadata for.
   * @returns The metadata array or undefined if no metadata is found.
   */
  getAnnotationParamtypes: P$3("di:paramtypes"),
  /**
   *
   * @param Type - Gets the "di:paramtypes" metadata for the specified type. If none is found,
   * an empty metadata array is created and added.
   * @returns The metadata array.
   */
  getOrCreateAnnotationParamTypes(t) {
    let e = this.getAnnotationParamtypes(t);
    return e === void 0 && Reflect.defineMetadata("di:paramtypes", e = [], t), e;
  },
  /**
   * Gets the dependency keys representing what is needed to instantiate the specified type.
   * @param Type - The type to get the dependencies for.
   * @returns An array of dependency keys.
   */
  getDependencies(t) {
    let e = C$6.get(t);
    if (e === void 0) {
      const r = t.inject;
      if (r === void 0) {
        const n = a$f.getDesignParamtypes(t), s = a$f.getAnnotationParamtypes(t);
        if (n === void 0)
          if (s === void 0) {
            const i = Object.getPrototypeOf(t);
            typeof i == "function" && i !== Function.prototype ? e = h$6(a$f.getDependencies(i)) : e = [];
          } else
            e = h$6(s);
        else if (s === void 0)
          e = h$6(n);
        else {
          e = h$6(n);
          let i = s.length, o;
          for (let c = 0; c < i; ++c)
            o = s[c], o !== void 0 && (e[c] = o);
          const l = Object.keys(s);
          i = l.length;
          let u;
          for (let c = 0; c < i; ++c)
            u = l[c], M$1(u) || (e[u] = s[u]);
        }
      } else
        e = h$6(r);
      C$6.set(t, e);
    }
    return e;
  },
  /**
   * Defines a property on a web component class. The value of this property will
   * be resolved from the dependency injection container responsible for the element
   * instance, based on where it is connected in the DOM.
   * @param target - The target to define the property on.
   * @param propertyName - The name of the property to define.
   * @param key - The dependency injection key.
   * @param respectConnection - Indicates whether or not to update the property value if the
   * hosting component is disconnected and then re-connected at a different location in the DOM.
   * @remarks
   * The respectConnection option is only applicable to elements that descend from FASTElement.
   */
  defineProperty(t, e, r, n = false) {
    const s = `$di_${e}`;
    Reflect.defineProperty(t, e, {
      get: function() {
        let i = this[s];
        if (i === void 0 && (i = (this instanceof HTMLElement ? a$f.findResponsibleContainer(this) : a$f.getOrCreateDOMContainer()).get(r), this[s] = i, n && this instanceof s$5)) {
          const l = this.$fastController, u = () => {
            const S = a$f.findResponsibleContainer(this).get(r), N = this[s];
            S !== N && (this[s] = i, l.notify(e));
          };
          l.subscribe({ handleChange: u }, "isConnected");
        }
        return i;
      }
    });
  },
  /**
   * Creates a dependency injection key.
   * @param nameConfigOrCallback - A friendly name for the key or a lambda that configures a
   * default resolution for the dependency.
   * @param configuror - If a friendly name was provided for the first parameter, then an optional
   * lambda that configures a default resolution for the dependency can be provided second.
   * @returns The created key.
   * @remarks
   * The created key can be used as a property decorator or constructor parameter decorator,
   * in addition to its standard use in an inject array or through direct container APIs.
   */
  createInterface(t, e) {
    const r = typeof t == "function" ? t : e, n = typeof t == "string" ? t : t && "friendlyName" in t && t.friendlyName || I$3, s = typeof t == "string" ? false : t && "respectConnection" in t && t.respectConnection || false, i = function(o, l, u) {
      if (o == null || new.target !== void 0)
        throw new Error(`No registration for interface: '${i.friendlyName}'`);
      if (l)
        a$f.defineProperty(o, l, i, s);
      else {
        const c = a$f.getOrCreateAnnotationParamTypes(o);
        c[u] = i;
      }
    };
    return i.$isInterface = true, i.friendlyName = n ?? "(anonymous)", r != null && (i.register = function(o, l) {
      return r(new T$2(o, l ?? i));
    }), i.toString = function() {
      return `InterfaceSymbol<${i.friendlyName}>`;
    }, i;
  },
  /**
   * A decorator that specifies what to inject into its target.
   * @param dependencies - The dependencies to inject.
   * @returns The decorator to be applied to the target class.
   * @remarks
   * The decorator can be used to decorate a class, listing all of the classes dependencies.
   * Or it can be used to decorate a constructor paramter, indicating what to inject for that
   * parameter.
   * Or it can be used for a web component property, indicating what that property should resolve to.
   */
  inject(...t) {
    return function(e, r, n) {
      if (typeof n == "number") {
        const s = a$f.getOrCreateAnnotationParamTypes(e), i = t[0];
        i !== void 0 && (s[n] = i);
      } else if (r)
        a$f.defineProperty(e, r, t[0]);
      else {
        const s = n ? a$f.getOrCreateAnnotationParamTypes(n.value) : a$f.getOrCreateAnnotationParamTypes(e);
        let i;
        for (let o = 0; o < t.length; ++o)
          i = t[o], i !== void 0 && (s[o] = i);
      }
    };
  },
  /**
   * Registers the `target` class as a transient dependency; each time the dependency is resolved
   * a new instance will be created.
   *
   * @param target - The class / constructor function to register as transient.
   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
   *
   * @example
   * On an existing class
   * ```ts
   * class Foo { }
   * DI.transient(Foo);
   * ```
   *
   * @example
   * Inline declaration
   *
   * ```ts
   * const Foo = DI.transient(class { });
   * // Foo is now strongly typed with register
   * Foo.register(container);
   * ```
   *
   * @public
   */
  transient(t) {
    return t.register = function(r) {
      return b$5.transient(t, t).register(r);
    }, t.registerInRequestor = false, t;
  },
  /**
   * Registers the `target` class as a singleton dependency; the class will only be created once. Each
   * consecutive time the dependency is resolved, the same instance will be returned.
   *
   * @param target - The class / constructor function to register as a singleton.
   * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
   * @example
   * On an existing class
   * ```ts
   * class Foo { }
   * DI.singleton(Foo);
   * ```
   *
   * @example
   * Inline declaration
   * ```ts
   * const Foo = DI.singleton(class { });
   * // Foo is now strongly typed with register
   * Foo.register(container);
   * ```
   *
   * @public
   */
  singleton(t, e = W) {
    return t.register = function(n) {
      return b$5.singleton(t, t).register(n);
    }, t.registerInRequestor = e.scoped, t;
  }
}), U$1 = a$f.createInterface("Container");
a$f.inject;
const W = { scoped: false };
let f$g = class f {
  constructor(e, r, n) {
    this.key = e, this.strategy = r, this.state = n, this.resolving = false;
  }
  get $isResolver() {
    return true;
  }
  register(e) {
    return e.registerResolver(this.key, this);
  }
  resolve(e, r) {
    switch (this.strategy) {
      case 0:
        return this.state;
      case 1: {
        if (this.resolving)
          throw new Error(`Cyclic dependency found: ${this.state.name}`);
        return this.resolving = true, this.state = e.getFactory(this.state).construct(r), this.strategy = 0, this.resolving = false, this.state;
      }
      case 2: {
        const n = e.getFactory(this.state);
        if (n === null)
          throw new Error(`Resolver for ${String(this.key)} returned a null factory`);
        return n.construct(r);
      }
      case 3:
        return this.state(e, r, this);
      case 4:
        return this.state[0].resolve(e, r);
      case 5:
        return r.get(this.state);
      default:
        throw new Error(`Invalid resolver strategy specified: ${this.strategy}.`);
    }
  }
  getFactory(e) {
    var r, n, s;
    switch (this.strategy) {
      case 1:
      case 2:
        return e.getFactory(this.state);
      case 5:
        return (s = (n = (r = e.getResolver(this.state)) === null || r === void 0 ? void 0 : r.getFactory) === null || n === void 0 ? void 0 : n.call(r, e)) !== null && s !== void 0 ? s : null;
      default:
        return null;
    }
  }
};
function j$2(t) {
  return this.get(t);
}
function q$1(t, e) {
  return e(t);
}
let z$2 = class z {
  constructor(e, r) {
    this.Type = e, this.dependencies = r, this.transformers = null;
  }
  construct(e, r) {
    let n;
    return r === void 0 ? n = new this.Type(...this.dependencies.map(j$2, e)) : n = new this.Type(...this.dependencies.map(j$2, e), ...r), this.transformers == null ? n : this.transformers.reduce(q$1, n);
  }
  registerTransformer(e) {
    (this.transformers || (this.transformers = [])).push(e);
  }
};
const B$1 = {
  $isResolver: true,
  resolve(t, e) {
    return e;
  }
};
function v$5(t) {
  return typeof t.register == "function";
}
function K$3(t) {
  return v$5(t) && typeof t.registerInRequestor == "boolean";
}
function x$1(t) {
  return K$3(t) && t.registerInRequestor;
}
function G$3(t) {
  return t.prototype !== void 0;
}
const H$1 = /* @__PURE__ */ new Set([
  "Array",
  "ArrayBuffer",
  "Boolean",
  "DataView",
  "Date",
  "Error",
  "EvalError",
  "Float32Array",
  "Float64Array",
  "Function",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Map",
  "Number",
  "Object",
  "Promise",
  "RangeError",
  "ReferenceError",
  "RegExp",
  "Set",
  "SharedArrayBuffer",
  "String",
  "SyntaxError",
  "TypeError",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "URIError",
  "WeakMap",
  "WeakSet"
]), D$4 = "__DI_LOCATE_PARENT__", R$2 = /* @__PURE__ */ new Map();
let g$5 = class g {
  constructor(e, r) {
    this.owner = e, this.config = r, this._parent = void 0, this.registerDepth = 0, this.context = null, e !== null && (e.$$container$$ = this), this.resolvers = /* @__PURE__ */ new Map(), this.resolvers.set(U$1, B$1), e instanceof Node && e.addEventListener(D$4, (n) => {
      n.composedPath()[0] !== this.owner && (n.detail.container = this, n.stopImmediatePropagation());
    });
  }
  get parent() {
    return this._parent === void 0 && (this._parent = this.config.parentLocator(this.owner)), this._parent;
  }
  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }
  get responsibleForOwnerRequests() {
    return this.config.responsibleForOwnerRequests;
  }
  registerWithContext(e, ...r) {
    return this.context = e, this.register(...r), this.context = null, this;
  }
  register(...e) {
    if (++this.registerDepth === 100)
      throw new Error("Unable to autoregister dependency");
    let r, n, s, i, o;
    const l = this.context;
    for (let u = 0, c = e.length; u < c; ++u)
      if (r = e[u], !!O$2(r))
        if (v$5(r))
          r.register(this, l);
        else if (G$3(r))
          b$5.singleton(r, r).register(this);
        else
          for (n = Object.keys(r), i = 0, o = n.length; i < o; ++i)
            s = r[n[i]], O$2(s) && (v$5(s) ? s.register(this, l) : this.register(s));
    return --this.registerDepth, this;
  }
  registerResolver(e, r) {
    d$3(e);
    const n = this.resolvers, s = n.get(e);
    return s == null ? n.set(e, r) : s instanceof f$g && s.strategy === 4 ? s.state.push(r) : n.set(e, new f$g(e, 4, [s, r])), r;
  }
  registerTransformer(e, r) {
    const n = this.getResolver(e);
    if (n == null)
      return false;
    if (n.getFactory) {
      const s = n.getFactory(this);
      return s == null ? false : (s.registerTransformer(r), true);
    }
    return false;
  }
  getResolver(e, r = true) {
    if (d$3(e), e.resolve !== void 0)
      return e;
    let n = this, s;
    for (; n != null; )
      if (s = n.resolvers.get(e), s == null) {
        if (n.parent == null) {
          const i = x$1(e) ? this : n;
          return r ? this.jitRegister(e, i) : null;
        }
        n = n.parent;
      } else
        return s;
    return null;
  }
  has(e, r = false) {
    return this.resolvers.has(e) ? true : r && this.parent != null ? this.parent.has(e, true) : false;
  }
  get(e) {
    if (d$3(e), e.$isResolver)
      return e.resolve(this, this);
    let r = this, n;
    for (; r != null; )
      if (n = r.resolvers.get(e), n == null) {
        if (r.parent == null) {
          const s = x$1(e) ? this : r;
          return n = this.jitRegister(e, s), n.resolve(r, this);
        }
        r = r.parent;
      } else
        return n.resolve(r, this);
    throw new Error(`Unable to resolve key: ${String(e)}`);
  }
  getAll(e, r = false) {
    d$3(e);
    const n = this;
    let s = n, i;
    if (r) {
      let o = i$5;
      for (; s != null; )
        i = s.resolvers.get(e), i != null && (o = o.concat(
          /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
          E$5(i, s, n)
        )), s = s.parent;
      return o;
    } else
      for (; s != null; )
        if (i = s.resolvers.get(e), i == null) {
          if (s = s.parent, s == null)
            return i$5;
        } else
          return E$5(i, s, n);
    return i$5;
  }
  getFactory(e) {
    let r = R$2.get(e);
    if (r === void 0) {
      if (J$2(e))
        throw new Error(`${e.name} is a native function and therefore cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`);
      R$2.set(e, r = new z$2(e, a$f.getDependencies(e)));
    }
    return r;
  }
  registerFactory(e, r) {
    R$2.set(e, r);
  }
  createChild(e) {
    return new g(null, Object.assign({}, this.config, e, { parentLocator: () => this }));
  }
  jitRegister(e, r) {
    if (typeof e != "function")
      throw new Error(`Attempted to jitRegister something that is not a constructor: '${e}'. Did you forget to register this dependency?`);
    if (H$1.has(e.name))
      throw new Error(`Attempted to jitRegister an intrinsic type: ${e.name}. Did you forget to add @inject(Key)`);
    if (v$5(e)) {
      const n = e.register(r);
      if (!(n instanceof Object) || n.resolve == null) {
        const s = r.resolvers.get(e);
        if (s != null)
          return s;
        throw new Error("A valid resolver was not returned from the static register method");
      }
      return n;
    } else {
      if (e.$isInterface)
        throw new Error(`Attempted to jitRegister an interface: ${e.friendlyName}`);
      {
        const n = this.config.defaultResolver(e, r);
        return r.resolvers.set(e, n), n;
      }
    }
  }
};
const A$1 = /* @__PURE__ */ new WeakMap();
function F$1(t) {
  return function(e, r, n) {
    if (A$1.has(n))
      return A$1.get(n);
    const s = t(e, r, n);
    return A$1.set(n, s), s;
  };
}
const b$5 = Object.freeze({
  /**
   * Allows you to pass an instance.
   * Every time you request this {@link Key} you will get this instance back.
   *
   * @example
   * ```
   * Registration.instance(Foo, new Foo()));
   * ```
   *
   * @param key - The key to register the instance under.
   * @param value - The instance to return when the key is requested.
   */
  instance(t, e) {
    return new f$g(t, 0, e);
  },
  /**
   * Creates an instance from the class.
   * Every time you request this {@link Key} you will get the same one back.
   *
   * @example
   * ```
   * Registration.singleton(Foo, Foo);
   * ```
   *
   * @param key - The key to register the singleton under.
   * @param value - The class to instantiate as a singleton when first requested.
   */
  singleton(t, e) {
    return new f$g(t, 1, e);
  },
  /**
   * Creates an instance from a class.
   * Every time you request this {@link Key} you will get a new instance.
   *
   * @example
   * ```
   * Registration.instance(Foo, Foo);
   * ```
   *
   * @param key - The key to register the instance type under.
   * @param value - The class to instantiate each time the key is requested.
   */
  transient(t, e) {
    return new f$g(t, 2, e);
  },
  /**
   * Delegates to a callback function to provide the dependency.
   * Every time you request this {@link Key} the callback will be invoked to provide
   * the dependency.
   *
   * @example
   * ```
   * Registration.callback(Foo, () => new Foo());
   * Registration.callback(Bar, (c: Container) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - The key to register the callback for.
   * @param callback - The function that is expected to return the dependency.
   */
  callback(t, e) {
    return new f$g(t, 3, e);
  },
  /**
   * Delegates to a callback function to provide the dependency and then caches the
   * dependency for future requests.
   *
   * @example
   * ```
   * Registration.cachedCallback(Foo, () => new Foo());
   * Registration.cachedCallback(Bar, (c: Container) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - The key to register the callback for.
   * @param callback - The function that is expected to return the dependency.
   * @remarks
   * If you pass the same Registration to another container, the same cached value will be used.
   * Should all references to the resolver returned be removed, the cache will expire.
   */
  cachedCallback(t, e) {
    return new f$g(t, 3, F$1(e));
  },
  /**
   * Creates an alternate {@link Key} to retrieve an instance by.
   *
   * @example
   * ```
   * Register.singleton(Foo, Foo)
   * Register.aliasTo(Foo, MyFoos);
   *
   * container.getAll(MyFoos) // contains an instance of Foo
   * ```
   *
   * @param originalKey - The original key that has been registered.
   * @param aliasKey - The alias to the original key.
   */
  aliasTo(t, e) {
    return new f$g(e, 5, t);
  }
});
function d$3(t) {
  if (t == null)
    throw new Error("key/value cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?");
}
function E$5(t, e, r) {
  if (t instanceof f$g && t.strategy === 4) {
    const n = t.state;
    let s = n.length;
    const i = new Array(s);
    for (; s--; )
      i[s] = n[s].resolve(e, r);
    return i;
  }
  return [t.resolve(e, r)];
}
const I$3 = "(anonymous)";
function O$2(t) {
  return typeof t == "object" && t !== null || typeof t == "function";
}
const J$2 = /* @__PURE__ */ function() {
  const t = /* @__PURE__ */ new WeakMap();
  let e = false, r = "", n = 0;
  return function(s) {
    return e = t.get(s), e === void 0 && (r = s.toString(), n = r.length, e = // 29 is the length of 'function () { [native code] }' which is the smallest length of a native function string
    n >= 29 && // 100 seems to be a safe upper bound of the max length of a native function. In Chrome and FF it's 56, in Edge it's 61.
    n <= 100 && // This whole heuristic *could* be tricked by a comment. Do we need to care about that?
    r.charCodeAt(n - 1) === 125 && // }
    // TODO: the spec is a little vague about the precise constraints, so we do need to test this across various browsers to make sure just one whitespace is a safe assumption.
    r.charCodeAt(n - 2) <= 32 && // whitespace
    r.charCodeAt(n - 3) === 93 && // ]
    r.charCodeAt(n - 4) === 101 && // e
    r.charCodeAt(n - 5) === 100 && // d
    r.charCodeAt(n - 6) === 111 && // o
    r.charCodeAt(n - 7) === 99 && // c
    r.charCodeAt(n - 8) === 32 && //
    r.charCodeAt(n - 9) === 101 && // e
    r.charCodeAt(n - 10) === 118 && // v
    r.charCodeAt(n - 11) === 105 && // i
    r.charCodeAt(n - 12) === 116 && // t
    r.charCodeAt(n - 13) === 97 && // a
    r.charCodeAt(n - 14) === 110 && // n
    r.charCodeAt(n - 15) === 88, t.set(s, e)), e;
  };
}(), p$6 = {};
function M$1(t) {
  switch (typeof t) {
    case "number":
      return t >= 0 && (t | 0) === t;
    case "string": {
      const e = p$6[t];
      if (e !== void 0)
        return e;
      const r = t.length;
      if (r === 0)
        return p$6[t] = false;
      let n = 0;
      for (let s = 0; s < r; ++s)
        if (n = t.charCodeAt(s), s === 0 && n === 48 && r > 1 || n < 48 || n > 57)
          return p$6[t] = false;
      return p$6[t] = true;
    }
    default:
      return false;
  }
}

function s$4(o) {
  return `${o.toLowerCase()}:presentation`;
}
const r$5 = /* @__PURE__ */ new Map(), m$9 = Object.freeze({
  /**
   * Defines a component presentation for an element.
   * @param tagName - The element name to define the presentation for.
   * @param presentation - The presentation that will be applied to matching elements.
   * @param container - The dependency injection container to register the configuration in.
   * @public
   */
  define(o, t, e) {
    const n = s$4(o);
    r$5.get(n) === void 0 ? r$5.set(n, t) : r$5.set(n, false), e.register(b$5.instance(n, t));
  },
  /**
   * Finds a component presentation for the specified element name,
   * searching the DOM hierarchy starting from the provided element.
   * @param tagName - The name of the element to locate the presentation for.
   * @param element - The element to begin the search from.
   * @returns The component presentation or null if none is found.
   * @public
   */
  forTag(o, t) {
    const e = s$4(o), n = r$5.get(e);
    return n === false ? a$f.findResponsibleContainer(t).get(e) : n || null;
  }
});
let g$4 = class g {
  /**
   * Creates an instance of DefaultComponentPresentation.
   * @param template - The template to apply to the element.
   * @param styles - The styles to apply to the element.
   * @public
   */
  constructor(t, e) {
    this.template = t || null, this.styles = e === void 0 ? null : Array.isArray(e) ? h$8.create(e) : e instanceof h$8 ? e : h$8.create([e]);
  }
  /**
   * Applies the presentation details to the specified element.
   * @param element - The element to apply the presentation details to.
   * @public
   */
  applyTo(t) {
    const e = t.$fastController;
    e.template === null && (e.template = this.template), e.styles === null && (e.styles = this.styles);
  }
};

let r$4 = class r extends s$5 {
  constructor() {
    super(...arguments), this._presentation = void 0;
  }
  /**
   * A property which resolves the ComponentPresentation instance
   * for the current component.
   * @public
   */
  get $presentation() {
    return this._presentation === void 0 && (this._presentation = m$9.forTag(this.tagName, this)), this._presentation;
  }
  templateChanged() {
    this.template !== void 0 && (this.$fastController.template = this.template);
  }
  stylesChanged() {
    this.styles !== void 0 && (this.$fastController.styles = this.styles);
  }
  /**
   * The connected callback for this FASTElement.
   * @remarks
   * This method is invoked by the platform whenever this FoundationElement
   * becomes connected to the document.
   * @public
   */
  connectedCallback() {
    this.$presentation !== null && this.$presentation.applyTo(this), super.connectedCallback();
  }
  /**
   * Defines an element registry function with a set of element definition defaults.
   * @param elementDefinition - The definition of the element to create the registry
   * function for.
   * @public
   */
  static compose(s) {
    return (i = {}) => new y$8(this === r ? class extends r {
    } : this, s, i);
  }
};
p$8([
  E$6
], r$4.prototype, "template", void 0);
p$8([
  E$6
], r$4.prototype, "styles", void 0);
function o$7(a, s, i) {
  return typeof a == "function" ? a(s, i) : a;
}
let y$8 = class y {
  constructor(s, i, e) {
    this.type = s, this.elementDefinition = i, this.overrideDefinition = e, this.definition = Object.assign(Object.assign({}, this.elementDefinition), this.overrideDefinition);
  }
  register(s, i) {
    const e = this.definition, f = this.overrideDefinition, d = `${e.prefix || i.elementPrefix}-${e.baseName}`;
    i.tryDefineElement({
      name: d,
      type: this.type,
      baseClass: this.elementDefinition.baseClass,
      callback: (t) => {
        const h = new g$4(o$7(e.template, t, e), o$7(e.styles, t, e));
        t.definePresentation(h);
        let n = o$7(e.shadowOptions, t, e);
        t.shadowRootMode && (n ? f.shadowOptions || (n.mode = t.shadowRootMode) : n !== null && (n = { mode: t.shadowRootMode })), t.defineElement({
          elementOptions: o$7(e.elementOptions, t, e),
          shadowOptions: n,
          attributes: o$7(e.attributes, t, e)
        });
      }
    });
  }
};

const T$1 = /* @__PURE__ */ new Set([
  "children",
  "localName",
  "ref",
  "style",
  "className"
]), M = Object.freeze(/* @__PURE__ */ Object.create(null)), k$6 = "_default", p$5 = /* @__PURE__ */ new Map();
function N$3(e, t) {
  typeof e == "function" ? e(t) : e.current = t;
}
function C$5(e, t) {
  if (!t.name) {
    const n = v$6.forType(e);
    if (n)
      t.name = n.name;
    else
      throw new Error("React wrappers must wrap a FASTElement or be configured with a name.");
  }
  return t.name;
}
function y$7(e) {
  return e.events || (e.events = {});
}
function P$2(e, t, n) {
  return T$1.has(n) ? (console.warn(`${C$5(e, t)} contains property ${n} which is a React reserved property. It will be used by React and not set on the element.`), false) : true;
}
function D$3(e, t) {
  if (!t.keys)
    if (t.properties)
      t.keys = new Set(t.properties.concat(Object.keys(y$7(t))));
    else {
      const n = new Set(Object.keys(y$7(t))), f = u$7.getAccessors(e.prototype);
      if (f.length > 0)
        for (const i of f)
          P$2(e, t, i.name) && n.add(i.name);
      else
        for (const i in e.prototype)
          !(i in HTMLElement.prototype) && P$2(e, t, i) && n.add(i);
      t.keys = n;
    }
  return t.keys;
}
function V$1(e, t) {
  let n = [];
  const f = {
    register(r, ...c) {
      n.forEach((d) => d.register(r, ...c)), n = [];
    }
  };
  function i(r, c = {}) {
    var d, h;
    r instanceof y$8 && (n.push(r), r = r.type);
    const b = p$5.get(r);
    if (b) {
      const a = b.get((d = c.name) !== null && d !== void 0 ? d : k$6);
      if (a)
        return a;
    }
    class O extends e.Component {
      constructor() {
        super(...arguments), this._element = null;
      }
      _updateElement(o) {
        const l = this._element;
        if (l === null)
          return;
        const _ = this.props, w = o || M, m = y$7(c);
        for (const s in this._elementProps) {
          const u = _[s], E = m[s];
          if (E === void 0)
            l[s] = u;
          else {
            const v = w[s];
            if (u === v)
              continue;
            v !== void 0 && l.removeEventListener(E, v), u !== void 0 && l.addEventListener(E, u);
          }
        }
      }
      componentDidMount() {
        this._updateElement();
      }
      componentDidUpdate(o) {
        this._updateElement(o);
      }
      render() {
        const o = this.props.__forwardedRef;
        (this._ref === void 0 || this._userRef !== o) && (this._ref = (s) => {
          this._element === null && (this._element = s), o !== null && N$3(o, s), this._userRef = o;
        });
        const l = { ref: this._ref }, _ = this._elementProps = {}, w = D$3(r, c), m = this.props;
        for (const s in m) {
          const u = m[s];
          w.has(s) ? _[s] = u : l[s === "className" ? "class" : s] = u;
        }
        return e.createElement(C$5(r, c), l);
      }
    }
    const R = e.forwardRef((a, o) => e.createElement(O, Object.assign(Object.assign({}, a), { __forwardedRef: o }), a?.children));
    return p$5.has(r) || p$5.set(r, /* @__PURE__ */ new Map()), p$5.get(r).set((h = c.name) !== null && h !== void 0 ? h : k$6, R), R;
  }
  return { wrap: i, registry: f };
}

const __variableDynamicImportRuntimeHelper = (glob$1, path$13, segs) => {
	const v = glob$1[path$13];
	if (v) return typeof v === "function" ? v() : Promise.resolve(v);
	return new Promise((_, reject) => {
		(typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, /* @__PURE__ */ new Error("Unknown variable dynamic import: " + path$13 + (path$13.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : ""))));
	});
};

const isString = obj => typeof obj === 'string';
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = object => {
  if (object == null) return '';
  return '' + object;
};
const copy = (a, s, t) => {
  a.forEach(m => {
    if (s[m]) t[m] = s[m];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = key => key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;
const canNotTraverseDeeper = object => !object || isString(object);
const getLastOfPath$1 = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split('.');
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath$1 = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath$1(object, path, Object);
  if (obj !== undefined || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath$1(object, p, Object);
  while (last.obj === undefined && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath$1(object, p, Object);
    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== 'undefined') {
      last.obj = undefined;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
};
const pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath$1(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
const getPath$1 = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath$1(object, path);
  if (!obj) return undefined;
  if (!Object.prototype.hasOwnProperty.call(obj, k)) return undefined;
  return obj[k];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath$1(data, key);
  if (value !== undefined) {
    return value;
  }
  return getPath$1(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== '__proto__' && prop !== 'constructor') {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = str => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};
const escape$1 = data => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, s => _entityMap[s]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== undefined) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [' ', ',', '?', '!', ';'];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || '';
  keySeparator = keySeparator || '';
  const possibleChars = chars.filter(c => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map(c => c === '?' ? '\\?' : c).join('|')})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function (obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  if (!obj) return undefined;
  if (obj[path]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path)) return undefined;
    return obj[path];
  }
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length;) {
    if (!current || typeof current !== 'object') {
      return undefined;
    }
    let next;
    let nextPath = '';
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== undefined) {
        if (['string', 'number', 'boolean'].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
const getCleanedCode = code => code?.replace('_', '-');

const consoleLogger = {
  type: 'logger',
  log(args) {
    this.output('log', args);
  },
  warn(args) {
    this.output('warn', args);
  },
  error(args) {
    this.output('error', args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.prefix = options.prefix || 'i18next:';
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, 'log', '', true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, 'warn', '', true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, 'error', '');
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();

class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(' ').forEach(event => {
      if (!this.observers[event]) this.observers[event] = new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(_ref => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers['*']) {
      const cloned = Array.from(this.observers['*'].entries());
      cloned.forEach(_ref2 => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}

class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === undefined) {
      this.options.keySeparator = '.';
    }
    if (this.options.ignoreJSONStructure === undefined) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath$1(this.data, path);
    if (!result && !ns && !key && lng.indexOf('.') > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join('.');
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath$1(this.data, path, value);
    if (!options.silent) this.emit('added', lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit('added', lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng, ns];
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath$1(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath$1(this.data, path, pack);
    if (!options.silent) this.emit('added', lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit('removed', lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== undefined;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find(v => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}

var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach(processor => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};

const checkedLoadedFor = {};
const shouldHandleAsObject = res => !isString(res) && typeof res !== 'boolean' && typeof res !== 'number';
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super();
    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, this);
    this.options = options;
    if (this.options.keySeparator === undefined) {
      this.options.keySeparator = '.';
    }
    this.logger = baseLogger.create('translator');
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      interpolation: {}
    };
    if (key == null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved?.res !== undefined;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === undefined) nsSeparator = ':';
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === 'object') options = {
      ...options
    };
    if (!options) options = {};
    if (keys == null) return '';
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === 'cimode') {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
    const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = options.count !== undefined && !isString(options.count);
    const hasDefaultValue = Translator.hasDefaultValue(options);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
    const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
      ordinal: false
    }) : '';
    const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
    const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            if (hasDefaultValue && !res) {
              copy[m] = this.translate(deepKey, {
                ...options,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : undefined,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy[m] = this.translate(deepKey, {
                ...options,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy[m] === deepKey) copy[m] = resForObjHndl[m];
          }
        }
        res = copy;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === 'all') {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit('missingKey', l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach(language => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach(suffix => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && !isString(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey?.[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach(k => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== undefined && !isString(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
      const needsContextHandling = options.context !== undefined && (isString(options.context) || typeof options.context === 'number') && options.context !== '';
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach(ns => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(', ')}" won't get resolved as namespace "${usedNS}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        }
        codes.forEach(code => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const optionsKeys = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== 'undefined') {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = 'defaultValue';
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
        return true;
      }
    }
    return false;
  }
}

class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create('languageUtils');
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf('-') < 0) return null;
    const p = code.split('-');
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === 'x') return null;
    return this.formatLanguageCode(p.join('-'));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf('-') < 0) return code;
    const p = code.split('-');
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf('-') > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e) {}
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach(code => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach(code => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find(supportedLng => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;
          if (supportedLng.indexOf('-') > 0 && lngOnly.indexOf('-') < 0 && supportedLng.substring(0, supportedLng.indexOf('-')) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = c => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString(code) && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {
      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach(fc => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
}

const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const dummyRule = {
  select: count => count === 1 ? 'one' : 'other',
  resolvedOptions: () => ({
    pluralCategories: ['one', 'other']
  })
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const cleanedCode = getCleanedCode(code === 'dev' ? 'en' : code);
    const type = options.ordinal ? 'ordinal' : 'cardinal';
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error('No Intl support, please use an Intl polyfill!');
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule('dev', options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.getSuffixes(code, options).map(suffix => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule('dev', options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map(pluralCategory => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${pluralCategory}`);
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ''}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix('dev', count, options);
  }
}

const deepFindWithDefaults = function (data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === undefined) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
const regexSafe = val => val.replace(/\$/g, '$$$$');
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.logger = baseLogger.create('interpolator');
    this.options = options;
    this.format = options?.interpolation?.format || (value => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1$1 !== undefined ? escape$1$1 : escape$1;
    this.escapeValue = escapeValue !== undefined ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || '{{';
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || '}}';
    this.formatSeparator = formatSeparator || ',';
    this.unescapePrefix = unescapeSuffix ? '' : unescapePrefix || '-';
    this.unescapeSuffix = this.unescapePrefix ? '' : unescapeSuffix || '';
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape('$t(');
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(')');
    this.nestingOptionsSeparator = nestingOptionsSeparator || ',';
    this.maxReplaces = maxReplaces || 1000;
    this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, 'g');
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = key => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, undefined, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: val => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: val => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach(todo => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === undefined) {
          if (typeof missingInterpolationHandler === 'function') {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : '';
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = '';
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = '';
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map(elem => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = '';
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}

const parseFormatStr = formatStr => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf('(') > -1) {
    const p = formatStr.split('(');
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === 'currency' && optStr.indexOf(':') < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(';');
      opts.forEach(opt => {
        if (opt) {
          const [key, ...rest] = opt.split(':');
          const val = rest.join(':').trim().replace(/^'+|'+$/g, '');
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === 'false') formatOptions[trimmedKey] = false;
          if (val === 'true') formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = fn => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: undefined
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.logger = baseLogger.create('formatter');
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return val => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: 'currency'
        });
        return val => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return val => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return val => formatter.format(val, opt.range || 'day');
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return val => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ',';
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf('(') > 1 && formats[0].indexOf(')') < 0 && formats.find(f => f.indexOf(')') > -1)) {
      const lastIndex = formats.findIndex(f => f.indexOf(')') > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}

const removePending = (q, name) => {
  if (q.pending[name] !== undefined) {
    delete q.pending[name];
    q.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create('backendConnector');
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach(lng => {
      let hasAllNamespaces = true;
      namespaces.forEach(ns => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ; else if (this.state[name] === 1) {
          if (pending[name] === undefined) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === undefined) pending[name] = true;
          if (toLoad[name] === undefined) toLoad[name] = true;
          if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split('|');
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit('failedLoading', lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, undefined, undefined, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach(q => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach(l => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach(n => {
              if (loaded[l][n] === undefined) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit('loaded', loaded);
    this.queue = this.queue.filter(q => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : undefined;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === 'function') {
          r.then(data => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : undefined;
    if (!this.backend) {
      this.logger.warn('No backend was added via i18next.use. Will not load resources.');
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach(name => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    const s = name.split('|');
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, 'read', undefined, undefined, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : () => {};
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
      return;
    }
    if (key === undefined || key === null || key === '') return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === 'function') {
            r.then(data => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}

const get = () => ({
  debug: false,
  initAsync: true,
  ns: ['translation'],
  defaultNS: ['translation'],
  fallbackLng: ['dev'],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: 'all',
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: '.',
  nsSeparator: ':',
  pluralSeparator: '_',
  contextSeparator: '_',
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: 'fallback',
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: args => {
    let ret = {};
    if (typeof args[1] === 'object') ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === 'object' || typeof args[3] === 'object') {
      const options = args[3] || args[2];
      Object.keys(options).forEach(key => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: value => value,
    prefix: '{{',
    suffix: '}}',
    formatSeparator: ',',
    unescapePrefix: '-',
    nestingPrefix: '$t(',
    nestingSuffix: ')',
    nestingOptionsSeparator: ',',
    maxReplaces: 1000,
    skipOnVariables: true
  }
});
const transformOptions = options => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.('cimode') < 0) {
    options.supportedLngs = options.supportedLngs.concat(['cimode']);
  }
  if (typeof options.initImmediate === 'boolean') options.initAsync = options.initImmediate;
  return options;
};

const noop = () => {};
const bindMemberFunctions = inst => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(mem => {
    if (typeof inst[mem] === 'function') {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : undefined;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : undefined;
    this.isInitializing = true;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf('translation') < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== undefined) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== undefined) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = ClassOrObject => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === 'function') return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on('*', function (event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on('*', function (event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach(m => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn('init: no languageDetector is used and no lng is defined');
    }
    const storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
    storeApi.forEach(fcName => {
      this[fcName] = function () {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
    storeApiChained.forEach(fcName => {
      this[fcName] = function () {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn('init: i18next is already initialized. You should call init just once!');
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log('initialized', this.options);
        this.emit('initialized', this.options);
        deferred.resolve(t);
        callback(err, t);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === 'function') usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = lng => {
        if (!lng) return;
        if (lng === 'cimode') return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach(l => {
          if (l === 'cimode') return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach(l => append(l));
      } else {
        append(usedLng);
      }
      this.options.preload?.forEach?.(l => append(l));
      this.services.backendConnector.load(toLoad, this.options.ns, e => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === 'function') {
      callback = lngs;
      lngs = undefined;
    }
    if (typeof ns === 'function') {
      callback = ns;
      ns = undefined;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, err => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
    if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');
    if (module.type === 'backend') {
      this.modules.backend = module;
    }
    if (module.type === 'logger' || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === 'languageDetector') {
      this.modules.languageDetector = module;
    }
    if (module.type === 'i18nFormat') {
      this.modules.i18nFormat = module;
    }
    if (module.type === 'postProcessor') {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === 'formatter') {
      this.modules.formatter = module;
    }
    if (module.type === '3rdParty') {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (['cimode', 'dev'].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit('languageChanging', lng);
    const setLngProps = l => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = undefined;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = undefined;
        this.emit('languageChanged', l);
        this.logger.log('languageChanged', l);
      } else {
        this.isLanguageChangingTo = undefined;
      }
      deferred.resolve(function () {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function () {
        return _this2.t(...arguments);
      });
    };
    const setLng = lngs => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        this.services.languageDetector?.cacheUserLanguage?.(l);
      }
      this.loadResources(l, err => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function (key, opts) {
      let options;
      if (typeof opts !== 'object') {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== '') options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || '.';
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map(k => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.translator?.translate(...args);
  }
  exists() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === 'cimode') return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== undefined) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach(n => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources(err => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter(lng => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources(err => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return 'rtl';
    const rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : undefined;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== undefined || options.prefix !== undefined) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ['store', 'services', 'language'];
    membersToCopy.forEach(m => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
        prev[l] = {
          ...this.store.data[l]
        };
        return Object.keys(prev[l]).reduce((acc, n) => {
          acc[n] = {
            ...prev[l][n]
          };
          return acc;
        }, {});
      }, {});
      clone.store = new ResourceStore(clonedData, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on('*', function (event) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;

instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;

var resourcesToBackend = function resourcesToBackend(res) {
  return {
    type: 'backend',
    init: function init(services, backendOptions, i18nextOptions) {},
    read: function read(language, namespace, callback) {
      if (typeof res === 'function') {
        if (res.length < 3) {
          try {
            var r = res(language, namespace);
            if (r && typeof r.then === 'function') {
              r.then(function (data) {
                return callback(null, data && data.default || data);
              }).catch(callback);
            } else {
              callback(null, r);
            }
          } catch (err) {
            callback(err);
          }
          return;
        }
        res(language, namespace, callback);
        return;
      }
      callback(null, res && res[language] && res[language][namespace]);
    }
  };
};

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics$1(d, b);
};

function __extends$1(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  };
  return __assign$1.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

//
// Main
//
function memoize(fn, options) {
    var cache = options && options.cache ? options.cache : cacheDefault;
    var serializer = options && options.serializer ? options.serializer : serializerDefault;
    var strategy = options && options.strategy ? options.strategy : strategyDefault;
    return strategy(fn, {
        cache: cache,
        serializer: serializer,
    });
}
//
// Strategy
//
function isPrimitive(value) {
    return (value == null || typeof value === 'number' || typeof value === 'boolean'); // || typeof value === "string" 'unsafe' primitive for our needs
}
function monadic(fn, cache, serializer, arg) {
    var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.call(this, arg);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function variadic(fn, cache, serializer) {
    var args = Array.prototype.slice.call(arguments, 3);
    var cacheKey = serializer(args);
    var computedValue = cache.get(cacheKey);
    if (typeof computedValue === 'undefined') {
        computedValue = fn.apply(this, args);
        cache.set(cacheKey, computedValue);
    }
    return computedValue;
}
function assemble(fn, context, strategy, cache, serialize) {
    return strategy.bind(context, fn, cache, serialize);
}
function strategyDefault(fn, options) {
    var strategy = fn.length === 1 ? monadic : variadic;
    return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
    return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
//
// Serializer
//
var serializerDefault = function () {
    return JSON.stringify(arguments);
};
//
// Cache
//
var ObjectWithoutPrototypeCache = /** @class */ (function () {
    function ObjectWithoutPrototypeCache() {
        this.cache = Object.create(null);
    }
    ObjectWithoutPrototypeCache.prototype.get = function (key) {
        return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
        this.cache[key] = value;
    };
    return ObjectWithoutPrototypeCache;
}());
var cacheDefault = {
    create: function create() {
        return new ObjectWithoutPrototypeCache();
    },
};
var strategies = {
    variadic: strategyVariadic};

var ErrorKind;
(function (ErrorKind) {
    /** Argument is unclosed (e.g. `{0`) */
    ErrorKind[ErrorKind["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
    /** Argument is empty (e.g. `{}`). */
    ErrorKind[ErrorKind["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
    /** Argument is malformed (e.g. `{foo!}``) */
    ErrorKind[ErrorKind["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
    /** Expect an argument type (e.g. `{foo,}`) */
    ErrorKind[ErrorKind["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
    /** Unsupported argument type (e.g. `{foo,foo}`) */
    ErrorKind[ErrorKind["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
    /** Expect an argument style (e.g. `{foo, number, }`) */
    ErrorKind[ErrorKind["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
    /** The number skeleton is invalid. */
    ErrorKind[ErrorKind["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
    /** The date time skeleton is invalid. */
    ErrorKind[ErrorKind["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
    /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */
    ErrorKind[ErrorKind["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
    /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */
    ErrorKind[ErrorKind["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
    /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */
    ErrorKind[ErrorKind["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
    /** Missing select argument options (e.g. `{foo, select}`) */
    ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
    /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */
    ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
    /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */
    ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
    /** Expecting a selector in `select` argument (e.g `{foo, select}`) */
    ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
    /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */
    ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
    /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */
    ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
    /**
     * Expecting a message fragment after the `plural` or `selectordinal` selector
     * (e.g. `{foo, plural, one}`)
     */
    ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
    /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */
    ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
    /**
     * Duplicate selectors in `plural` or `selectordinal` argument.
     * (e.g. {foo, plural, one {#} one {#}})
     */
    ErrorKind[ErrorKind["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
    /** Duplicate selectors in `select` argument.
     * (e.g. {foo, select, apple {apple} apple {apple}})
     */
    ErrorKind[ErrorKind["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
    /** Plural or select argument option must have `other` clause. */
    ErrorKind[ErrorKind["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
    /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */
    ErrorKind[ErrorKind["INVALID_TAG"] = 23] = "INVALID_TAG";
    /** The tag name is invalid. (e.g. `<123>foo</123>`) */
    ErrorKind[ErrorKind["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
    /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */
    ErrorKind[ErrorKind["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
    /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */
    ErrorKind[ErrorKind["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));

var TYPE;
(function (TYPE) {
    /**
     * Raw text
     */
    TYPE[TYPE["literal"] = 0] = "literal";
    /**
     * Variable w/o any format, e.g `var` in `this is a {var}`
     */
    TYPE[TYPE["argument"] = 1] = "argument";
    /**
     * Variable w/ number format
     */
    TYPE[TYPE["number"] = 2] = "number";
    /**
     * Variable w/ date format
     */
    TYPE[TYPE["date"] = 3] = "date";
    /**
     * Variable w/ time format
     */
    TYPE[TYPE["time"] = 4] = "time";
    /**
     * Variable w/ select format
     */
    TYPE[TYPE["select"] = 5] = "select";
    /**
     * Variable w/ plural format
     */
    TYPE[TYPE["plural"] = 6] = "plural";
    /**
     * Only possible within plural argument.
     * This is the `#` symbol that will be substituted with the count.
     */
    TYPE[TYPE["pound"] = 7] = "pound";
    /**
     * XML-like tag
     */
    TYPE[TYPE["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function (SKELETON_TYPE) {
    SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
    SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
/**
 * Type Guards
 */
function isLiteralElement(el) {
    return el.type === TYPE.literal;
}
function isArgumentElement(el) {
    return el.type === TYPE.argument;
}
function isNumberElement(el) {
    return el.type === TYPE.number;
}
function isDateElement(el) {
    return el.type === TYPE.date;
}
function isTimeElement(el) {
    return el.type === TYPE.time;
}
function isSelectElement(el) {
    return el.type === TYPE.select;
}
function isPluralElement(el) {
    return el.type === TYPE.plural;
}
function isPoundElement(el) {
    return el.type === TYPE.pound;
}
function isTagElement(el) {
    return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
    return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
    return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);
}

// @generated from regex-gen.ts
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

/**
 * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
 * with some tweaks
 */
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
/**
 * Parse Date time skeleton into Intl.DateTimeFormatOptions
 * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * @public
 * @param skeleton skeleton string
 */
function parseDateTimeSkeleton(skeleton) {
    var result = {};
    skeleton.replace(DATE_TIME_REGEX, function (match) {
        var len = match.length;
        switch (match[0]) {
            // Era
            case 'G':
                result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                break;
            // Year
            case 'y':
                result.year = len === 2 ? '2-digit' : 'numeric';
                break;
            case 'Y':
            case 'u':
            case 'U':
            case 'r':
                throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
            // Quarter
            case 'q':
            case 'Q':
                throw new RangeError('`q/Q` (quarter) patterns are not supported');
            // Month
            case 'M':
            case 'L':
                result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
                break;
            // Week
            case 'w':
            case 'W':
                throw new RangeError('`w/W` (week) patterns are not supported');
            case 'd':
                result.day = ['numeric', '2-digit'][len - 1];
                break;
            case 'D':
            case 'F':
            case 'g':
                throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
            // Weekday
            case 'E':
                result.weekday = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                break;
            case 'e':
                if (len < 4) {
                    throw new RangeError('`e..eee` (weekday) patterns are not supported');
                }
                result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                break;
            case 'c':
                if (len < 4) {
                    throw new RangeError('`c..ccc` (weekday) patterns are not supported');
                }
                result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                break;
            // Period
            case 'a': // AM, PM
                result.hour12 = true;
                break;
            case 'b': // am, pm, noon, midnight
            case 'B': // flexible day periods
                throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
            // Hour
            case 'h':
                result.hourCycle = 'h12';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'H':
                result.hourCycle = 'h23';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'K':
                result.hourCycle = 'h11';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'k':
                result.hourCycle = 'h24';
                result.hour = ['numeric', '2-digit'][len - 1];
                break;
            case 'j':
            case 'J':
            case 'C':
                throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
            // Minute
            case 'm':
                result.minute = ['numeric', '2-digit'][len - 1];
                break;
            // Second
            case 's':
                result.second = ['numeric', '2-digit'][len - 1];
                break;
            case 'S':
            case 'A':
                throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');
            // Zone
            case 'z': // 1..3, 4: specific non-location format
                result.timeZoneName = len < 4 ? 'short' : 'long';
                break;
            case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
            case 'O': // 1, 4: milliseconds in day short, long
            case 'v': // 1, 4: generic non-location format
            case 'V': // 1, 2, 3, 4: time zone ID or city
            case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
            case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
                throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');
        }
        return '';
    });
    return result;
}

// @generated from regex-gen.ts
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

function parseNumberSkeletonFromString(skeleton) {
    if (skeleton.length === 0) {
        throw new Error('Number skeleton cannot be empty');
    }
    // Parse the skeleton
    var stringTokens = skeleton
        .split(WHITE_SPACE_REGEX)
        .filter(function (x) { return x.length > 0; });
    var tokens = [];
    for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
        var stringToken = stringTokens_1[_i];
        var stemAndOptions = stringToken.split('/');
        if (stemAndOptions.length === 0) {
            throw new Error('Invalid number skeleton');
        }
        var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
        for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
            var option = options_1[_a];
            if (option.length === 0) {
                throw new Error('Invalid number skeleton');
            }
        }
        tokens.push({ stem: stem, options: options });
    }
    return tokens;
}
function icuUnitToEcma(unit) {
    return unit.replace(/^(.*?)-/, '');
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
    var result = {};
    if (str[str.length - 1] === 'r') {
        result.roundingPriority = 'morePrecision';
    }
    else if (str[str.length - 1] === 's') {
        result.roundingPriority = 'lessPrecision';
    }
    str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {
        // @@@ case
        if (typeof g2 !== 'string') {
            result.minimumSignificantDigits = g1.length;
            result.maximumSignificantDigits = g1.length;
        }
        // @@@+ case
        else if (g2 === '+') {
            result.minimumSignificantDigits = g1.length;
        }
        // .### case
        else if (g1[0] === '#') {
            result.maximumSignificantDigits = g1.length;
        }
        // .@@## or .@@@ case
        else {
            result.minimumSignificantDigits = g1.length;
            result.maximumSignificantDigits =
                g1.length + (typeof g2 === 'string' ? g2.length : 0);
        }
        return '';
    });
    return result;
}
function parseSign(str) {
    switch (str) {
        case 'sign-auto':
            return {
                signDisplay: 'auto',
            };
        case 'sign-accounting':
        case '()':
            return {
                currencySign: 'accounting',
            };
        case 'sign-always':
        case '+!':
            return {
                signDisplay: 'always',
            };
        case 'sign-accounting-always':
        case '()!':
            return {
                signDisplay: 'always',
                currencySign: 'accounting',
            };
        case 'sign-except-zero':
        case '+?':
            return {
                signDisplay: 'exceptZero',
            };
        case 'sign-accounting-except-zero':
        case '()?':
            return {
                signDisplay: 'exceptZero',
                currencySign: 'accounting',
            };
        case 'sign-never':
        case '+_':
            return {
                signDisplay: 'never',
            };
    }
}
function parseConciseScientificAndEngineeringStem(stem) {
    // Engineering
    var result;
    if (stem[0] === 'E' && stem[1] === 'E') {
        result = {
            notation: 'engineering',
        };
        stem = stem.slice(2);
    }
    else if (stem[0] === 'E') {
        result = {
            notation: 'scientific',
        };
        stem = stem.slice(1);
    }
    if (result) {
        var signDisplay = stem.slice(0, 2);
        if (signDisplay === '+!') {
            result.signDisplay = 'always';
            stem = stem.slice(2);
        }
        else if (signDisplay === '+?') {
            result.signDisplay = 'exceptZero';
            stem = stem.slice(2);
        }
        if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
            throw new Error('Malformed concise eng/scientific notation');
        }
        result.minimumIntegerDigits = stem.length;
    }
    return result;
}
function parseNotationOptions(opt) {
    var result = {};
    var signOpts = parseSign(opt);
    if (signOpts) {
        return signOpts;
    }
    return result;
}
/**
 * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options
 */
function parseNumberSkeleton(tokens) {
    var result = {};
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        switch (token.stem) {
            case 'percent':
            case '%':
                result.style = 'percent';
                continue;
            case '%x100':
                result.style = 'percent';
                result.scale = 100;
                continue;
            case 'currency':
                result.style = 'currency';
                result.currency = token.options[0];
                continue;
            case 'group-off':
            case ',_':
                result.useGrouping = false;
                continue;
            case 'precision-integer':
            case '.':
                result.maximumFractionDigits = 0;
                continue;
            case 'measure-unit':
            case 'unit':
                result.style = 'unit';
                result.unit = icuUnitToEcma(token.options[0]);
                continue;
            case 'compact-short':
            case 'K':
                result.notation = 'compact';
                result.compactDisplay = 'short';
                continue;
            case 'compact-long':
            case 'KK':
                result.notation = 'compact';
                result.compactDisplay = 'long';
                continue;
            case 'scientific':
                result = __assign$1(__assign$1(__assign$1({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (__assign$1(__assign$1({}, all), parseNotationOptions(opt))); }, {}));
                continue;
            case 'engineering':
                result = __assign$1(__assign$1(__assign$1({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (__assign$1(__assign$1({}, all), parseNotationOptions(opt))); }, {}));
                continue;
            case 'notation-simple':
                result.notation = 'standard';
                continue;
            // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
            case 'unit-width-narrow':
                result.currencyDisplay = 'narrowSymbol';
                result.unitDisplay = 'narrow';
                continue;
            case 'unit-width-short':
                result.currencyDisplay = 'code';
                result.unitDisplay = 'short';
                continue;
            case 'unit-width-full-name':
                result.currencyDisplay = 'name';
                result.unitDisplay = 'long';
                continue;
            case 'unit-width-iso-code':
                result.currencyDisplay = 'symbol';
                continue;
            case 'scale':
                result.scale = parseFloat(token.options[0]);
                continue;
            case 'rounding-mode-floor':
                result.roundingMode = 'floor';
                continue;
            case 'rounding-mode-ceiling':
                result.roundingMode = 'ceil';
                continue;
            case 'rounding-mode-down':
                result.roundingMode = 'trunc';
                continue;
            case 'rounding-mode-up':
                result.roundingMode = 'expand';
                continue;
            case 'rounding-mode-half-even':
                result.roundingMode = 'halfEven';
                continue;
            case 'rounding-mode-half-down':
                result.roundingMode = 'halfTrunc';
                continue;
            case 'rounding-mode-half-up':
                result.roundingMode = 'halfExpand';
                continue;
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
            case 'integer-width':
                if (token.options.length > 1) {
                    throw new RangeError('integer-width stems only accept a single optional option');
                }
                token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {
                    if (g1) {
                        result.minimumIntegerDigits = g2.length;
                    }
                    else if (g3 && g4) {
                        throw new Error('We currently do not support maximum integer digits');
                    }
                    else if (g5) {
                        throw new Error('We currently do not support exact integer digits');
                    }
                    return '';
                });
                continue;
        }
        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
        if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
            result.minimumIntegerDigits = token.stem.length;
            continue;
        }
        if (FRACTION_PRECISION_REGEX.test(token.stem)) {
            // Precision
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision
            // precision-integer case
            if (token.options.length > 1) {
                throw new RangeError('Fraction-precision stems only accept a single optional option');
            }
            token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {
                // .000* case (before ICU67 it was .000+)
                if (g2 === '*') {
                    result.minimumFractionDigits = g1.length;
                }
                // .### case
                else if (g3 && g3[0] === '#') {
                    result.maximumFractionDigits = g3.length;
                }
                // .00## case
                else if (g4 && g5) {
                    result.minimumFractionDigits = g4.length;
                    result.maximumFractionDigits = g4.length + g5.length;
                }
                else {
                    result.minimumFractionDigits = g1.length;
                    result.maximumFractionDigits = g1.length;
                }
                return '';
            });
            var opt = token.options[0];
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display
            if (opt === 'w') {
                result = __assign$1(__assign$1({}, result), { trailingZeroDisplay: 'stripIfInteger' });
            }
            else if (opt) {
                result = __assign$1(__assign$1({}, result), parseSignificantPrecision(opt));
            }
            continue;
        }
        // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision
        if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
            result = __assign$1(__assign$1({}, result), parseSignificantPrecision(token.stem));
            continue;
        }
        var signOpts = parseSign(token.stem);
        if (signOpts) {
            result = __assign$1(__assign$1({}, result), signOpts);
        }
        var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
        if (conciseScientificAndEngineeringOpts) {
            result = __assign$1(__assign$1({}, result), conciseScientificAndEngineeringOpts);
        }
    }
    return result;
}

// @generated from time-data-gen.ts
// prettier-ignore  
var timeData = {
    "001": [
        "H",
        "h"
    ],
    "419": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "AC": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "AD": [
        "H",
        "hB"
    ],
    "AE": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "AF": [
        "H",
        "hb",
        "hB",
        "h"
    ],
    "AG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "AI": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "AL": [
        "h",
        "H",
        "hB"
    ],
    "AM": [
        "H",
        "hB"
    ],
    "AO": [
        "H",
        "hB"
    ],
    "AR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "AS": [
        "h",
        "H"
    ],
    "AT": [
        "H",
        "hB"
    ],
    "AU": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "AW": [
        "H",
        "hB"
    ],
    "AX": [
        "H"
    ],
    "AZ": [
        "H",
        "hB",
        "h"
    ],
    "BA": [
        "H",
        "hB",
        "h"
    ],
    "BB": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BD": [
        "h",
        "hB",
        "H"
    ],
    "BE": [
        "H",
        "hB"
    ],
    "BF": [
        "H",
        "hB"
    ],
    "BG": [
        "H",
        "hB",
        "h"
    ],
    "BH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "BI": [
        "H",
        "h"
    ],
    "BJ": [
        "H",
        "hB"
    ],
    "BL": [
        "H",
        "hB"
    ],
    "BM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BN": [
        "hb",
        "hB",
        "h",
        "H"
    ],
    "BO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "BQ": [
        "H"
    ],
    "BR": [
        "H",
        "hB"
    ],
    "BS": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "BT": [
        "h",
        "H"
    ],
    "BW": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "BY": [
        "H",
        "h"
    ],
    "BZ": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CA": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "CC": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CD": [
        "hB",
        "H"
    ],
    "CF": [
        "H",
        "h",
        "hB"
    ],
    "CG": [
        "H",
        "hB"
    ],
    "CH": [
        "H",
        "hB",
        "h"
    ],
    "CI": [
        "H",
        "hB"
    ],
    "CK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CL": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CM": [
        "H",
        "h",
        "hB"
    ],
    "CN": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "CO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CP": [
        "H"
    ],
    "CR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CU": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "CV": [
        "H",
        "hB"
    ],
    "CW": [
        "H",
        "hB"
    ],
    "CX": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "CY": [
        "h",
        "H",
        "hb",
        "hB"
    ],
    "CZ": [
        "H"
    ],
    "DE": [
        "H",
        "hB"
    ],
    "DG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "DJ": [
        "h",
        "H"
    ],
    "DK": [
        "H"
    ],
    "DM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "DO": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "DZ": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "EA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "EC": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "EE": [
        "H",
        "hB"
    ],
    "EG": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "EH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "ER": [
        "h",
        "H"
    ],
    "ES": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "ET": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "FI": [
        "H"
    ],
    "FJ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "FK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "FM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "FO": [
        "H",
        "h"
    ],
    "FR": [
        "H",
        "hB"
    ],
    "GA": [
        "H",
        "hB"
    ],
    "GB": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GD": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GE": [
        "H",
        "hB",
        "h"
    ],
    "GF": [
        "H",
        "hB"
    ],
    "GG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GH": [
        "h",
        "H"
    ],
    "GI": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "GL": [
        "H",
        "h"
    ],
    "GM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GN": [
        "H",
        "hB"
    ],
    "GP": [
        "H",
        "hB"
    ],
    "GQ": [
        "H",
        "hB",
        "h",
        "hb"
    ],
    "GR": [
        "h",
        "H",
        "hb",
        "hB"
    ],
    "GT": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "GU": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "GW": [
        "H",
        "hB"
    ],
    "GY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "HK": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "HN": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "HR": [
        "H",
        "hB"
    ],
    "HU": [
        "H",
        "h"
    ],
    "IC": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "ID": [
        "H"
    ],
    "IE": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IL": [
        "H",
        "hB"
    ],
    "IM": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IN": [
        "h",
        "H"
    ],
    "IO": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "IQ": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "IR": [
        "hB",
        "H"
    ],
    "IS": [
        "H"
    ],
    "IT": [
        "H",
        "hB"
    ],
    "JE": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "JM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "JO": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "JP": [
        "H",
        "K",
        "h"
    ],
    "KE": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "KG": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "KH": [
        "hB",
        "h",
        "H",
        "hb"
    ],
    "KI": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KM": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "KN": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KP": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "KR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "KW": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "KY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "KZ": [
        "H",
        "hB"
    ],
    "LA": [
        "H",
        "hb",
        "hB",
        "h"
    ],
    "LB": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "LC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "LI": [
        "H",
        "hB",
        "h"
    ],
    "LK": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "LR": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "LS": [
        "h",
        "H"
    ],
    "LT": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "LU": [
        "H",
        "h",
        "hB"
    ],
    "LV": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "LY": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "MC": [
        "H",
        "hB"
    ],
    "MD": [
        "H",
        "hB"
    ],
    "ME": [
        "H",
        "hB",
        "h"
    ],
    "MF": [
        "H",
        "hB"
    ],
    "MG": [
        "H",
        "h"
    ],
    "MH": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MK": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "ML": [
        "H"
    ],
    "MM": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "MN": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "MO": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MP": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MQ": [
        "H",
        "hB"
    ],
    "MR": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "MS": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "MT": [
        "H",
        "h"
    ],
    "MU": [
        "H",
        "h"
    ],
    "MV": [
        "H",
        "h"
    ],
    "MW": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "MX": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "MY": [
        "hb",
        "hB",
        "h",
        "H"
    ],
    "MZ": [
        "H",
        "hB"
    ],
    "NA": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "NC": [
        "H",
        "hB"
    ],
    "NE": [
        "H"
    ],
    "NF": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NG": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NI": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "NL": [
        "H",
        "hB"
    ],
    "NO": [
        "H",
        "h"
    ],
    "NP": [
        "H",
        "h",
        "hB"
    ],
    "NR": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NU": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "NZ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "OM": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PA": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PE": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PF": [
        "H",
        "h",
        "hB"
    ],
    "PG": [
        "h",
        "H"
    ],
    "PH": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PK": [
        "h",
        "hB",
        "H"
    ],
    "PL": [
        "H",
        "h"
    ],
    "PM": [
        "H",
        "hB"
    ],
    "PN": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "PR": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "PS": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "PT": [
        "H",
        "hB"
    ],
    "PW": [
        "h",
        "H"
    ],
    "PY": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "QA": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "RE": [
        "H",
        "hB"
    ],
    "RO": [
        "H",
        "hB"
    ],
    "RS": [
        "H",
        "hB",
        "h"
    ],
    "RU": [
        "H"
    ],
    "RW": [
        "H",
        "h"
    ],
    "SA": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SB": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SC": [
        "H",
        "h",
        "hB"
    ],
    "SD": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SE": [
        "H"
    ],
    "SG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SH": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "SI": [
        "H",
        "hB"
    ],
    "SJ": [
        "H"
    ],
    "SK": [
        "H"
    ],
    "SL": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "SM": [
        "H",
        "h",
        "hB"
    ],
    "SN": [
        "H",
        "h",
        "hB"
    ],
    "SO": [
        "h",
        "H"
    ],
    "SR": [
        "H",
        "hB"
    ],
    "SS": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "ST": [
        "H",
        "hB"
    ],
    "SV": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "SX": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "SY": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "SZ": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TA": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "TC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TD": [
        "h",
        "H",
        "hB"
    ],
    "TF": [
        "H",
        "h",
        "hB"
    ],
    "TG": [
        "H",
        "hB"
    ],
    "TH": [
        "H",
        "h"
    ],
    "TJ": [
        "H",
        "h"
    ],
    "TL": [
        "H",
        "hB",
        "hb",
        "h"
    ],
    "TM": [
        "H",
        "h"
    ],
    "TN": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "TO": [
        "h",
        "H"
    ],
    "TR": [
        "H",
        "hB"
    ],
    "TT": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "TW": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "TZ": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "UA": [
        "H",
        "hB",
        "h"
    ],
    "UG": [
        "hB",
        "hb",
        "H",
        "h"
    ],
    "UM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "US": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "UY": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "UZ": [
        "H",
        "hB",
        "h"
    ],
    "VA": [
        "H",
        "h",
        "hB"
    ],
    "VC": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VE": [
        "h",
        "H",
        "hB",
        "hb"
    ],
    "VG": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VI": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "VN": [
        "H",
        "h"
    ],
    "VU": [
        "h",
        "H"
    ],
    "WF": [
        "H",
        "hB"
    ],
    "WS": [
        "h",
        "H"
    ],
    "XK": [
        "H",
        "hB",
        "h"
    ],
    "YE": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "YT": [
        "H",
        "hB"
    ],
    "ZA": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "ZM": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "ZW": [
        "H",
        "h"
    ],
    "af-ZA": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "ar-001": [
        "h",
        "hB",
        "hb",
        "H"
    ],
    "ca-ES": [
        "H",
        "h",
        "hB"
    ],
    "en-001": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "en-HK": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "en-IL": [
        "H",
        "h",
        "hb",
        "hB"
    ],
    "en-MY": [
        "h",
        "hb",
        "H",
        "hB"
    ],
    "es-BR": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-ES": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "es-GQ": [
        "H",
        "h",
        "hB",
        "hb"
    ],
    "fr-CA": [
        "H",
        "h",
        "hB"
    ],
    "gl-ES": [
        "H",
        "h",
        "hB"
    ],
    "gu-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "hi-IN": [
        "hB",
        "h",
        "H"
    ],
    "it-CH": [
        "H",
        "h",
        "hB"
    ],
    "it-IT": [
        "H",
        "h",
        "hB"
    ],
    "kn-IN": [
        "hB",
        "h",
        "H"
    ],
    "ml-IN": [
        "hB",
        "h",
        "H"
    ],
    "mr-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "pa-IN": [
        "hB",
        "hb",
        "h",
        "H"
    ],
    "ta-IN": [
        "hB",
        "h",
        "hb",
        "H"
    ],
    "te-IN": [
        "hB",
        "h",
        "H"
    ],
    "zu-ZA": [
        "H",
        "hB",
        "hb",
        "h"
    ]
};

/**
 * Returns the best matching date time pattern if a date time skeleton
 * pattern is provided with a locale. Follows the Unicode specification:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#table-mapping-requested-time-skeletons-to-patterns
 * @param skeleton date time skeleton pattern that possibly includes j, J or C
 * @param locale
 */
function getBestPattern(skeleton, locale) {
    var skeletonCopy = '';
    for (var patternPos = 0; patternPos < skeleton.length; patternPos++) {
        var patternChar = skeleton.charAt(patternPos);
        if (patternChar === 'j') {
            var extraLength = 0;
            while (patternPos + 1 < skeleton.length &&
                skeleton.charAt(patternPos + 1) === patternChar) {
                extraLength++;
                patternPos++;
            }
            var hourLen = 1 + (extraLength & 1);
            var dayPeriodLen = extraLength < 2 ? 1 : 3 + (extraLength >> 1);
            var dayPeriodChar = 'a';
            var hourChar = getDefaultHourSymbolFromLocale(locale);
            if (hourChar == 'H' || hourChar == 'k') {
                dayPeriodLen = 0;
            }
            while (dayPeriodLen-- > 0) {
                skeletonCopy += dayPeriodChar;
            }
            while (hourLen-- > 0) {
                skeletonCopy = hourChar + skeletonCopy;
            }
        }
        else if (patternChar === 'J') {
            skeletonCopy += 'H';
        }
        else {
            skeletonCopy += patternChar;
        }
    }
    return skeletonCopy;
}
/**
 * Maps the [hour cycle type](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/hourCycle)
 * of the given `locale` to the corresponding time pattern.
 * @param locale
 */
function getDefaultHourSymbolFromLocale(locale) {
    var hourCycle = locale.hourCycle;
    if (hourCycle === undefined &&
        // @ts-ignore hourCycle(s) is not identified yet
        locale.hourCycles &&
        // @ts-ignore
        locale.hourCycles.length) {
        // @ts-ignore
        hourCycle = locale.hourCycles[0];
    }
    if (hourCycle) {
        switch (hourCycle) {
            case 'h24':
                return 'k';
            case 'h23':
                return 'H';
            case 'h12':
                return 'h';
            case 'h11':
                return 'K';
            default:
                throw new Error('Invalid hourCycle');
        }
    }
    // TODO: Once hourCycle is fully supported remove the following with data generation
    var languageTag = locale.language;
    var regionTag;
    if (languageTag !== 'root') {
        regionTag = locale.maximize().region;
    }
    var hourCycles = timeData[regionTag || ''] ||
        timeData[languageTag || ''] ||
        timeData["".concat(languageTag, "-001")] ||
        timeData['001'];
    return hourCycles[0];
}

var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
    return { start: start, end: end };
}
// #region Ponyfills
// Consolidate these variables up top for easier toggling during debugging
var hasNativeStartsWith = !!String.prototype.startsWith && '_a'.startsWith('a', 1);
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger
    ? Number.isSafeInteger
    : function (n) {
        return (typeof n === 'number' &&
            isFinite(n) &&
            Math.floor(n) === n &&
            Math.abs(n) <= 0x1fffffffffffff);
    };
// IE11 does not support y and u.
var REGEX_SUPPORTS_U_AND_Y = true;
try {
    var re$1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
    /**
     * legacy Edge or Xbox One browser
     * Unicode flag support: supported
     * Pattern_Syntax support: not supported
     * See https://github.com/formatjs/formatjs/issues/2822
     */
    REGEX_SUPPORTS_U_AND_Y = ((_a = re$1.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';
}
catch (_) {
    REGEX_SUPPORTS_U_AND_Y = false;
}
var startsWith = hasNativeStartsWith
    ? // Native
        function startsWith(s, search, position) {
            return s.startsWith(search, position);
        }
    : // For IE11
        function startsWith(s, search, position) {
            return s.slice(position, position + search.length) === search;
        };
var fromCodePoint = hasNativeFromCodePoint
    ? String.fromCodePoint
    : // IE11
        function fromCodePoint() {
            var codePoints = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                codePoints[_i] = arguments[_i];
            }
            var elements = '';
            var length = codePoints.length;
            var i = 0;
            var code;
            while (length > i) {
                code = codePoints[i++];
                if (code > 0x10ffff)
                    throw RangeError(code + ' is not a valid code point');
                elements +=
                    code < 0x10000
                        ? String.fromCharCode(code)
                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);
            }
            return elements;
        };
var fromEntries = 
// native
hasNativeFromEntries
    ? Object.fromEntries
    : // Ponyfill
        function fromEntries(entries) {
            var obj = {};
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var _a = entries_1[_i], k = _a[0], v = _a[1];
                obj[k] = v;
            }
            return obj;
        };
var codePointAt = hasNativeCodePointAt
    ? // Native
        function codePointAt(s, index) {
            return s.codePointAt(index);
        }
    : // IE 11
        function codePointAt(s, index) {
            var size = s.length;
            if (index < 0 || index >= size) {
                return undefined;
            }
            var first = s.charCodeAt(index);
            var second;
            return first < 0xd800 ||
                first > 0xdbff ||
                index + 1 === size ||
                (second = s.charCodeAt(index + 1)) < 0xdc00 ||
                second > 0xdfff
                ? first
                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;
        };
var trimStart = hasTrimStart
    ? // Native
        function trimStart(s) {
            return s.trimStart();
        }
    : // Ponyfill
        function trimStart(s) {
            return s.replace(SPACE_SEPARATOR_START_REGEX, '');
        };
var trimEnd = hasTrimEnd
    ? // Native
        function trimEnd(s) {
            return s.trimEnd();
        }
    : // Ponyfill
        function trimEnd(s) {
            return s.replace(SPACE_SEPARATOR_END_REGEX, '');
        };
// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.
function RE(s, flag) {
    return new RegExp(s, flag);
}
// #endregion
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
    // Native
    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
        var _a;
        IDENTIFIER_PREFIX_RE_1.lastIndex = index;
        var match = IDENTIFIER_PREFIX_RE_1.exec(s);
        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';
    };
}
else {
    // IE11
    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
        var match = [];
        while (true) {
            var c = codePointAt(s, index);
            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {
                break;
            }
            match.push(c);
            index += c >= 0x10000 ? 2 : 1;
        }
        return fromCodePoint.apply(void 0, match);
    };
}
var Parser = /** @class */ (function () {
    function Parser(message, options) {
        if (options === void 0) { options = {}; }
        this.message = message;
        this.position = { offset: 0, line: 1, column: 1 };
        this.ignoreTag = !!options.ignoreTag;
        this.locale = options.locale;
        this.requiresOtherClause = !!options.requiresOtherClause;
        this.shouldParseSkeletons = !!options.shouldParseSkeletons;
    }
    Parser.prototype.parse = function () {
        if (this.offset() !== 0) {
            throw Error('parser can only be used once');
        }
        return this.parseMessage(0, '', false);
    };
    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {
        var elements = [];
        while (!this.isEOF()) {
            var char = this.char();
            if (char === 123 /* `{` */) {
                var result = this.parseArgument(nestingLevel, expectingCloseTag);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            }
            else if (char === 125 /* `}` */ && nestingLevel > 0) {
                break;
            }
            else if (char === 35 /* `#` */ &&
                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {
                var position = this.clonePosition();
                this.bump();
                elements.push({
                    type: TYPE.pound,
                    location: createLocation(position, this.clonePosition()),
                });
            }
            else if (char === 60 /* `<` */ &&
                !this.ignoreTag &&
                this.peek() === 47 // char code for '/'
            ) {
                if (expectingCloseTag) {
                    break;
                }
                else {
                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
                }
            }
            else if (char === 60 /* `<` */ &&
                !this.ignoreTag &&
                _isAlpha(this.peek() || 0)) {
                var result = this.parseTag(nestingLevel, parentArgType);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            }
            else {
                var result = this.parseLiteral(nestingLevel, parentArgType);
                if (result.err) {
                    return result;
                }
                elements.push(result.val);
            }
        }
        return { val: elements, err: null };
    };
    /**
     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
     * are accepted:
     *
     * ```
     * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
     * tagName ::= [a-z] (PENChar)*
     * PENChar ::=
     *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
     * ```
     *
     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
     * since other tag-based engines like React allow it
     */
    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {
        var startPosition = this.clonePosition();
        this.bump(); // `<`
        var tagName = this.parseTagName();
        this.bumpSpace();
        if (this.bumpIf('/>')) {
            // Self closing tag
            return {
                val: {
                    type: TYPE.literal,
                    value: "<".concat(tagName, "/>"),
                    location: createLocation(startPosition, this.clonePosition()),
                },
                err: null,
            };
        }
        else if (this.bumpIf('>')) {
            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
            if (childrenResult.err) {
                return childrenResult;
            }
            var children = childrenResult.val;
            // Expecting a close tag
            var endTagStartPosition = this.clonePosition();
            if (this.bumpIf('</')) {
                if (this.isEOF() || !_isAlpha(this.char())) {
                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                }
                var closingTagNameStartPosition = this.clonePosition();
                var closingTagName = this.parseTagName();
                if (tagName !== closingTagName) {
                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
                }
                this.bumpSpace();
                if (!this.bumpIf('>')) {
                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                }
                return {
                    val: {
                        type: TYPE.tag,
                        value: tagName,
                        children: children,
                        location: createLocation(startPosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            else {
                return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
            }
        }
        else {
            return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
        }
    };
    /**
     * This method assumes that the caller has peeked ahead for the first tag character.
     */
    Parser.prototype.parseTagName = function () {
        var startOffset = this.offset();
        this.bump(); // the first tag name character
        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
            this.bump();
        }
        return this.message.slice(startOffset, this.offset());
    };
    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {
        var start = this.clonePosition();
        var value = '';
        while (true) {
            var parseQuoteResult = this.tryParseQuote(parentArgType);
            if (parseQuoteResult) {
                value += parseQuoteResult;
                continue;
            }
            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
            if (parseUnquotedResult) {
                value += parseUnquotedResult;
                continue;
            }
            var parseLeftAngleResult = this.tryParseLeftAngleBracket();
            if (parseLeftAngleResult) {
                value += parseLeftAngleResult;
                continue;
            }
            break;
        }
        var location = createLocation(start, this.clonePosition());
        return {
            val: { type: TYPE.literal, value: value, location: location },
            err: null,
        };
    };
    Parser.prototype.tryParseLeftAngleBracket = function () {
        if (!this.isEOF() &&
            this.char() === 60 /* `<` */ &&
            (this.ignoreTag ||
                // If at the opening tag or closing tag position, bail.
                !_isAlphaOrSlash(this.peek() || 0))) {
            this.bump(); // `<`
            return '<';
        }
        return null;
    };
    /**
     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
     * a character that requires quoting (that is, "only where needed"), and works the same in
     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
     */
    Parser.prototype.tryParseQuote = function (parentArgType) {
        if (this.isEOF() || this.char() !== 39 /* `'` */) {
            return null;
        }
        // Parse escaped char following the apostrophe, or early return if there is no escaped char.
        // Check if is valid escaped character
        switch (this.peek()) {
            case 39 /* `'` */:
                // double quote, should return as a single quote.
                this.bump();
                this.bump();
                return "'";
            // '{', '<', '>', '}'
            case 123:
            case 60:
            case 62:
            case 125:
                break;
            case 35: // '#'
                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {
                    break;
                }
                return null;
            default:
                return null;
        }
        this.bump(); // apostrophe
        var codePoints = [this.char()]; // escaped char
        this.bump();
        // read chars until the optional closing apostrophe is found
        while (!this.isEOF()) {
            var ch = this.char();
            if (ch === 39 /* `'` */) {
                if (this.peek() === 39 /* `'` */) {
                    codePoints.push(39);
                    // Bump one more time because we need to skip 2 characters.
                    this.bump();
                }
                else {
                    // Optional closing apostrophe.
                    this.bump();
                    break;
                }
            }
            else {
                codePoints.push(ch);
            }
            this.bump();
        }
        return fromCodePoint.apply(void 0, codePoints);
    };
    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {
        if (this.isEOF()) {
            return null;
        }
        var ch = this.char();
        if (ch === 60 /* `<` */ ||
            ch === 123 /* `{` */ ||
            (ch === 35 /* `#` */ &&
                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||
            (ch === 125 /* `}` */ && nestingLevel > 0)) {
            return null;
        }
        else {
            this.bump();
            return fromCodePoint(ch);
        }
    };
    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {
        var openingBracePosition = this.clonePosition();
        this.bump(); // `{`
        this.bumpSpace();
        if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        if (this.char() === 125 /* `}` */) {
            this.bump();
            return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
        // argument name
        var value = this.parseIdentifierIfPossible().value;
        if (!value) {
            return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
        this.bumpSpace();
        if (this.isEOF()) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        switch (this.char()) {
            // Simple argument: `{name}`
            case 125 /* `}` */: {
                this.bump(); // `}`
                return {
                    val: {
                        type: TYPE.argument,
                        // value does not include the opening and closing braces.
                        value: value,
                        location: createLocation(openingBracePosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            // Argument with options: `{name, format, ...}`
            case 44 /* `,` */: {
                this.bump(); // `,`
                this.bumpSpace();
                if (this.isEOF()) {
                    return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
                }
                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
            }
            default:
                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
        }
    };
    /**
     * Advance the parser until the end of the identifier, if it is currently on
     * an identifier character. Return an empty string otherwise.
     */
    Parser.prototype.parseIdentifierIfPossible = function () {
        var startingPosition = this.clonePosition();
        var startOffset = this.offset();
        var value = matchIdentifierAtIndex(this.message, startOffset);
        var endOffset = startOffset + value.length;
        this.bumpTo(endOffset);
        var endPosition = this.clonePosition();
        var location = createLocation(startingPosition, endPosition);
        return { value: value, location: location };
    };
    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {
        var _a;
        // Parse this range:
        // {name, type, style}
        //        ^---^
        var typeStartPosition = this.clonePosition();
        var argType = this.parseIdentifierIfPossible().value;
        var typeEndPosition = this.clonePosition();
        switch (argType) {
            case '':
                // Expecting a style string number, date, time, plural, selectordinal, or select.
                return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
            case 'number':
            case 'date':
            case 'time': {
                // Parse this range:
                // {name, number, style}
                //              ^-------^
                this.bumpSpace();
                var styleAndLocation = null;
                if (this.bumpIf(',')) {
                    this.bumpSpace();
                    var styleStartPosition = this.clonePosition();
                    var result = this.parseSimpleArgStyleIfPossible();
                    if (result.err) {
                        return result;
                    }
                    var style = trimEnd(result.val);
                    if (style.length === 0) {
                        return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());
                    styleAndLocation = { style: style, styleLocation: styleLocation };
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                var location_1 = createLocation(openingBracePosition, this.clonePosition());
                // Extract style or skeleton
                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {
                    // Skeleton starts with `::`.
                    var skeleton = trimStart(styleAndLocation.style.slice(2));
                    if (argType === 'number') {
                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
                        if (result.err) {
                            return result;
                        }
                        return {
                            val: { type: TYPE.number, value: value, location: location_1, style: result.val },
                            err: null,
                        };
                    }
                    else {
                        if (skeleton.length === 0) {
                            return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
                        }
                        var dateTimePattern = skeleton;
                        // Get "best match" pattern only if locale is passed, if not, let it
                        // pass as-is where `parseDateTimeSkeleton()` will throw an error
                        // for unsupported patterns.
                        if (this.locale) {
                            dateTimePattern = getBestPattern(skeleton, this.locale);
                        }
                        var style = {
                            type: SKELETON_TYPE.dateTime,
                            pattern: dateTimePattern,
                            location: styleAndLocation.styleLocation,
                            parsedOptions: this.shouldParseSkeletons
                                ? parseDateTimeSkeleton(dateTimePattern)
                                : {},
                        };
                        var type = argType === 'date' ? TYPE.date : TYPE.time;
                        return {
                            val: { type: type, value: value, location: location_1, style: style },
                            err: null,
                        };
                    }
                }
                // Regular style or no style.
                return {
                    val: {
                        type: argType === 'number'
                            ? TYPE.number
                            : argType === 'date'
                                ? TYPE.date
                                : TYPE.time,
                        value: value,
                        location: location_1,
                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,
                    },
                    err: null,
                };
            }
            case 'plural':
            case 'selectordinal':
            case 'select': {
                // Parse this range:
                // {name, plural, options}
                //              ^---------^
                var typeEndPosition_1 = this.clonePosition();
                this.bumpSpace();
                if (!this.bumpIf(',')) {
                    return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign$1({}, typeEndPosition_1)));
                }
                this.bumpSpace();
                // Parse offset:
                // {name, plural, offset:1, options}
                //                ^-----^
                //
                // or the first option:
                //
                // {name, plural, one {...} other {...}}
                //                ^--^
                var identifierAndLocation = this.parseIdentifierIfPossible();
                var pluralOffset = 0;
                if (argType !== 'select' && identifierAndLocation.value === 'offset') {
                    if (!this.bumpIf(':')) {
                        return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                    this.bumpSpace();
                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                    if (result.err) {
                        return result;
                    }
                    // Parse another identifier for option parsing
                    this.bumpSpace();
                    identifierAndLocation = this.parseIdentifierIfPossible();
                    pluralOffset = result.val;
                }
                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
                if (optionsResult.err) {
                    return optionsResult;
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                var location_2 = createLocation(openingBracePosition, this.clonePosition());
                if (argType === 'select') {
                    return {
                        val: {
                            type: TYPE.select,
                            value: value,
                            options: fromEntries(optionsResult.val),
                            location: location_2,
                        },
                        err: null,
                    };
                }
                else {
                    return {
                        val: {
                            type: TYPE.plural,
                            value: value,
                            options: fromEntries(optionsResult.val),
                            offset: pluralOffset,
                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',
                            location: location_2,
                        },
                        err: null,
                    };
                }
            }
            default:
                return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
        }
    };
    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {
        // Parse: {value, number, ::currency/GBP }
        //
        if (this.isEOF() || this.char() !== 125 /* `}` */) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        this.bump(); // `}`
        return { val: true, err: null };
    };
    /**
     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
     */
    Parser.prototype.parseSimpleArgStyleIfPossible = function () {
        var nestedBraces = 0;
        var startPosition = this.clonePosition();
        while (!this.isEOF()) {
            var ch = this.char();
            switch (ch) {
                case 39 /* `'` */: {
                    // Treat apostrophe as quoting but include it in the style part.
                    // Find the end of the quoted literal text.
                    this.bump();
                    var apostrophePosition = this.clonePosition();
                    if (!this.bumpUntil("'")) {
                        return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
                    }
                    this.bump();
                    break;
                }
                case 123 /* `{` */: {
                    nestedBraces += 1;
                    this.bump();
                    break;
                }
                case 125 /* `}` */: {
                    if (nestedBraces > 0) {
                        nestedBraces -= 1;
                    }
                    else {
                        return {
                            val: this.message.slice(startPosition.offset, this.offset()),
                            err: null,
                        };
                    }
                    break;
                }
                default:
                    this.bump();
                    break;
            }
        }
        return {
            val: this.message.slice(startPosition.offset, this.offset()),
            err: null,
        };
    };
    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {
        var tokens = [];
        try {
            tokens = parseNumberSkeletonFromString(skeleton);
        }
        catch (e) {
            return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
        }
        return {
            val: {
                type: SKELETON_TYPE.number,
                tokens: tokens,
                location: location,
                parsedOptions: this.shouldParseSkeletons
                    ? parseNumberSkeleton(tokens)
                    : {},
            },
            err: null,
        };
    };
    /**
     * @param nesting_level The current nesting level of messages.
     *     This can be positive when parsing message fragment in select or plural argument options.
     * @param parent_arg_type The parent argument's type.
     * @param parsed_first_identifier If provided, this is the first identifier-like selector of
     *     the argument. It is a by-product of a previous parsing attempt.
     * @param expecting_close_tag If true, this message is directly or indirectly nested inside
     *     between a pair of opening and closing tags. The nested message will not parse beyond
     *     the closing tag boundary.
     */
    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
        var _a;
        var hasOtherClause = false;
        var options = [];
        var parsedSelectors = new Set();
        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
        // Parse:
        // one {one apple}
        // ^--^
        while (true) {
            if (selector.length === 0) {
                var startPosition = this.clonePosition();
                if (parentArgType !== 'select' && this.bumpIf('=')) {
                    // Try parse `={number}` selector
                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
                    if (result.err) {
                        return result;
                    }
                    selectorLocation = createLocation(startPosition, this.clonePosition());
                    selector = this.message.slice(startPosition.offset, this.offset());
                }
                else {
                    break;
                }
            }
            // Duplicate selector clauses
            if (parsedSelectors.has(selector)) {
                return this.error(parentArgType === 'select'
                    ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR
                    : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
            }
            if (selector === 'other') {
                hasOtherClause = true;
            }
            // Parse:
            // one {one apple}
            //     ^----------^
            this.bumpSpace();
            var openingBracePosition = this.clonePosition();
            if (!this.bumpIf('{')) {
                return this.error(parentArgType === 'select'
                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
            }
            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
            if (fragmentResult.err) {
                return fragmentResult;
            }
            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
            if (argCloseResult.err) {
                return argCloseResult;
            }
            options.push([
                selector,
                {
                    value: fragmentResult.val,
                    location: createLocation(openingBracePosition, this.clonePosition()),
                },
            ]);
            // Keep track of the existing selectors
            parsedSelectors.add(selector);
            // Prep next selector clause.
            this.bumpSpace();
            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);
        }
        if (options.length === 0) {
            return this.error(parentArgType === 'select'
                ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR
                : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
        }
        if (this.requiresOtherClause && !hasOtherClause) {
            return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
        }
        return { val: options, err: null };
    };
    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {
        var sign = 1;
        var startingPosition = this.clonePosition();
        if (this.bumpIf('+')) ;
        else if (this.bumpIf('-')) {
            sign = -1;
        }
        var hasDigits = false;
        var decimal = 0;
        while (!this.isEOF()) {
            var ch = this.char();
            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {
                hasDigits = true;
                decimal = decimal * 10 + (ch - 48);
                this.bump();
            }
            else {
                break;
            }
        }
        var location = createLocation(startingPosition, this.clonePosition());
        if (!hasDigits) {
            return this.error(expectNumberError, location);
        }
        decimal *= sign;
        if (!isSafeInteger(decimal)) {
            return this.error(invalidNumberError, location);
        }
        return { val: decimal, err: null };
    };
    Parser.prototype.offset = function () {
        return this.position.offset;
    };
    Parser.prototype.isEOF = function () {
        return this.offset() === this.message.length;
    };
    Parser.prototype.clonePosition = function () {
        // This is much faster than `Object.assign` or spread.
        return {
            offset: this.position.offset,
            line: this.position.line,
            column: this.position.column,
        };
    };
    /**
     * Return the code point at the current position of the parser.
     * Throws if the index is out of bound.
     */
    Parser.prototype.char = function () {
        var offset = this.position.offset;
        if (offset >= this.message.length) {
            throw Error('out of bound');
        }
        var code = codePointAt(this.message, offset);
        if (code === undefined) {
            throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
        }
        return code;
    };
    Parser.prototype.error = function (kind, location) {
        return {
            val: null,
            err: {
                kind: kind,
                message: this.message,
                location: location,
            },
        };
    };
    /** Bump the parser to the next UTF-16 code unit. */
    Parser.prototype.bump = function () {
        if (this.isEOF()) {
            return;
        }
        var code = this.char();
        if (code === 10 /* '\n' */) {
            this.position.line += 1;
            this.position.column = 1;
            this.position.offset += 1;
        }
        else {
            this.position.column += 1;
            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.
            this.position.offset += code < 0x10000 ? 1 : 2;
        }
    };
    /**
     * If the substring starting at the current position of the parser has
     * the given prefix, then bump the parser to the character immediately
     * following the prefix and return true. Otherwise, don't bump the parser
     * and return false.
     */
    Parser.prototype.bumpIf = function (prefix) {
        if (startsWith(this.message, prefix, this.offset())) {
            for (var i = 0; i < prefix.length; i++) {
                this.bump();
            }
            return true;
        }
        return false;
    };
    /**
     * Bump the parser until the pattern character is found and return `true`.
     * Otherwise bump to the end of the file and return `false`.
     */
    Parser.prototype.bumpUntil = function (pattern) {
        var currentOffset = this.offset();
        var index = this.message.indexOf(pattern, currentOffset);
        if (index >= 0) {
            this.bumpTo(index);
            return true;
        }
        else {
            this.bumpTo(this.message.length);
            return false;
        }
    };
    /**
     * Bump the parser to the target offset.
     * If target offset is beyond the end of the input, bump the parser to the end of the input.
     */
    Parser.prototype.bumpTo = function (targetOffset) {
        if (this.offset() > targetOffset) {
            throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
        }
        targetOffset = Math.min(targetOffset, this.message.length);
        while (true) {
            var offset = this.offset();
            if (offset === targetOffset) {
                break;
            }
            if (offset > targetOffset) {
                throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
            }
            this.bump();
            if (this.isEOF()) {
                break;
            }
        }
    };
    /** advance the parser through all whitespace to the next non-whitespace code unit. */
    Parser.prototype.bumpSpace = function () {
        while (!this.isEOF() && _isWhiteSpace(this.char())) {
            this.bump();
        }
    };
    /**
     * Peek at the *next* Unicode codepoint in the input without advancing the parser.
     * If the input has been exhausted, then this returns null.
     */
    Parser.prototype.peek = function () {
        if (this.isEOF()) {
            return null;
        }
        var code = this.char();
        var offset = this.offset();
        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));
        return nextCode !== null && nextCode !== void 0 ? nextCode : null;
    };
    return Parser;
}());
/**
 * This check if codepoint is alphabet (lower & uppercase)
 * @param codepoint
 * @returns
 */
function _isAlpha(codepoint) {
    return ((codepoint >= 97 && codepoint <= 122) ||
        (codepoint >= 65 && codepoint <= 90));
}
function _isAlphaOrSlash(codepoint) {
    return _isAlpha(codepoint) || codepoint === 47; /* '/' */
}
/** See `parseTag` function docs. */
function _isPotentialElementNameChar(c) {
    return (c === 45 /* '-' */ ||
        c === 46 /* '.' */ ||
        (c >= 48 && c <= 57) /* 0..9 */ ||
        c === 95 /* '_' */ ||
        (c >= 97 && c <= 122) /** a..z */ ||
        (c >= 65 && c <= 90) /* A..Z */ ||
        c == 0xb7 ||
        (c >= 0xc0 && c <= 0xd6) ||
        (c >= 0xd8 && c <= 0xf6) ||
        (c >= 0xf8 && c <= 0x37d) ||
        (c >= 0x37f && c <= 0x1fff) ||
        (c >= 0x200c && c <= 0x200d) ||
        (c >= 0x203f && c <= 0x2040) ||
        (c >= 0x2070 && c <= 0x218f) ||
        (c >= 0x2c00 && c <= 0x2fef) ||
        (c >= 0x3001 && c <= 0xd7ff) ||
        (c >= 0xf900 && c <= 0xfdcf) ||
        (c >= 0xfdf0 && c <= 0xfffd) ||
        (c >= 0x10000 && c <= 0xeffff));
}
/**
 * Code point equivalent of regex `\p{White_Space}`.
 * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
 */
function _isWhiteSpace(c) {
    return ((c >= 0x0009 && c <= 0x000d) ||
        c === 0x0020 ||
        c === 0x0085 ||
        (c >= 0x200e && c <= 0x200f) ||
        c === 0x2028 ||
        c === 0x2029);
}
/**
 * Code point equivalent of regex `\p{Pattern_Syntax}`.
 * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
 */
function _isPatternSyntax(c) {
    return ((c >= 0x0021 && c <= 0x0023) ||
        c === 0x0024 ||
        (c >= 0x0025 && c <= 0x0027) ||
        c === 0x0028 ||
        c === 0x0029 ||
        c === 0x002a ||
        c === 0x002b ||
        c === 0x002c ||
        c === 0x002d ||
        (c >= 0x002e && c <= 0x002f) ||
        (c >= 0x003a && c <= 0x003b) ||
        (c >= 0x003c && c <= 0x003e) ||
        (c >= 0x003f && c <= 0x0040) ||
        c === 0x005b ||
        c === 0x005c ||
        c === 0x005d ||
        c === 0x005e ||
        c === 0x0060 ||
        c === 0x007b ||
        c === 0x007c ||
        c === 0x007d ||
        c === 0x007e ||
        c === 0x00a1 ||
        (c >= 0x00a2 && c <= 0x00a5) ||
        c === 0x00a6 ||
        c === 0x00a7 ||
        c === 0x00a9 ||
        c === 0x00ab ||
        c === 0x00ac ||
        c === 0x00ae ||
        c === 0x00b0 ||
        c === 0x00b1 ||
        c === 0x00b6 ||
        c === 0x00bb ||
        c === 0x00bf ||
        c === 0x00d7 ||
        c === 0x00f7 ||
        (c >= 0x2010 && c <= 0x2015) ||
        (c >= 0x2016 && c <= 0x2017) ||
        c === 0x2018 ||
        c === 0x2019 ||
        c === 0x201a ||
        (c >= 0x201b && c <= 0x201c) ||
        c === 0x201d ||
        c === 0x201e ||
        c === 0x201f ||
        (c >= 0x2020 && c <= 0x2027) ||
        (c >= 0x2030 && c <= 0x2038) ||
        c === 0x2039 ||
        c === 0x203a ||
        (c >= 0x203b && c <= 0x203e) ||
        (c >= 0x2041 && c <= 0x2043) ||
        c === 0x2044 ||
        c === 0x2045 ||
        c === 0x2046 ||
        (c >= 0x2047 && c <= 0x2051) ||
        c === 0x2052 ||
        c === 0x2053 ||
        (c >= 0x2055 && c <= 0x205e) ||
        (c >= 0x2190 && c <= 0x2194) ||
        (c >= 0x2195 && c <= 0x2199) ||
        (c >= 0x219a && c <= 0x219b) ||
        (c >= 0x219c && c <= 0x219f) ||
        c === 0x21a0 ||
        (c >= 0x21a1 && c <= 0x21a2) ||
        c === 0x21a3 ||
        (c >= 0x21a4 && c <= 0x21a5) ||
        c === 0x21a6 ||
        (c >= 0x21a7 && c <= 0x21ad) ||
        c === 0x21ae ||
        (c >= 0x21af && c <= 0x21cd) ||
        (c >= 0x21ce && c <= 0x21cf) ||
        (c >= 0x21d0 && c <= 0x21d1) ||
        c === 0x21d2 ||
        c === 0x21d3 ||
        c === 0x21d4 ||
        (c >= 0x21d5 && c <= 0x21f3) ||
        (c >= 0x21f4 && c <= 0x22ff) ||
        (c >= 0x2300 && c <= 0x2307) ||
        c === 0x2308 ||
        c === 0x2309 ||
        c === 0x230a ||
        c === 0x230b ||
        (c >= 0x230c && c <= 0x231f) ||
        (c >= 0x2320 && c <= 0x2321) ||
        (c >= 0x2322 && c <= 0x2328) ||
        c === 0x2329 ||
        c === 0x232a ||
        (c >= 0x232b && c <= 0x237b) ||
        c === 0x237c ||
        (c >= 0x237d && c <= 0x239a) ||
        (c >= 0x239b && c <= 0x23b3) ||
        (c >= 0x23b4 && c <= 0x23db) ||
        (c >= 0x23dc && c <= 0x23e1) ||
        (c >= 0x23e2 && c <= 0x2426) ||
        (c >= 0x2427 && c <= 0x243f) ||
        (c >= 0x2440 && c <= 0x244a) ||
        (c >= 0x244b && c <= 0x245f) ||
        (c >= 0x2500 && c <= 0x25b6) ||
        c === 0x25b7 ||
        (c >= 0x25b8 && c <= 0x25c0) ||
        c === 0x25c1 ||
        (c >= 0x25c2 && c <= 0x25f7) ||
        (c >= 0x25f8 && c <= 0x25ff) ||
        (c >= 0x2600 && c <= 0x266e) ||
        c === 0x266f ||
        (c >= 0x2670 && c <= 0x2767) ||
        c === 0x2768 ||
        c === 0x2769 ||
        c === 0x276a ||
        c === 0x276b ||
        c === 0x276c ||
        c === 0x276d ||
        c === 0x276e ||
        c === 0x276f ||
        c === 0x2770 ||
        c === 0x2771 ||
        c === 0x2772 ||
        c === 0x2773 ||
        c === 0x2774 ||
        c === 0x2775 ||
        (c >= 0x2794 && c <= 0x27bf) ||
        (c >= 0x27c0 && c <= 0x27c4) ||
        c === 0x27c5 ||
        c === 0x27c6 ||
        (c >= 0x27c7 && c <= 0x27e5) ||
        c === 0x27e6 ||
        c === 0x27e7 ||
        c === 0x27e8 ||
        c === 0x27e9 ||
        c === 0x27ea ||
        c === 0x27eb ||
        c === 0x27ec ||
        c === 0x27ed ||
        c === 0x27ee ||
        c === 0x27ef ||
        (c >= 0x27f0 && c <= 0x27ff) ||
        (c >= 0x2800 && c <= 0x28ff) ||
        (c >= 0x2900 && c <= 0x2982) ||
        c === 0x2983 ||
        c === 0x2984 ||
        c === 0x2985 ||
        c === 0x2986 ||
        c === 0x2987 ||
        c === 0x2988 ||
        c === 0x2989 ||
        c === 0x298a ||
        c === 0x298b ||
        c === 0x298c ||
        c === 0x298d ||
        c === 0x298e ||
        c === 0x298f ||
        c === 0x2990 ||
        c === 0x2991 ||
        c === 0x2992 ||
        c === 0x2993 ||
        c === 0x2994 ||
        c === 0x2995 ||
        c === 0x2996 ||
        c === 0x2997 ||
        c === 0x2998 ||
        (c >= 0x2999 && c <= 0x29d7) ||
        c === 0x29d8 ||
        c === 0x29d9 ||
        c === 0x29da ||
        c === 0x29db ||
        (c >= 0x29dc && c <= 0x29fb) ||
        c === 0x29fc ||
        c === 0x29fd ||
        (c >= 0x29fe && c <= 0x2aff) ||
        (c >= 0x2b00 && c <= 0x2b2f) ||
        (c >= 0x2b30 && c <= 0x2b44) ||
        (c >= 0x2b45 && c <= 0x2b46) ||
        (c >= 0x2b47 && c <= 0x2b4c) ||
        (c >= 0x2b4d && c <= 0x2b73) ||
        (c >= 0x2b74 && c <= 0x2b75) ||
        (c >= 0x2b76 && c <= 0x2b95) ||
        c === 0x2b96 ||
        (c >= 0x2b97 && c <= 0x2bff) ||
        (c >= 0x2e00 && c <= 0x2e01) ||
        c === 0x2e02 ||
        c === 0x2e03 ||
        c === 0x2e04 ||
        c === 0x2e05 ||
        (c >= 0x2e06 && c <= 0x2e08) ||
        c === 0x2e09 ||
        c === 0x2e0a ||
        c === 0x2e0b ||
        c === 0x2e0c ||
        c === 0x2e0d ||
        (c >= 0x2e0e && c <= 0x2e16) ||
        c === 0x2e17 ||
        (c >= 0x2e18 && c <= 0x2e19) ||
        c === 0x2e1a ||
        c === 0x2e1b ||
        c === 0x2e1c ||
        c === 0x2e1d ||
        (c >= 0x2e1e && c <= 0x2e1f) ||
        c === 0x2e20 ||
        c === 0x2e21 ||
        c === 0x2e22 ||
        c === 0x2e23 ||
        c === 0x2e24 ||
        c === 0x2e25 ||
        c === 0x2e26 ||
        c === 0x2e27 ||
        c === 0x2e28 ||
        c === 0x2e29 ||
        (c >= 0x2e2a && c <= 0x2e2e) ||
        c === 0x2e2f ||
        (c >= 0x2e30 && c <= 0x2e39) ||
        (c >= 0x2e3a && c <= 0x2e3b) ||
        (c >= 0x2e3c && c <= 0x2e3f) ||
        c === 0x2e40 ||
        c === 0x2e41 ||
        c === 0x2e42 ||
        (c >= 0x2e43 && c <= 0x2e4f) ||
        (c >= 0x2e50 && c <= 0x2e51) ||
        c === 0x2e52 ||
        (c >= 0x2e53 && c <= 0x2e7f) ||
        (c >= 0x3001 && c <= 0x3003) ||
        c === 0x3008 ||
        c === 0x3009 ||
        c === 0x300a ||
        c === 0x300b ||
        c === 0x300c ||
        c === 0x300d ||
        c === 0x300e ||
        c === 0x300f ||
        c === 0x3010 ||
        c === 0x3011 ||
        (c >= 0x3012 && c <= 0x3013) ||
        c === 0x3014 ||
        c === 0x3015 ||
        c === 0x3016 ||
        c === 0x3017 ||
        c === 0x3018 ||
        c === 0x3019 ||
        c === 0x301a ||
        c === 0x301b ||
        c === 0x301c ||
        c === 0x301d ||
        (c >= 0x301e && c <= 0x301f) ||
        c === 0x3020 ||
        c === 0x3030 ||
        c === 0xfd3e ||
        c === 0xfd3f ||
        (c >= 0xfe45 && c <= 0xfe46));
}

function pruneLocation(els) {
    els.forEach(function (el) {
        delete el.location;
        if (isSelectElement(el) || isPluralElement(el)) {
            for (var k in el.options) {
                delete el.options[k].location;
                pruneLocation(el.options[k].value);
            }
        }
        else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
            delete el.style.location;
        }
        else if ((isDateElement(el) || isTimeElement(el)) &&
            isDateTimeSkeleton(el.style)) {
            delete el.style.location;
        }
        else if (isTagElement(el)) {
            pruneLocation(el.children);
        }
    });
}
function parse(message, opts) {
    if (opts === void 0) { opts = {}; }
    opts = __assign$1({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
    var result = new Parser(message, opts).parse();
    if (result.err) {
        var error = SyntaxError(ErrorKind[result.err.kind]);
        // @ts-expect-error Assign to error object
        error.location = result.err.location;
        // @ts-expect-error Assign to error object
        error.originalMessage = result.err.message;
        throw error;
    }
    if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
        pruneLocation(result.val);
    }
    return result.val;
}

var ErrorCode;
(function (ErrorCode) {
    // When we have a placeholder but no value to format
    ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
    // When value supplied is invalid
    ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
    // When we need specific Intl API but it's not available
    ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = /** @class */ (function (_super) {
    __extends$1(FormatError, _super);
    function FormatError(msg, code, originalMessage) {
        var _this = _super.call(this, msg) || this;
        _this.code = code;
        _this.originalMessage = originalMessage;
        return _this;
    }
    FormatError.prototype.toString = function () {
        return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    };
    return FormatError;
}(Error));
var InvalidValueError = /** @class */ (function (_super) {
    __extends$1(InvalidValueError, _super);
    function InvalidValueError(variableId, value, options, originalMessage) {
        return _super.call(this, "Invalid values for \"".concat(variableId, "\": \"").concat(value, "\". Options are \"").concat(Object.keys(options).join('", "'), "\""), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueError;
}(FormatError));
var InvalidValueTypeError = /** @class */ (function (_super) {
    __extends$1(InvalidValueTypeError, _super);
    function InvalidValueTypeError(value, type, originalMessage) {
        return _super.call(this, "Value for \"".concat(value, "\" must be of type ").concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
    }
    return InvalidValueTypeError;
}(FormatError));
var MissingValueError = /** @class */ (function (_super) {
    __extends$1(MissingValueError, _super);
    function MissingValueError(variableId, originalMessage) {
        return _super.call(this, "The intl string context variable \"".concat(variableId, "\" was not provided to the string \"").concat(originalMessage, "\""), ErrorCode.MISSING_VALUE, originalMessage) || this;
    }
    return MissingValueError;
}(FormatError));

var PART_TYPE;
(function (PART_TYPE) {
    PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
    PART_TYPE[PART_TYPE["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
    if (parts.length < 2) {
        return parts;
    }
    return parts.reduce(function (all, part) {
        var lastPart = all[all.length - 1];
        if (!lastPart ||
            lastPart.type !== PART_TYPE.literal ||
            part.type !== PART_TYPE.literal) {
            all.push(part);
        }
        else {
            lastPart.value += part.value;
        }
        return all;
    }, []);
}
function isFormatXMLElementFn(el) {
    return typeof el === 'function';
}
// TODO(skeleton): add skeleton support
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
// For debugging
originalMessage) {
    // Hot path for straight simple msg translations
    if (els.length === 1 && isLiteralElement(els[0])) {
        return [
            {
                type: PART_TYPE.literal,
                value: els[0].value,
            },
        ];
    }
    var result = [];
    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
        var el = els_1[_i];
        // Exit early for string parts.
        if (isLiteralElement(el)) {
            result.push({
                type: PART_TYPE.literal,
                value: el.value,
            });
            continue;
        }
        // TODO: should this part be literal type?
        // Replace `#` in plural rules with the actual numeric value.
        if (isPoundElement(el)) {
            if (typeof currentPluralValue === 'number') {
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters.getNumberFormat(locales).format(currentPluralValue),
                });
            }
            continue;
        }
        var varName = el.value;
        // Enforce that all required values are provided by the caller.
        if (!(values && varName in values)) {
            throw new MissingValueError(varName, originalMessage);
        }
        var value = values[varName];
        if (isArgumentElement(el)) {
            if (!value || typeof value === 'string' || typeof value === 'number') {
                value =
                    typeof value === 'string' || typeof value === 'number'
                        ? String(value)
                        : '';
            }
            result.push({
                type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                value: value,
            });
            continue;
        }
        // Recursively format plural and select parts' option  which can be a
        // nested pattern structure. The choosing of the option to use is
        // abstracted-by and delegated-to the part helper object.
        if (isDateElement(el)) {
            var style = typeof el.style === 'string'
                ? formats.date[el.style]
                : isDateTimeSkeleton(el.style)
                    ? el.style.parsedOptions
                    : undefined;
            result.push({
                type: PART_TYPE.literal,
                value: formatters
                    .getDateTimeFormat(locales, style)
                    .format(value),
            });
            continue;
        }
        if (isTimeElement(el)) {
            var style = typeof el.style === 'string'
                ? formats.time[el.style]
                : isDateTimeSkeleton(el.style)
                    ? el.style.parsedOptions
                    : formats.time.medium;
            result.push({
                type: PART_TYPE.literal,
                value: formatters
                    .getDateTimeFormat(locales, style)
                    .format(value),
            });
            continue;
        }
        if (isNumberElement(el)) {
            var style = typeof el.style === 'string'
                ? formats.number[el.style]
                : isNumberSkeleton(el.style)
                    ? el.style.parsedOptions
                    : undefined;
            if (style && style.scale) {
                value =
                    value *
                        (style.scale || 1);
            }
            result.push({
                type: PART_TYPE.literal,
                value: formatters
                    .getNumberFormat(locales, style)
                    .format(value),
            });
            continue;
        }
        if (isTagElement(el)) {
            var children = el.children, value_1 = el.value;
            var formatFn = values[value_1];
            if (!isFormatXMLElementFn(formatFn)) {
                throw new InvalidValueTypeError(value_1, 'function', originalMessage);
            }
            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
            var chunks = formatFn(parts.map(function (p) { return p.value; }));
            if (!Array.isArray(chunks)) {
                chunks = [chunks];
            }
            result.push.apply(result, chunks.map(function (c) {
                return {
                    type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                    value: c,
                };
            }));
        }
        if (isSelectElement(el)) {
            var opt = el.options[value] || el.options.other;
            if (!opt) {
                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
            }
            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
            continue;
        }
        if (isPluralElement(el)) {
            var opt = el.options["=".concat(value)];
            if (!opt) {
                if (!Intl.PluralRules) {
                    throw new FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", ErrorCode.MISSING_INTL_API, originalMessage);
                }
                var rule = formatters
                    .getPluralRules(locales, { type: el.pluralType })
                    .select(value - (el.offset || 0));
                opt = el.options[rule] || el.options.other;
            }
            if (!opt) {
                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
            }
            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
            continue;
        }
    }
    return mergeLiteral(result);
}

/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/
// -- MessageFormat --------------------------------------------------------
function mergeConfig(c1, c2) {
    if (!c2) {
        return c1;
    }
    return __assign$1(__assign$1(__assign$1({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
        all[k] = __assign$1(__assign$1({}, c1[k]), (c2[k] || {}));
        return all;
    }, {}));
}
function mergeConfigs(defaultConfig, configs) {
    if (!configs) {
        return defaultConfig;
    }
    return Object.keys(defaultConfig).reduce(function (all, k) {
        all[k] = mergeConfig(defaultConfig[k], configs[k]);
        return all;
    }, __assign$1({}, defaultConfig));
}
function createFastMemoizeCache(store) {
    return {
        create: function () {
            return {
                get: function (key) {
                    return store[key];
                },
                set: function (key, value) {
                    store[key] = value;
                },
            };
        },
    };
}
function createDefaultFormatters(cache) {
    if (cache === void 0) { cache = {
        number: {},
        dateTime: {},
        pluralRules: {},
    }; }
    return {
        getNumberFormat: memoize(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.number),
            strategy: strategies.variadic,
        }),
        getDateTimeFormat: memoize(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.dateTime),
            strategy: strategies.variadic,
        }),
        getPluralRules: memoize(function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray([void 0], args, false)))();
        }, {
            cache: createFastMemoizeCache(cache.pluralRules),
            strategy: strategies.variadic,
        }),
    };
}
var IntlMessageFormat = /** @class */ (function () {
    function IntlMessageFormat(message, locales, overrideFormats, opts) {
        if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
        var _this = this;
        this.formatterCache = {
            number: {},
            dateTime: {},
            pluralRules: {},
        };
        this.format = function (values) {
            var parts = _this.formatToParts(values);
            // Hot path for straight simple msg translations
            if (parts.length === 1) {
                return parts[0].value;
            }
            var result = parts.reduce(function (all, part) {
                if (!all.length ||
                    part.type !== PART_TYPE.literal ||
                    typeof all[all.length - 1] !== 'string') {
                    all.push(part.value);
                }
                else {
                    all[all.length - 1] += part.value;
                }
                return all;
            }, []);
            if (result.length <= 1) {
                return result[0] || '';
            }
            return result;
        };
        this.formatToParts = function (values) {
            return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
        };
        this.resolvedOptions = function () {
            var _a;
            return ({
                locale: ((_a = _this.resolvedLocale) === null || _a === void 0 ? void 0 : _a.toString()) ||
                    Intl.NumberFormat.supportedLocalesOf(_this.locales)[0],
            });
        };
        this.getAst = function () { return _this.ast; };
        // Defined first because it's used to build the format pattern.
        this.locales = locales;
        this.resolvedLocale = IntlMessageFormat.resolveLocale(locales);
        if (typeof message === 'string') {
            this.message = message;
            if (!IntlMessageFormat.__parse) {
                throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
            }
            var _a = opts || {}; _a.formatters; var parseOpts = __rest(_a, ["formatters"]);
            // Parse string messages into an AST.
            this.ast = IntlMessageFormat.__parse(message, __assign$1(__assign$1({}, parseOpts), { locale: this.resolvedLocale }));
        }
        else {
            this.ast = message;
        }
        if (!Array.isArray(this.ast)) {
            throw new TypeError('A message must be provided as a String or AST.');
        }
        // Creates a new object with the specified `formats` merged with the default
        // formats.
        this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
        this.formatters =
            (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
    }
    Object.defineProperty(IntlMessageFormat, "defaultLocale", {
        get: function () {
            if (!IntlMessageFormat.memoizedDefaultLocale) {
                IntlMessageFormat.memoizedDefaultLocale =
                    new Intl.NumberFormat().resolvedOptions().locale;
            }
            return IntlMessageFormat.memoizedDefaultLocale;
        },
        enumerable: false,
        configurable: true
    });
    IntlMessageFormat.memoizedDefaultLocale = null;
    IntlMessageFormat.resolveLocale = function (locales) {
        if (typeof Intl.Locale === 'undefined') {
            return;
        }
        var supportedLocales = Intl.NumberFormat.supportedLocalesOf(locales);
        if (supportedLocales.length > 0) {
            return new Intl.Locale(supportedLocales[0]);
        }
        return new Intl.Locale(typeof locales === 'string' ? locales : locales[0]);
    };
    IntlMessageFormat.__parse = parse;
    // Default format options used as the prototype of the `formats` provided to the
    // constructor. These are used when constructing the internal Intl.NumberFormat
    // and Intl.DateTimeFormat instances.
    IntlMessageFormat.formats = {
        number: {
            integer: {
                maximumFractionDigits: 0,
            },
            currency: {
                style: 'currency',
            },
            percent: {
                style: 'percent',
            },
        },
        date: {
            short: {
                month: 'numeric',
                day: 'numeric',
                year: '2-digit',
            },
            medium: {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
            },
            long: {
                month: 'long',
                day: 'numeric',
                year: 'numeric',
            },
            full: {
                weekday: 'long',
                month: 'long',
                day: 'numeric',
                year: 'numeric',
            },
        },
        time: {
            short: {
                hour: 'numeric',
                minute: 'numeric',
            },
            medium: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
            },
            long: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short',
            },
            full: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short',
            },
        },
    };
    return IntlMessageFormat;
}());

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); return Constructor; }

function getDefaults() {
  return {
    memoize: true,
    memoizeFallback: false,
    bindI18n: '',
    bindI18nStore: '',
    parseErrorHandler: function parseErrorHandler(err, key, res, options) {
      return res;
    },
    parseLngForICU: function parseLngForICU(lng) {
      return lng;
    }
  };
}

var ICU = /*#__PURE__*/function () {
  function ICU(options) {
    _classCallCheck(this, ICU);

    this.type = 'i18nFormat';
    this.mem = {};
    this.init(null, options);
  }

  _createClass(ICU, [{
    key: "init",
    value: function init(i18next, options) {
      var _this = this;

      var i18nextOptions = i18next && i18next.options && i18next.options.i18nFormat || {};
      this.options = defaults(i18nextOptions, options, this.options || {}, getDefaults());
      this.formats = this.options.formats;

      if (i18next) {
        var _this$options = this.options,
            bindI18n = _this$options.bindI18n,
            bindI18nStore = _this$options.bindI18nStore,
            memoize = _this$options.memoize;
        i18next.IntlMessageFormat = IntlMessageFormat;
        i18next.ICU = this;

        if (memoize) {
          if (bindI18n) {
            i18next.on(bindI18n, function () {
              return _this.clearCache();
            });
          }

          if (bindI18nStore) {
            i18next.store.on(bindI18nStore, function () {
              return _this.clearCache();
            });
          }
        }
      }
    }
  }, {
    key: "addUserDefinedFormats",
    value: function addUserDefinedFormats(formats) {
      this.formats = this.formats ? _objectSpread(_objectSpread({}, this.formats), formats) : formats;
    }
  }, {
    key: "parse",
    value: function parse(res, options, lng, ns, key, info) {
      var hadSuccessfulLookup = info && info.resolved && info.resolved.res;
      var memKey = this.options.memoize && "".concat(lng, ".").concat(ns, ".").concat(key.replace(/\./g, '###'));
      var fc;

      if (this.options.memoize) {
        fc = getPath(this.mem, memKey);
      }

      try {
        if (!fc) {
          var transformedLng = this.options.parseLngForICU(lng); // without ignoreTag, react-i18next <Trans> translations with <0></0> placeholders
          // will fail to parse, as IntlMessageFormat expects them to be defined in the
          // options passed to fc.format() as { 0: (children) => string }
          // but the replacement of placeholders is done in react-i18next

          fc = new IntlMessageFormat(res, transformedLng, this.formats, {
            ignoreTag: true
          });
          if (this.options.memoize && (this.options.memoizeFallback || !info || hadSuccessfulLookup)) setPath(this.mem, memKey, fc);
        }

        return fc.format(options);
      } catch (err) {
        return this.options.parseErrorHandler(err, key, res, options);
      }
    }
  }, {
    key: "addLookupKeys",
    value: function addLookupKeys(finalKeys, _key, _code, _ns, _options) {
      // no additional keys needed for select or plural
      // so there is no need to add keys to that finalKeys array
      return finalKeys;
    }
  }, {
    key: "clearCache",
    value: function clearCache() {
      this.mem = {};
    }
  }]);

  return ICU;
}();

ICU.type = 'i18nFormat';

const jamf = "Jamf";
const jmf = "Jamf Micro Frontend Hub";
const yes = "yes";
const no = "no";
const cancel = "cancel";
const commonEnUS = {
  jamf,
  jmf,
  yes,
  no,
  cancel,
};

function createI18nInstance(loadResources, optionParam, initCallback) {
  const i18nInstance = instance.createInstance();
  const initOptions = typeof optionParam === "function" ? {} : optionParam;
  const callback = typeof optionParam === "function" ? optionParam : initCallback;
  const isDebug = ["sbox", "dev"].includes("prod");
  i18nInstance.use(ICU).use(resourcesToBackend(loadResources)).init(
    {
      fallbackLng: {
        en: ["en-US"],
        fr: ["fr-FR", "en-US"],
        nl: ["nl-NL", "en-US"],
        de: ["de-DE", "en-US"],
        ja: ["ja-JP", "en-US"],
        es: ["es-ES", "en-US"],
        zh: ["zh-TW", "en-US"],
        "zh-hant": ["zh-TW", "en-US"],
        default: ["en-US"]
      },
      supportedLngs: [
        "en",
        "fr",
        "nl",
        "de",
        "ja",
        "es",
        "zh",
        "en-US",
        "fr-FR",
        "nl-NL",
        "de-DE",
        "ja-JP",
        "es-ES",
        "zh-hant",
        "zh-TW"
      ],
      debug: isDebug,
      load: "currentOnly",
      resources: {
        "en-US": {
          common: commonEnUS
        }
      },
      ns: ["common"],
      defaultNS: "common",
      partialBundledLanguages: true,
      interpolation: {
        escapeValue: false
      },
      ...initOptions
    },
    callback
  );
  return i18nInstance;
}

const loadResources = (language, namespace) => {
  console.log(namespace);
  return __variableDynamicImportRuntimeHelper((/* #__PURE__ */ Object.assign({"../assets/locales/de-DE/app.json": () => __vitePreload(() => import('./app-BU3wc8lf.js'),true              ?[]:void 0,import.meta.url),"../assets/locales/en-US/app.json": () => __vitePreload(() => import('./app-CB3q1vKv.js'),true              ?[]:void 0,import.meta.url),"../assets/locales/es-ES/app.json": () => __vitePreload(() => import('./app-BESpF9SW.js'),true              ?[]:void 0,import.meta.url),"../assets/locales/fr-FR/app.json": () => __vitePreload(() => import('./app-Bo99ZjS5.js'),true              ?[]:void 0,import.meta.url),"../assets/locales/ja-JP/app.json": () => __vitePreload(() => import('./app-D32PcVxS.js'),true              ?[]:void 0,import.meta.url),"../assets/locales/nl-NL/app.json": () => __vitePreload(() => import('./app-DIsE0f6z.js'),true              ?[]:void 0,import.meta.url),"../assets/locales/zh-TW/app.json": () => __vitePreload(() => import('./app-DvxowMNY.js'),true              ?[]:void 0,import.meta.url)})), `../assets/locales/${language}/${namespace}.json`, 5);
};
function initializeI18n() {
  let resolve;
  const initPromise = new Promise((r) => {
    resolve = r;
  });
  return {
    i18next: createI18nInstance(loadResources, () => {
      resolve();
    }),
    i18nextInit: initPromise
  };
}

var define_process_env_default = {};
let listenerQueue$4 = [];
let lqIndex$4 = 0;
const QUEUE_ITEMS_PER_LISTENER$4 = 4;
let atom$4 = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex$4 + QUEUE_ITEMS_PER_LISTENER$4; i < listenerQueue$4.length; ) {
          if (listenerQueue$4[i] === listener) {
            listenerQueue$4.splice(i, QUEUE_ITEMS_PER_LISTENER$4);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER$4;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue$4.length;
      for (let listener of listeners) {
        listenerQueue$4.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex$4 = 0; lqIndex$4 < listenerQueue$4.length; lqIndex$4 += QUEUE_ITEMS_PER_LISTENER$4) {
          listenerQueue$4[lqIndex$4](
            listenerQueue$4[lqIndex$4 + 1],
            listenerQueue$4[lqIndex$4 + 2],
            listenerQueue$4[lqIndex$4 + 3]
          );
        }
        listenerQueue$4.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  return $atom;
};
const createTokenStore = () => atom$4("initial value");
const createIdentityStore = () => atom$4(void 0);
const createSsoEnabledStore = () => atom$4(false);
function disableSetOnConsumer(store, isConsumer) {
  return {
    ...store,
    set: isConsumer ? () => console.error("This method is only allowed on service provider, not consumer") : store.set
  };
}
const createAuthService = (logout) => {
  let integratorId;
  const sharedTokenStore = createTokenStore();
  const sharedIdentityStore = createIdentityStore();
  const sharedSsoEnabledStore = createSsoEnabledStore();
  const v1 = (consumerId) => {
    if (!integratorId) {
      integratorId = consumerId;
    }
    const isConsumer = consumerId !== integratorId;
    return {
      featureService: {
        tokenStore: disableSetOnConsumer(sharedTokenStore, isConsumer),
        identityStore: disableSetOnConsumer(sharedIdentityStore, isConsumer),
        ...logout,
        ssoEnabledStore: disableSetOnConsumer(sharedSsoEnabledStore, isConsumer)
      }
    };
  };
  return {
    id: "jamf:auth_service",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    create(_env) {
      return {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        "1.5.0": (consumerId, _consumerName) => v1(consumerId)
      };
    }
  };
};
const authService = createAuthService();
let listenerQueue$3 = [];
let lqIndex$3 = 0;
const QUEUE_ITEMS_PER_LISTENER$3 = 4;
let atom$3 = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex$3 + QUEUE_ITEMS_PER_LISTENER$3; i < listenerQueue$3.length; ) {
          if (listenerQueue$3[i] === listener) {
            listenerQueue$3.splice(i, QUEUE_ITEMS_PER_LISTENER$3);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER$3;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) ;
        }
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue$3.length;
      for (let listener of listeners) {
        listenerQueue$3.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex$3 = 0; lqIndex$3 < listenerQueue$3.length; lqIndex$3 += QUEUE_ITEMS_PER_LISTENER$3) {
          listenerQueue$3[lqIndex$3](
            listenerQueue$3[lqIndex$3 + 1],
            listenerQueue$3[lqIndex$3 + 2],
            listenerQueue$3[lqIndex$3 + 3]
          );
        }
        listenerQueue$3.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  return $atom;
};
const createBaseUrlStore = (initialBaseUrl) => atom$3(initialBaseUrl);
const createGatewayBaseUrlService = (initialBaseUrl) => {
  let intergratorId;
  const baseUrlStore = createBaseUrlStore(initialBaseUrl);
  const v1 = (consumerId) => {
    if (!intergratorId) {
      intergratorId = consumerId;
    }
    const isIntegrator = consumerId === intergratorId;
    const setBaseUrl = (baseUrl) => {
      if (!isIntegrator) {
        console.error("This method is only allowed on service provider, not consumer");
        return;
      }
      baseUrlStore.set(baseUrl);
    };
    const getBaseUrl = () => baseUrlStore.get();
    return {
      featureService: {
        setBaseUrl,
        getBaseUrl
      }
    };
  };
  return {
    id: "jamf:gateway_base_url_service",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    create(_env) {
      return {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        "1.0.0": (consumerId, _consumerName) => v1(consumerId)
      };
    }
  };
};
const GATEWAY_URL_STORAGE_KEY = "jamf:gatewayBaseUrl";
const gatewayBaseUrlService = createGatewayBaseUrlService(
  localStorage.getItem(GATEWAY_URL_STORAGE_KEY) ?? void 0
);
class GroupsServiceV1Class {
  _getComputersSmartGroups;
  constructor(getComputersSmartGroups) {
    this._getComputersSmartGroups = getComputersSmartGroups;
  }
  get getComputersSmartGroups() {
    if (!this._getComputersSmartGroups) {
      throw new Error("GroupsService.getComputersSmartGroups is not set");
    }
    return this._getComputersSmartGroups;
  }
  set getComputersSmartGroups(getComputersSmartGroups) {
    this._getComputersSmartGroups = getComputersSmartGroups;
  }
}
const GROUPS_SERVICE_ID = "jamf:groups_service";
function createGroupsService(getComputersSmartGroups, v2) {
  return {
    id: GROUPS_SERVICE_ID,
    create() {
      const groupsServiceV1 = new GroupsServiceV1Class(getComputersSmartGroups);
      const groupsServiceV2 = Object.freeze({
        ...v2
      });
      return {
        "1.0.0": function getGroupsServiceDeprecated() {
          return {
            featureService: groupsServiceV1
          };
        },
        "2.0.0": function getGroupsService() {
          return {
            featureService: groupsServiceV2
          };
        }
      };
    }
  };
}
const ddmrMockGroup = {
  groupName: "DDmR test scope",
  groupId: "groupA",
  isStaticGroup: true,
  type: "mobileDevice"
};
const jamfSchoolSmartGroupNames = ["School iOS 16", "School iPadOS 17"];
const jamfSchoolStaticGroups = ["Middle school", "High school"];
const jamfSchoolGroups = [
  ...jamfSchoolStaticGroups.map((groupName) => ({ groupName, isStaticGroup: true })),
  ...jamfSchoolSmartGroupNames.map((groupName) => ({ groupName, isStaticGroup: false }))
];
const additionalSmartGroupNames = ["iOS 16 devices", "Non-compliant iOS", "Up-to-date apps", "Inactive user devices"];
const additionalStaticGroupNames = ["Management devices", "UX dep", "Engineering", "Not assigned devices", "Damaged"];
const predefinedGroups = [
  {
    groupName: "All devices",
    groupId: "a3f7e8d2-4b9c-11ec-8d3d-0242ac130003",
    isStaticGroup: false,
    type: "computer"
  },
  {
    groupName: "All computers",
    groupId: "a4f7e8d2-4b9c-11ec-8d3d-0242ac130004",
    isStaticGroup: false,
    type: "computer"
  },
  {
    groupName: "US devices",
    groupId: "a5f7e8d2-4b9c-11ec-8d3d-0242ac130005",
    isStaticGroup: false,
    type: "computer"
  },
  {
    groupName: "EU devices",
    groupId: "a6f7e8d2-4b9c-11ec-8d3d-0242ac130006",
    isStaticGroup: false,
    type: "computer"
  },
  {
    groupName: "US computers",
    groupId: "a7f7e8d2-4b9c-11ec-8d3d-0242ac130007",
    isStaticGroup: false,
    type: "computer"
  }
];
const allGroups = [
  ...jamfSchoolGroups.map(
    (group, index) => ({
      ...group,
      // it needs to be a string so that it follows designed API by scoping engine
      // however, it needs to be a string containing only numbers so that it mirrors JSchool for now
      groupId: `${index}`,
      type: "mobileDevice"
    })
  ),
  ddmrMockGroup,
  ...predefinedGroups,
  ...additionalSmartGroupNames.map(
    (name) => ({
      groupName: name,
      groupId: name,
      isStaticGroup: false,
      type: "mobileDevice"
    })
  ),
  ...additionalStaticGroupNames.map(
    (name) => ({
      groupName: name,
      groupId: name,
      isStaticGroup: true,
      type: "mobileDevice"
    })
  )
];
function isStatic(group) {
  return group.isStaticGroup;
}
function isSmart(group) {
  return !group.isStaticGroup;
}
function byName(name) {
  if (!name) {
    return () => true;
  }
  const searchBy = name.toLowerCase();
  return (group) => group.groupName.toLowerCase().includes(searchBy);
}
function byType(type) {
  if (!type) {
    return () => true;
  }
  return (group) => group.type === type;
}
function getPagingParams(page, pageSize) {
  return [page * pageSize, (page + 1) * pageSize];
}
function buildResponse(isSmartPredicate, opts) {
  const filteredGroups = allGroups.filter(isSmartPredicate).filter(byType(opts.type)).filter(byName(opts.name));
  return {
    results: filteredGroups.slice(...getPagingParams(opts.page, opts.pageSize)),
    totalCount: filteredGroups.length
  };
}
const groupsService = createGroupsService(() => Promise.resolve(predefinedGroups), {
  getGroup(id) {
    return Promise.resolve(allGroups.find(({ groupId }) => groupId === id) ?? null);
  },
  getSmartGroups(opts) {
    return Promise.resolve(buildResponse(isSmart, opts));
  },
  getStaticGroups(opts) {
    return Promise.resolve(buildResponse(isStatic, opts));
  },
  getAllGroups(opts) {
    return Promise.resolve(buildResponse(() => true, opts));
  }
});
class RoutingServiceV1Class {
  _navigate;
  _remotePaths;
  constructor(navigate2, remotePaths) {
    this._navigate = navigate2;
    this._remotePaths = remotePaths ?? {
      COMPUTERS: "",
      SETTINGS_CATEGORIES: "",
      SETTINGS_COMPUTERS_EXTENSION_ATTRIBUTES: "",
      SETTINGS_COMPUTERS_SCRIPTS: "",
      SETTINGS_COMPUTERS_CONFIGURATION_PROFILES: "",
      SETTINGS_COMPUTERS_POLICIES: "",
      SETTINGS_COMPUTERS_SMART_GROUPS: ""
    };
  }
  getRoutingPath = (remoteId) => {
    const result = this._remotePaths[remoteId];
    if (!result) {
      throw new Error(`No routing path found for remoteId: ${remoteId}`);
    }
    return result;
  };
  get navigate() {
    if (!this._navigate) {
      throw new Error("RoutingService.navigate is not set");
    }
    return this._navigate;
  }
  set navigate(navigate2) {
    this._navigate = navigate2;
  }
}
const ROUTING_SERVICE_ID = "jamf:routing_service";
function createRoutingService(navigate2, remotePaths) {
  return {
    id: ROUTING_SERVICE_ID,
    create() {
      const routingServiceV1 = new RoutingServiceV1Class(navigate2, remotePaths);
      return {
        "1.1.0": function getRoutingService() {
          return {
            featureService: routingServiceV1
          };
        }
      };
    }
  };
}
const navigate = window.location.replace;
const routePaths = {
  "demo:angular": "/angular",
  "demo:angular:nested": "/angular/nested",
  "demo:vanilla": "/vanilla",
  "demo:vue": "/vue",
  "demo:vue:nested": "/vue/about",
  "demo:react": "/react",
  "demo:react:nested": "/react/nested",
  COMPUTERS: "/computers.html",
  SETTINGS_CATEGORIES: "/categories.html",
  SETTINGS_COMPUTERS_EXTENSION_ATTRIBUTES: "/view/settings/computer-management/computer-extension-attributes",
  SETTINGS_COMPUTERS_SCRIPTS: "/view/settings/computer-management/scripts",
  SETTINGS_COMPUTERS_CONFIGURATION_PROFILES: "/OSXConfigurationProfiles.html",
  SETTINGS_COMPUTERS_POLICIES: "/policies.html",
  SETTINGS_COMPUTERS_SMART_GROUPS: "/smartComputerGroups.html"
};
const routingService = createRoutingService(navigate, routePaths);
let listenerQueue$2 = [];
let lqIndex$2 = 0;
const QUEUE_ITEMS_PER_LISTENER$2 = 4;
let atom$2 = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex$2 + QUEUE_ITEMS_PER_LISTENER$2; i < listenerQueue$2.length; ) {
          if (listenerQueue$2[i] === listener) {
            listenerQueue$2.splice(i, QUEUE_ITEMS_PER_LISTENER$2);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER$2;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) ;
        }
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue$2.length;
      for (let listener of listeners) {
        listenerQueue$2.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex$2 = 0; lqIndex$2 < listenerQueue$2.length; lqIndex$2 += QUEUE_ITEMS_PER_LISTENER$2) {
          listenerQueue$2[lqIndex$2](
            listenerQueue$2[lqIndex$2 + 1],
            listenerQueue$2[lqIndex$2 + 2],
            listenerQueue$2[lqIndex$2 + 3]
          );
        }
        listenerQueue$2.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  return $atom;
};
const createTenantStore = () => atom$2(null);
const createTenantService = () => {
  let intergratorId;
  const rawTenantStore = createTenantStore();
  const v1 = (consumerId) => {
    if (!intergratorId) {
      intergratorId = consumerId;
    }
    const isIntegrator = consumerId === intergratorId;
    const tenantStore = {
      ...rawTenantStore,
      set: isIntegrator ? rawTenantStore.set : (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (_s) => console.error("This method is only allowed on service provider, not consumer")
      )
    };
    return {
      featureService: {
        tenantStore
      }
    };
  };
  return {
    id: "jamf:tenant_service",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    create(_env) {
      return {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        "1.0.0": (consumerId, _consumerName) => v1(consumerId)
      };
    }
  };
};
const tenantService = createTenantService();
let listenerQueue$1 = [];
let lqIndex$1 = 0;
const QUEUE_ITEMS_PER_LISTENER$1 = 4;
let atom$1 = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex$1 + QUEUE_ITEMS_PER_LISTENER$1; i < listenerQueue$1.length; ) {
          if (listenerQueue$1[i] === listener) {
            listenerQueue$1.splice(i, QUEUE_ITEMS_PER_LISTENER$1);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER$1;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) ;
        }
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue$1.length;
      for (let listener of listeners) {
        listenerQueue$1.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex$1 = 0; lqIndex$1 < listenerQueue$1.length; lqIndex$1 += QUEUE_ITEMS_PER_LISTENER$1) {
          listenerQueue$1[lqIndex$1](
            listenerQueue$1[lqIndex$1 + 1],
            listenerQueue$1[lqIndex$1 + 2],
            listenerQueue$1[lqIndex$1 + 3]
          );
        }
        listenerQueue$1.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  return $atom;
};
const createUserPreferencesStore = (userPreferences) => atom$1({ locale: "en-US" });
const createUserPreferencesService = (userPreferences) => {
  let intergratorId;
  const rawUserPreferencesStore = createUserPreferencesStore();
  const v1 = (consumerId) => {
    if (!intergratorId) {
      intergratorId = consumerId;
    }
    const isIntegrator = consumerId === intergratorId;
    const userPreferencesStore = {
      ...rawUserPreferencesStore,
      set: isIntegrator ? rawUserPreferencesStore.set : (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (_s) => console.error("This method is only allowed on service provider, not consumer")
      )
    };
    return {
      featureService: {
        userPreferencesStore
      }
    };
  };
  return {
    id: "jamf:user_preferences_service",
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    create(_env) {
      return {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        "1.0.0": (consumerId, _consumerName) => v1(consumerId)
      };
    }
  };
};
const userPreferencesService = createUserPreferencesService();
class AsyncValue {
  constructor(promise, value, error) {
    this.promise = promise;
    this.value = value;
    this.error = error;
    promise.then((val) => this.value = val).catch((err) => this.error = err);
  }
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
  if (hasRequiredLrucache) return lrucache;
  hasRequiredLrucache = 1;
  class LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key) {
      const value = this.map.get(key);
      if (value === void 0) {
        return void 0;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  lrucache = LRUCache;
  return lrucache;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions) return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
var re = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  const debug = typeof process === "object" && define_process_env_default && define_process_env_default.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug;
  return debug_1;
}
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe) return re.exports;
  hasRequiredRe = 1;
  (function(module, exports) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug = requireDebug();
    exports = module.exports = {};
    const re2 = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src = exports.src = [];
    const safeSrc = exports.safeSrc = [];
    const t = exports.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re, re.exports);
  return re.exports;
}
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers) return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
var semver;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver) return semver;
  hasRequiredSemver = 1;
  const debug = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re2, t } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re2[t.PRERELEASELOOSE] : re2[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver = SemVer;
  return semver;
}
var compare_1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare) return compare_1;
  hasRequiredCompare = 1;
  const SemVer = requireSemver();
  const compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  compare_1 = compare;
  return compare_1;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  const compare = requireCompare();
  const eq = (a, b, loose) => compare(a, b, loose) === 0;
  eq_1 = eq;
  return eq_1;
}
var neq_1;
var hasRequiredNeq;
function requireNeq() {
  if (hasRequiredNeq) return neq_1;
  hasRequiredNeq = 1;
  const compare = requireCompare();
  const neq = (a, b, loose) => compare(a, b, loose) !== 0;
  neq_1 = neq;
  return neq_1;
}
var gt_1;
var hasRequiredGt;
function requireGt() {
  if (hasRequiredGt) return gt_1;
  hasRequiredGt = 1;
  const compare = requireCompare();
  const gt = (a, b, loose) => compare(a, b, loose) > 0;
  gt_1 = gt;
  return gt_1;
}
var gte_1;
var hasRequiredGte;
function requireGte() {
  if (hasRequiredGte) return gte_1;
  hasRequiredGte = 1;
  const compare = requireCompare();
  const gte = (a, b, loose) => compare(a, b, loose) >= 0;
  gte_1 = gte;
  return gte_1;
}
var lt_1;
var hasRequiredLt;
function requireLt() {
  if (hasRequiredLt) return lt_1;
  hasRequiredLt = 1;
  const compare = requireCompare();
  const lt = (a, b, loose) => compare(a, b, loose) < 0;
  lt_1 = lt;
  return lt_1;
}
var lte_1;
var hasRequiredLte;
function requireLte() {
  if (hasRequiredLte) return lte_1;
  hasRequiredLte = 1;
  const compare = requireCompare();
  const lte = (a, b, loose) => compare(a, b, loose) <= 0;
  lte_1 = lte;
  return lte_1;
}
var cmp_1;
var hasRequiredCmp;
function requireCmp() {
  if (hasRequiredCmp) return cmp_1;
  hasRequiredCmp = 1;
  const eq = requireEq();
  const neq = requireNeq();
  const gt = requireGt();
  const gte = requireGte();
  const lt = requireLt();
  const lte = requireLte();
  const cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  cmp_1 = cmp;
  return cmp_1;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY = Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator;
  const parseOptions = requireParseOptions();
  const { safeRe: re2, t } = requireRe();
  const cmp = requireCmp();
  const debug = requireDebug();
  const SemVer = requireSemver();
  const Range = requireRange();
  return comparator;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range {
    constructor(range2, options) {
      options = parseOptions(options);
      if (range2 instanceof Range) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range2);
      range2 = range2.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range2);
      range2 = range2.replace(re2[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range2);
      range2 = range2.replace(re2[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range;
  const LRU = requireLrucache();
  const cache = new LRU();
  const parseOptions = requireParseOptions();
  const Comparator = requireComparator();
  const debug = requireDebug();
  const SemVer = requireSemver();
  const {
    safeRe: re2,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var satisfies_1;
var hasRequiredSatisfies;
function requireSatisfies() {
  if (hasRequiredSatisfies) return satisfies_1;
  hasRequiredSatisfies = 1;
  const Range = requireRange();
  const satisfies = (version, range2, options) => {
    try {
      range2 = new Range(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version);
  };
  satisfies_1 = satisfies;
  return satisfies_1;
}
var satisfiesExports = requireSatisfies();
const semverSatisfies = /* @__PURE__ */ getDefaultExportFromCjs(satisfiesExports);
var parse_1;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  const SemVer = requireSemver();
  const parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  parse_1 = parse;
  return parse_1;
}
var valid_1;
var hasRequiredValid;
function requireValid() {
  if (hasRequiredValid) return valid_1;
  hasRequiredValid = 1;
  const parse = requireParse();
  const valid = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
  };
  valid_1 = valid;
  return valid_1;
}
var validExports = requireValid();
const semverValid = /* @__PURE__ */ getDefaultExportFromCjs(validExports);
class ExternalsValidator {
  /**
   * @throws Throws an error if the provided externals contain an invalid
   * version.
   */
  constructor(providedExternals) {
    this.providedExternals = providedExternals;
    for (const [externalName, providedVersion] of Object.entries(providedExternals)) {
      if (!semverValid(providedVersion)) {
        throw new Error(`The provided version ${JSON.stringify(providedVersion)} for the external ${JSON.stringify(externalName)} is invalid.`);
      }
    }
  }
  /**
   * Validate that the required externals are provided in a compatible version.
   *
   * @throws Throws an error if the required externals can't be satisfied.
   */
  validate(requiredExternals, consumerId) {
    for (const [externalName, versionRange] of Object.entries(requiredExternals)) {
      const providedVersion = this.providedExternals[externalName];
      if (!providedVersion) {
        throw new Error(`The external dependency ${JSON.stringify(externalName)}${consumerId ? ` as required by ${JSON.stringify(consumerId)}` : ``} is not provided.`);
      }
      if (!semverSatisfies(providedVersion, versionRange)) {
        throw new Error(`The external dependency ${JSON.stringify(externalName)} ${consumerId ? `as required by ${JSON.stringify(consumerId)} in the` : `in the required`} version range ${JSON.stringify(versionRange)} is not satisfied. The provided version is ${JSON.stringify(providedVersion)}.`);
      }
    }
  }
}
function invalidFeatureAppModule(url, moduleType, moduleLoader) {
  let message = `The Feature App module at the url ${JSON.stringify(url)} ${moduleType ? `with the module type ${JSON.stringify(moduleType)}` : `with no specific module type`} is invalid. A Feature App module must have a Feature App definition as default export. A Feature App definition is an object with at least a \`create\` method.`;
  if (moduleLoader && moduleLoader.length > 1 && !moduleType) {
    message += " Hint: The provided module loader expects an optional second parameter `moduleType`. It might need to be provided for this Feature App.";
  }
  return message;
}
function isFeatureAppDefinition(maybeFeatureAppDefinition) {
  if (typeof maybeFeatureAppDefinition !== "object" || !maybeFeatureAppDefinition) {
    return false;
  }
  const featureAppDefinition = maybeFeatureAppDefinition;
  return typeof featureAppDefinition.create === "function";
}
function isFeatureAppModule(maybeFeatureAppModule) {
  if (typeof maybeFeatureAppModule !== "object" || !maybeFeatureAppModule) {
    return false;
  }
  return isFeatureAppDefinition(maybeFeatureAppModule.default);
}
class FeatureAppManager {
  constructor(featureServiceRegistry, options = {}) {
    this.featureServiceRegistry = featureServiceRegistry;
    this.options = options;
    this.asyncFeatureAppDefinitions = /* @__PURE__ */ new Map();
    this.featureAppDefinitionsWithRegisteredOwnFeatureServices = /* @__PURE__ */ new WeakSet();
    this.featureAppRetainers = /* @__PURE__ */ new Map();
    this.logger = options.logger || console;
  }
  /**
   * Load a [[FeatureAppDefinition]] using the module loader the
   * [[FeatureAppManager]] was initilized with.
   *
   * @throws Throws an error if no module loader was provided on initilization.
   *
   * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a module
   * format compatible with the module loader.
   *
   * @param moduleType The module type of the [[FeatureAppDefinition]] bundle.
   * This value can be used by the provided
   * [[FeatureAppManagerOptions.moduleLoader]].
   *
   * @returns An [[AsyncValue]] containing a promise that resolves with the
   * loaded [[FeatureAppDefinition]]. If called again with the same URL it
   * returns the same [[AsyncValue]]. The promise rejects when loading fails, or
   * when the loaded bundle doesn't export a [[FeatureAppDefinition]] as
   * default.
   */
  getAsyncFeatureAppDefinition(url, moduleType) {
    const key = `${url}${moduleType}`;
    let asyncFeatureAppDefinition = this.asyncFeatureAppDefinitions.get(key);
    if (!asyncFeatureAppDefinition) {
      asyncFeatureAppDefinition = this.createAsyncFeatureAppDefinition(url, moduleType);
      this.asyncFeatureAppDefinitions.set(key, asyncFeatureAppDefinition);
    }
    return asyncFeatureAppDefinition;
  }
  /**
   * Create a [[FeatureAppScope]] which includes validating externals, binding
   * all available Feature Service dependencies, and calling the `create` method
   * of the [[FeatureAppDefinition]].
   *
   * @throws Throws an error if Feature Services that the
   * [[FeatureAppDefinition]] provides with its `ownFeatureServices` key fail to
   * be registered.
   * @throws Throws an error if the required externals can't be satisfied.
   * @throws Throws an error if the required Feature Services can't be
   * satisfied.
   * @throws Throws an error the [[FeatureAppDefinition]]'s `create` method
   * throws.
   *
   * @param featureAppID The ID of the Feature App to create a scope for.
   * @param featureAppDefinition The definition of the Feature App to create a
   * scope for.
   *
   * @returns A [[FeatureAppScope]] for the provided Feature App ID and
   * [[FeatureAppDefinition]]. A new scope is created for every call of
   * `createFeatureAppScope`, even with the same ID and definiton.
   */
  createFeatureAppScope(featureAppId, featureAppDefinition, options = {}) {
    const featureAppRetainer = this.getFeatureAppRetainer(featureAppId, featureAppDefinition, options);
    let released = false;
    return {
      featureApp: featureAppRetainer.featureApp,
      release: () => {
        if (released) {
          this.logger.warn(`The Feature App with the ID ${JSON.stringify(featureAppId)} has already been released for this scope.`);
        } else {
          released = true;
          featureAppRetainer.release();
        }
      }
    };
  }
  /**
   * Preload a [[FeatureAppDefinition]] using the module loader the
   * [[FeatureAppManager]] was initilized with. Useful before hydration of a
   * server rendered page to avoid render result mismatch between client and
   * server due missing [[FeatureAppDefinition]]s.
   *
   * @throws Throws an error if no module loader was provided on initilization.
   *
   * @param url A URL pointing to a [[FeatureAppDefinition]] bundle in a module
   * format compatible with the module loader.
   *
   * @param moduleType The module type of the [[FeatureAppDefinition]] bundle.
   * This value can be used by the provided
   * [[FeatureAppManagerOptions.moduleLoader]].
   */
  async preloadFeatureApp(url, moduleType) {
    await this.getAsyncFeatureAppDefinition(url, moduleType).promise;
  }
  createAsyncFeatureAppDefinition(url, moduleType) {
    const { moduleLoader: loadModule } = this.options;
    if (!loadModule) {
      throw new Error("No module loader provided.");
    }
    return new AsyncValue(loadModule(url, moduleType).then((featureAppModule) => {
      if (!isFeatureAppModule(featureAppModule)) {
        throw new Error(invalidFeatureAppModule(url, moduleType, this.options.moduleLoader));
      }
      this.logger.info(`The Feature App module at the url ${JSON.stringify(url)} has been successfully loaded.`);
      return featureAppModule.default;
    }));
  }
  registerOwnFeatureServices(featureAppId, featureAppDefinition) {
    if (this.featureAppDefinitionsWithRegisteredOwnFeatureServices.has(featureAppDefinition)) {
      return;
    }
    if (featureAppDefinition.ownFeatureServiceDefinitions) {
      this.featureServiceRegistry.registerFeatureServices(featureAppDefinition.ownFeatureServiceDefinitions, featureAppId);
    }
    this.featureAppDefinitionsWithRegisteredOwnFeatureServices.add(featureAppDefinition);
  }
  getFeatureAppRetainer(featureAppId, featureAppDefinition, options) {
    let featureAppRetainer = this.featureAppRetainers.get(featureAppId);
    if (featureAppRetainer) {
      featureAppRetainer.retain();
    } else {
      this.registerOwnFeatureServices(featureAppId, featureAppDefinition);
      featureAppRetainer = this.createFeatureAppRetainer(featureAppDefinition, featureAppId, options);
    }
    return featureAppRetainer;
  }
  createFeatureAppRetainer(featureAppDefinition, featureAppId, options) {
    var _a, _b;
    this.validateExternals(featureAppDefinition, featureAppId);
    const { featureAppName, baseUrl, beforeCreate, config, done, parentFeatureApp } = options;
    const binding = this.featureServiceRegistry.bindFeatureServices(featureAppDefinition, featureAppId, featureAppName);
    try {
      (_b = (_a = this.options).onBind) === null || _b === void 0 ? void 0 : _b.call(_a, {
        featureAppDefinition,
        featureAppId,
        featureAppName,
        parentFeatureApp
      });
    } catch (error) {
      this.logger.error("Failed to execute onBind callback.", error);
    }
    const env = {
      baseUrl,
      config,
      featureAppId,
      featureAppName,
      featureServices: binding.featureServices,
      done
    };
    try {
      beforeCreate === null || beforeCreate === void 0 ? void 0 : beforeCreate(env);
      const featureApp = featureAppDefinition.create(env);
      this.logger.info(`The Feature App with the ID ${JSON.stringify(featureAppId)} has been successfully created.`);
      let retainCount = 1;
      const featureAppRetainer = {
        featureApp,
        retain: () => {
          retainCount += 1;
        },
        release: () => {
          retainCount -= 1;
          if (retainCount === 0) {
            this.featureAppRetainers.delete(featureAppId);
            binding.unbind();
          }
        }
      };
      this.featureAppRetainers.set(featureAppId, featureAppRetainer);
      return featureAppRetainer;
    } catch (error) {
      binding.unbind();
      throw error;
    }
  }
  validateExternals(featureAppDefinition, featureAppId) {
    const { externalsValidator } = this.options;
    if (!externalsValidator) {
      return;
    }
    const { dependencies } = featureAppDefinition;
    if (dependencies && dependencies.externals) {
      externalsValidator.validate(dependencies.externals, featureAppId);
    }
  }
}
var coerce_1;
var hasRequiredCoerce;
function requireCoerce() {
  if (hasRequiredCoerce) return coerce_1;
  hasRequiredCoerce = 1;
  const SemVer = requireSemver();
  const parse = requireParse();
  const { safeRe: re2, t } = requireRe();
  const coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  coerce_1 = coerce;
  return coerce_1;
}
var coerceExports = requireCoerce();
const semverCoerce = /* @__PURE__ */ getDefaultExportFromCjs(coerceExports);
function featureServiceUnsupported(optional, providerId, consumerId, versionRange, supportedVersions) {
  return `The ${optional ? "optional" : "required"} Feature Service ${JSON.stringify(providerId)} in the unsupported version range ${JSON.stringify(versionRange)} could not be bound to consumer ${JSON.stringify(consumerId)}. The supported versions are ${JSON.stringify(supportedVersions)}.`;
}
function featureServiceVersionInvalid(providerId, registrantId, version) {
  return `The Feature Service ${JSON.stringify(providerId)} could not be registered by registrant ${JSON.stringify(registrantId)} because it defines the invalid version ${JSON.stringify(version)}.`;
}
function featureServiceDependencyVersionInvalid(optional, providerId, consumerId) {
  return `The ${optional ? "optional" : "required"} Feature Service ${JSON.stringify(providerId)} in an invalid version could not be bound to consumer ${JSON.stringify(consumerId)}.`;
}
function featureServiceNotRegistered(optional, providerId, consumerId) {
  return `The ${optional ? "optional" : "required"} Feature Service ${JSON.stringify(providerId)} is not registered and therefore could not be bound to consumer ${JSON.stringify(consumerId)}.`;
}
function featureServiceReturnedUndefined(providerId, registrantId) {
  return `The Feature Service ${JSON.stringify(providerId)} could not be registered by registrant ${JSON.stringify(registrantId)} because it returned undefined.`;
}
function featureServiceSuccessfullyRegistered(providerId, registrantId) {
  return `The Feature Service ${JSON.stringify(providerId)} has been successfully registered by registrant ${JSON.stringify(registrantId)}.`;
}
function featureServiceAlreadyRegistered(providerId, registrantId) {
  return `The already registered Feature Service ${JSON.stringify(providerId)} could not be re-registered by registrant ${JSON.stringify(registrantId)}.`;
}
function featureServiceSuccessfullyBound(providerId, consumerId) {
  return `The required Feature Service ${JSON.stringify(providerId)} has been successfully bound to consumer ${JSON.stringify(consumerId)}.`;
}
function featureServicesAlreadyBound(consumerId) {
  return `All required Feature Services are already bound to consumer ${JSON.stringify(consumerId)}.`;
}
function featureServiceCouldNotBeUnbound(providerId, consumerId) {
  return `The required Feature Service ${JSON.stringify(providerId)} could not be unbound from consumer ${JSON.stringify(consumerId)}.`;
}
function featureServiceSuccessfullyUnbound(providerId, consumerId) {
  return `The required Feature Service ${JSON.stringify(providerId)} has been successfully unbound from consumer ${JSON.stringify(consumerId)}.`;
}
function featureServicesAlreadyUnbound(consumerId) {
  return `All required Feature Services are already unbound from consumer ${JSON.stringify(consumerId)}.`;
}
var toposort$1 = { exports: {} };
var hasRequiredToposort;
function requireToposort() {
  if (hasRequiredToposort) return toposort$1.exports;
  hasRequiredToposort = 1;
  toposort$1.exports = function(edges) {
    return toposort2(uniqueNodes(edges), edges);
  };
  toposort$1.exports.array = toposort2;
  function toposort2(nodes, edges) {
    var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
    edges.forEach(function(edge) {
      if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
        throw new Error("Unknown node. There is an unknown node in the supplied edges.");
      }
    });
    while (i--) {
      if (!visited[i]) visit(nodes[i], i, /* @__PURE__ */ new Set());
    }
    return sorted;
    function visit(node, i2, predecessors) {
      if (predecessors.has(node)) {
        var nodeRep;
        try {
          nodeRep = ", node was:" + JSON.stringify(node);
        } catch (e) {
          nodeRep = "";
        }
        throw new Error("Cyclic dependency" + nodeRep);
      }
      if (!nodesHash.has(node)) {
        throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
      }
      if (visited[i2]) return;
      visited[i2] = true;
      var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
      outgoing = Array.from(outgoing);
      if (i2 = outgoing.length) {
        predecessors.add(node);
        do {
          var child = outgoing[--i2];
          visit(child, nodesHash.get(child), predecessors);
        } while (i2);
        predecessors.delete(node);
      }
      sorted[--cursor] = node;
    }
  }
  function uniqueNodes(arr) {
    var res = /* @__PURE__ */ new Set();
    for (var i = 0, len = arr.length; i < len; i++) {
      var edge = arr[i];
      res.add(edge[0]);
      res.add(edge[1]);
    }
    return Array.from(res);
  }
  function makeOutgoingEdges(arr) {
    var edges = /* @__PURE__ */ new Map();
    for (var i = 0, len = arr.length; i < len; i++) {
      var edge = arr[i];
      if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
      if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
      edges.get(edge[0]).add(edge[1]);
    }
    return edges;
  }
  function makeNodesHash(arr) {
    var res = /* @__PURE__ */ new Map();
    for (var i = 0, len = arr.length; i < len; i++) {
      res.set(arr[i], i);
    }
    return res;
  }
  return toposort$1.exports;
}
var toposortExports = requireToposort();
const toposort = /* @__PURE__ */ getDefaultExportFromCjs(toposortExports);
function createTuple(first) {
  return (second) => [first, second];
}
function createDependencyEdges(dependentName, dependencies) {
  return Object.keys(dependencies).map(createTuple(dependentName));
}
function createAllDependencyEdges(dependencyGraph) {
  return Array.from(dependencyGraph.keys()).reduce((allDependencyEdges, dependencyName) => {
    const dependencies = dependencyGraph.get(dependencyName);
    if (!dependencies) {
      return allDependencyEdges;
    }
    const dependencyEdges = createDependencyEdges(dependencyName, dependencies);
    return [...allDependencyEdges, ...dependencyEdges];
  }, []);
}
function toposortDependencies(dependencyGraph) {
  const dependencyNames = Array.from(dependencyGraph.keys());
  const dependencyEdges = createAllDependencyEdges(dependencyGraph);
  const sortedDependencyNames = toposort(dependencyEdges);
  sortedDependencyNames.push(...dependencyNames.filter((dependencyName) => dependencyGraph.has(dependencyName) && sortedDependencyNames.indexOf(dependencyName) === -1));
  return sortedDependencyNames.reverse();
}
function mergeFeatureServiceDependencies({ dependencies, optionalDependencies }) {
  return Object.assign(Object.assign({}, dependencies && dependencies.featureServices), optionalDependencies && optionalDependencies.featureServices);
}
function createDependencyGraph(definitions) {
  const dependencyGraph = /* @__PURE__ */ new Map();
  for (const definition of definitions) {
    dependencyGraph.set(definition.id, mergeFeatureServiceDependencies(definition));
  }
  return dependencyGraph;
}
function isOptionalFeatureServiceDependency({ optionalDependencies }, providerId) {
  return Boolean(optionalDependencies && optionalDependencies.featureServices && optionalDependencies.featureServices.hasOwnProperty(providerId));
}
function createProviderDefinitionsById(definitions) {
  const providerDefinitionsById = /* @__PURE__ */ new Map();
  for (const definition of definitions) {
    providerDefinitionsById.set(definition.id, definition);
  }
  return providerDefinitionsById;
}
class FeatureServiceRegistry {
  constructor(options = {}) {
    this.options = options;
    this.sharedFeatureServices = /* @__PURE__ */ new Map();
    this.consumerIds = /* @__PURE__ */ new Set();
    this.logger = options.logger || console;
  }
  /**
   * Register a set of Feature Services to make them available for binding to
   * dependent consumers.
   *
   * @throws Throws an error if the dependencies of one of the provider
   * definitions can't be fulfilled.
   * @throws Throws an error if one of the registered Feature Services contains
   * an invalid version according to semver notation.
   *
   * @param providerDefinitions Feature Services that should be registered. A
   * Feature Service and its dependencies must either be registered together, or
   * the dependencies must have already been registered. It is not possible to
   * provide dependencies later. Sorting the provided definitions is not
   * necessary, since the registry takes care of registering the given
   * definitions in the correct order.
   * @param registrantId The ID of the entity that registers the provider
   * definitions.
   */
  registerFeatureServices(providerDefinitions, registrantId) {
    const providerDefinitionsById = createProviderDefinitionsById(providerDefinitions);
    const dependencyGraph = createDependencyGraph(providerDefinitions);
    for (const providerId of toposortDependencies(dependencyGraph)) {
      this.registerFeatureService(providerDefinitionsById, providerId, registrantId);
    }
  }
  /**
   * Bind all dependencies to a consumer.
   *
   * @throws Throws an error if non-optional dependencies can't be fulfilled.
   * @throws Throws an error if called with the same consumer ID more than once.
   *
   * @param consumerDefinition The definition of the consumer to which
   * dependencies should be bound.
   * @param consumerId The ID of the consumer to which dependencies should be
   * bound.
   * @param consumerName The name of the consumer to which dependencies should be
   * bound.
   */
  bindFeatureServices(consumerDefinition, consumerId, consumerName) {
    if (this.consumerIds.has(consumerId)) {
      throw new Error(featureServicesAlreadyBound(consumerId));
    }
    const bindings = /* @__PURE__ */ new Map();
    const featureServices = /* @__PURE__ */ Object.create(null);
    const allDependencies = mergeFeatureServiceDependencies(consumerDefinition);
    for (const providerId of Object.keys(allDependencies)) {
      const optional = isOptionalFeatureServiceDependency(consumerDefinition, providerId);
      const versionRange = allDependencies[providerId];
      const binding = this.bindFeatureService(providerId, consumerId, consumerName, versionRange, { optional });
      if (!binding) {
        continue;
      }
      this.logger.info(featureServiceSuccessfullyBound(providerId, consumerId));
      bindings.set(providerId, binding);
      featureServices[providerId] = binding.featureService;
    }
    this.consumerIds.add(consumerId);
    let unbound = false;
    const unbind = () => {
      if (unbound) {
        throw new Error(featureServicesAlreadyUnbound(consumerId));
      }
      unbound = true;
      this.consumerIds.delete(consumerId);
      for (const [providerId, binding] of bindings.entries()) {
        try {
          if (binding.unbind) {
            binding.unbind();
          }
          this.logger.info(featureServiceSuccessfullyUnbound(providerId, consumerId));
        } catch (error) {
          this.logger.error(featureServiceCouldNotBeUnbound(providerId, consumerId), error);
        }
      }
    };
    return { featureServices, unbind };
  }
  /**
   * Returns info about consumers and registered feature services.
   */
  getInfo() {
    return {
      consumerIds: Array.from(this.consumerIds),
      featureServices: [...this.sharedFeatureServices.entries()].map(([id, sharedFeatureService]) => ({
        id,
        versions: Object.keys(sharedFeatureService)
      }))
    };
  }
  registerFeatureService(providerDefinitionsById, providerId, registrantId) {
    const providerDefinition = providerDefinitionsById.get(providerId);
    if (!providerDefinition) {
      return;
    }
    if (this.sharedFeatureServices.has(providerId)) {
      this.logger.warn(featureServiceAlreadyRegistered(providerId, registrantId));
      return;
    }
    this.validateExternals(providerDefinition, providerId);
    const { featureServices } = this.bindFeatureServices(providerDefinition, providerId);
    const sharedFeatureService = providerDefinition.create({ featureServices });
    if (sharedFeatureService) {
      this.validateFeatureServiceVersions(sharedFeatureService, providerId, registrantId);
      this.sharedFeatureServices.set(providerId, sharedFeatureService);
      this.logger.info(featureServiceSuccessfullyRegistered(providerId, registrantId));
    } else {
      this.logger.info(featureServiceReturnedUndefined(providerId, registrantId));
    }
  }
  bindFeatureService(providerId, consumerId, consumerName, versionRange, { optional }) {
    const coercedVersion = versionRange && semverCoerce(versionRange);
    if (!coercedVersion) {
      const message = featureServiceDependencyVersionInvalid(optional, providerId, consumerId);
      if (optional) {
        this.logger.info(message);
        return;
      }
      throw new Error(message);
    }
    const caretRange = `^${coercedVersion.version}`;
    const sharedFeatureService = this.sharedFeatureServices.get(providerId);
    if (!sharedFeatureService) {
      const message = featureServiceNotRegistered(optional, providerId, consumerId);
      if (optional) {
        this.logger.info(message);
        return;
      }
      throw new Error(message);
    }
    const supportedVersions = Object.keys(sharedFeatureService);
    const version = supportedVersions.find((supportedVersion) => semverSatisfies(supportedVersion, caretRange));
    const bindFeatureService = version ? sharedFeatureService[version] : void 0;
    if (!bindFeatureService) {
      const message = featureServiceUnsupported(optional, providerId, consumerId, caretRange, supportedVersions);
      if (optional) {
        this.logger.info(message);
        return;
      }
      throw new Error(message);
    }
    return bindFeatureService(consumerId, consumerName);
  }
  validateExternals(consumerDefinition, consumerId) {
    const { externalsValidator } = this.options;
    if (!externalsValidator) {
      return;
    }
    const { dependencies } = consumerDefinition;
    if (dependencies && dependencies.externals) {
      externalsValidator.validate(dependencies.externals, consumerId);
    }
  }
  validateFeatureServiceVersions(sharedFeatureService, providerId, registrantId) {
    for (const version of Object.keys(sharedFeatureService)) {
      if (!semverValid(version)) {
        throw new Error(featureServiceVersionInvalid(providerId, registrantId, version));
      }
    }
  }
}
function createFeatureHub(integratorId, options = {}) {
  const { featureServiceDefinitions, featureServiceDependencies, providedExternals, moduleLoader, logger, onBind } = options;
  let externalsValidator;
  if (providedExternals) {
    externalsValidator = new ExternalsValidator(providedExternals);
  }
  const featureServiceRegistry = new FeatureServiceRegistry({
    externalsValidator,
    logger
  });
  const integratorDefinition = {
    dependencies: { featureServices: featureServiceDependencies }
  };
  if (featureServiceDefinitions) {
    featureServiceRegistry.registerFeatureServices(featureServiceDefinitions, integratorId);
  }
  const featureAppManager = new FeatureAppManager(featureServiceRegistry, {
    externalsValidator,
    moduleLoader,
    logger,
    onBind
  });
  const { featureServices } = featureServiceRegistry.bindFeatureServices(integratorDefinition, integratorId);
  return { featureAppManager, featureServiceRegistry, featureServices };
}
const sampleTenant = {
  tenantId: "d464a122-8dbb-44cb-af14-2f39270eb1e4",
  hostType: "protect",
  hostVersion: "1.10",
  environmentType: "sbox",
  organizationId: "2cb6890a-8ab0-4a3d-b472-e829eceeca70",
  environmentId: "3fa85f64-5717-4562-b3fc-2c963f66afa6"
};
const createFeatureHubProviderService = (featureHub) => {
  return {
    id: "jamf:feature_hub_provider_service",
    create() {
      return {
        "1.0.0"() {
          return {
            featureService: {
              getFeatureHub() {
                return featureHub;
              }
            }
          };
        }
      };
    }
  };
};
const APPS_SERVICE_ID = "jamf:app_store_and_in_house_apps_service";
function createAppsService({
  searchApps,
  loadApps,
  saveApp
}) {
  return {
    id: APPS_SERVICE_ID,
    create() {
      return {
        "1.0.0": function getAppsService() {
          return {
            featureService: {
              searchApps,
              loadApps,
              saveApp
            }
          };
        }
      };
    }
  };
}
const predefinedApps = [
  {
    appName: "Game Center",
    bundleID: "com.apple.gamecenter"
  },
  {
    appName: "Computers",
    bundleID: "com.apple.TVHomeSharing"
  },
  {
    appName: "Notes",
    bundleID: "com.apple.mobilenotes"
  },
  {
    appName: "X",
    bundleID: "com.atebits.Tweetie2"
  },
  {
    appName: "Telegram Messenger",
    bundleID: "ph.telegra.Telegraph"
  },
  {
    appName: "Facebook",
    bundleID: "com.facebook.Facebook"
  },
  {
    appName: "White Noise Deep Sleep Sounds",
    bundleID: "com.kitefaster.MagicBabySleeperFree"
  },
  {
    appName: "TikTok",
    bundleID: "com.zhiliaoapp.musically"
  },
  {
    appName: "Crunchyroll",
    bundleID: "com.crunchyroll.iphone"
  },
  {
    appName: "Instagram",
    bundleID: "com.burbn.instagram"
  },
  {
    appName: "NordVPN: VPN Fast & Secure",
    bundleID: "com.nordvpn.NordVPN"
  },
  {
    appName: "ExpressVPN: Fast & Secure VPN",
    bundleID: "com.expressvpn.iosvpn"
  },
  {
    appName: "Smule: Sing & Record Karaoke",
    bundleID: "com.smule.sing"
  },
  {
    appName: "YouTube: Watch, Listen, Stream",
    bundleID: "com.google.ios.youtube"
  },
  {
    appName: "Truth or Dare **",
    bundleID: "com.couplegame.truthordare"
  }
];
const appsService = createAppsService({
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  searchApps(appName, _osType) {
    return Promise.resolve(
      predefinedApps.filter((app) => {
        return app.appName.toLowerCase().includes(appName.toLowerCase());
      }) || []
    );
  },
  loadApps(bundleIDs) {
    return Promise.resolve(
      bundleIDs.map((bundleID) => {
        return predefinedApps.find((app) => app.bundleID === bundleID) || { appName: "", bundleID };
      }) || []
    );
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  saveApp(_app) {
    return Promise.resolve();
  }
});
const PERMISSIONS_SERVICE_ID = "jamf:permissions_service";
function createPermissionsService(getPermissions) {
  return {
    id: PERMISSIONS_SERVICE_ID,
    create() {
      return {
        "1.0.0": function v1() {
          return {
            featureService: {
              getPermissions
            }
          };
        }
      };
    }
  };
}
const permissions = {
  "compliance-benchmarks": {
    create: true,
    read: true,
    update: true,
    delete: true
  },
  blueprints: {
    create: true,
    read: true,
    update: true,
    delete: true
  }
};
const permissionsService = createPermissionsService(() => Promise.resolve(permissions));
function createNavPreventionServiceV1(showNavPreventionModal) {
  let isFormDirty = false;
  let isModalOpen = false;
  function showNavPreventionModalInternal() {
    isModalOpen = true;
    return showNavPreventionModal().then((result) => {
      isModalOpen = false;
      if (result) {
        isFormDirty = false;
      }
      return result;
    });
  }
  function getIsFormDirty() {
    return isFormDirty;
  }
  function setIsFormDirty(dirty) {
    isFormDirty = dirty;
  }
  function getIsModalOpen() {
    return isModalOpen;
  }
  return {
    showNavPreventionModal: showNavPreventionModalInternal,
    getIsFormDirty,
    setIsFormDirty,
    getIsModalOpen
  };
}
const NAV_PREVENTION_SERVICE_ID = "jamf:nav_prevention_service";
function createNavPreventionService(showNavPreventionModal) {
  const navPreventionServiceV1 = createNavPreventionServiceV1(showNavPreventionModal);
  return {
    id: NAV_PREVENTION_SERVICE_ID,
    create() {
      return {
        "1.0.0": function v1() {
          return {
            featureService: navPreventionServiceV1
          };
        }
      };
    }
  };
}
const navPreventionService = createNavPreventionService(
  () => new Promise((resolve) => {
    const result = window.confirm("Are you sure you want to leave?");
    resolve(result);
  })
);
const ANALYTICS_SERVICE_ID = "jamf:analytics_service";
function createAnalyticsService(track, isReady) {
  return {
    id: ANALYTICS_SERVICE_ID,
    create() {
      return {
        "1.0.0": function v1() {
          return {
            featureService: {
              track,
              isReady
            }
          };
        }
      };
    }
  };
}
const analyticsService = createAnalyticsService(
  (...args) => {
    console.log("mockedAnalyticsServiceEvent", "color: green", ...args);
  },
  () => {
    return Promise.resolve(true);
  }
);
let listenerQueue = [];
let lqIndex = 0;
const QUEUE_ITEMS_PER_LISTENER = 4;
let atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(
          listener,
          $atom.value,
          oldValue,
          changedKey
        );
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  return $atom;
};
const createAiReadyStore = () => atom(false);
const createAiAllowedStore = () => atom(false);
const createAiMessageStore = () => atom({
  key: "",
  content: "",
  context: ""
});
const AI_SERVICE_ID = "jamf:ai_service";
function createAiService() {
  const sharedAiReadyStore = createAiReadyStore();
  const sharedAiAllowedStore = createAiAllowedStore();
  const sharedAiMessageStore = createAiMessageStore();
  return {
    id: AI_SERVICE_ID,
    create(_env) {
      return {
        "1.0.0": function() {
          return {
            featureService: {
              aiReadyStore: sharedAiReadyStore,
              aiAllowedStore: sharedAiAllowedStore,
              aiMessageStore: sharedAiMessageStore
            }
          };
        }
      };
    }
  };
}
const aiService = createAiService();
const AUTH_TOKEN_CHANGED_EVENT = "authTokenChanged";
const initialize = (featureHub, integratorId, shouldCreateFeatureHubService) => {
  const { featureServices } = featureHub;
  if (authService.id in featureServices) {
    const { tokenStore, identityStore, ssoEnabledStore } = featureServices[authService.id];
    tokenStore.set("sample token");
    window.addEventListener(AUTH_TOKEN_CHANGED_EVENT, (event) => {
      const { token } = event.detail;
      tokenStore.set(token);
    });
    identityStore.set({
      name: "Jane Doe",
      email: "jane@example.com"
    });
    ssoEnabledStore.set(true);
  }
  if (tenantService.id in featureServices) {
    featureServices[tenantService.id].tenantStore.set(sampleTenant);
  }
  if (aiService.id in featureServices) {
    featureServices[aiService.id].aiReadyStore.set(true);
    featureServices[aiService.id].aiAllowedStore.set(true);
  }
  if (shouldCreateFeatureHubService) {
    const featureHubProviderService = createFeatureHubProviderService(featureHub);
    featureHub.featureServiceRegistry.registerFeatureServices([featureHubProviderService], integratorId);
  }
  return featureServices;
};
const mockServices = (requiredServices) => {
  const integratorId = "libs:mock-services";
  const shouldCreateFeatureHubService = Boolean(requiredServices["jamf:feature_hub_provider_service"]);
  if (shouldCreateFeatureHubService) {
    delete requiredServices["jamf:feature_hub_provider_service"];
  }
  const featureHub = createFeatureHub(integratorId, {
    featureServiceDefinitions: [
      authService,
      tenantService,
      routingService,
      groupsService,
      userPreferencesService,
      appsService,
      analyticsService,
      aiService,
      {
        id: "jamfdemo:add_group",
        create() {
          return {
            "1.0.0": () => ({
              featureService: {
                addGroup: () => {
                  return new Promise((resolve) => {
                    resolve("new group id");
                  });
                }
              }
            })
          };
        }
      },
      gatewayBaseUrlService,
      permissionsService,
      navPreventionService
    ],
    featureServiceDependencies: requiredServices
  });
  const mockedFeatureServices = initialize(
    featureHub,
    integratorId,
    shouldCreateFeatureHubService
  );
  console.log("Mocked featureServices: ", mockedFeatureServices);
  return mockedFeatureServices;
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
"function"==typeof SuppressedError&&SuppressedError;var t$6="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function i$3(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function o$6(e,t){return e(t={exports:{}},t.exports),t.exports}var n$6=o$6((function(e,t){Object.defineProperty(t,"__esModule",{value:true});var i=function(){function e(){var e=this;this.locked=new Map,this.addToLocked=function(t,i){var o=e.locked.get(t);void 0===o?void 0===i?e.locked.set(t,[]):e.locked.set(t,[i]):void 0!==i&&(o.unshift(i),e.locked.set(t,o));},this.isLocked=function(t){return e.locked.has(t)},this.lock=function(t){return new Promise((function(i,o){e.isLocked(t)?e.addToLocked(t,i):(e.addToLocked(t),i());}))},this.unlock=function(t){var i=e.locked.get(t);if(void 0!==i&&0!==i.length){var o=i.pop();e.locked.set(t,i),void 0!==o&&setTimeout(o,0);}else e.locked.delete(t);};}return e.getInstance=function(){return void 0===e.instance&&(e.instance=new e),e.instance},e}();t.default=function(){return i.getInstance()};}));i$3(n$6);var a$e=i$3(o$6((function(e,i){var o=t$6&&t$6.__awaiter||function(e,t,i,o){return new(i||(i=Promise))((function(n,a){function r(e){try{c(o.next(e));}catch(e){a(e);}}function s(e){try{c(o.throw(e));}catch(e){a(e);}}function c(e){e.done?n(e.value):new i((function(t){t(e.value);})).then(r,s);}c((o=o.apply(e,t||[])).next());}))},a=t$6&&t$6.__generator||function(e,t){var i,o,n,a,r={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(i)throw new TypeError("Generator is already executing.");for(;r;)try{if(i=1,o&&(n=2&a[0]?o.return:a[0]?o.throw||((n=o.return)&&n.call(o),0):o.next)&&!(n=n.call(o,a[1])).done)return n;switch(o=0,n&&(a=[2&a[0],n.value]),a[0]){case 0:case 1:n=a;break;case 4:return r.label++,{value:a[1],done:!1};case 5:r.label++,o=a[1],a=[0];continue;case 7:a=r.ops.pop(),r.trys.pop();continue;default:if(!(n=r.trys,(n=n.length>0&&n[n.length-1])||6!==a[0]&&2!==a[0])){r=0;continue}if(3===a[0]&&(!n||a[1]>n[0]&&a[1]<n[3])){r.label=a[1];break}if(6===a[0]&&r.label<n[1]){r.label=n[1],n=a;break}if(n&&r.label<n[2]){r.label=n[2],r.ops.push(a);break}n[2]&&r.ops.pop(),r.trys.pop();continue}a=t.call(e,r);}catch(e){a=[6,e],o=0;}finally{i=n=0;}if(5&a[0])throw a[1];return {value:a[0]?a[1]:void 0,done:true}}([a,s])}}},r=t$6;Object.defineProperty(i,"__esModule",{value:true});var s="browser-tabs-lock-key",c={key:function(e){return o(r,void 0,void 0,(function(){return a(this,(function(e){throw new Error("Unsupported")}))}))},getItem:function(e){return o(r,void 0,void 0,(function(){return a(this,(function(e){throw new Error("Unsupported")}))}))},clear:function(){return o(r,void 0,void 0,(function(){return a(this,(function(e){return [2,window.localStorage.clear()]}))}))},removeItem:function(e){return o(r,void 0,void 0,(function(){return a(this,(function(e){throw new Error("Unsupported")}))}))},setItem:function(e,t){return o(r,void 0,void 0,(function(){return a(this,(function(e){throw new Error("Unsupported")}))}))},keySync:function(e){return window.localStorage.key(e)},getItemSync:function(e){return window.localStorage.getItem(e)},clearSync:function(){return window.localStorage.clear()},removeItemSync:function(e){return window.localStorage.removeItem(e)},setItemSync:function(e,t){return window.localStorage.setItem(e,t)}};function d(e){return new Promise((function(t){return setTimeout(t,e)}))}function u(e){for(var t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",i="",o=0;o<e;o++){i+=t[Math.floor(Math.random()*t.length)];}return i}var l=function(){function e(t){this.acquiredIatSet=new Set,this.storageHandler=void 0,this.id=Date.now().toString()+u(15),this.acquireLock=this.acquireLock.bind(this),this.releaseLock=this.releaseLock.bind(this),this.releaseLock__private__=this.releaseLock__private__.bind(this),this.waitForSomethingToChange=this.waitForSomethingToChange.bind(this),this.refreshLockWhileAcquired=this.refreshLockWhileAcquired.bind(this),this.storageHandler=t,void 0===e.waiters&&(e.waiters=[]);}return e.prototype.acquireLock=function(t,i){return void 0===i&&(i=5e3),o(this,void 0,void 0,(function(){var o,n,r,l,h,p,m;return a(this,(function(a){switch(a.label){case 0:o=Date.now()+u(4),n=Date.now()+i,r=s+"-"+t,l=void 0===this.storageHandler?c:this.storageHandler,a.label=1;case 1:return Date.now()<n?[4,d(30)]:[3,8];case 2:return a.sent(),null!==l.getItemSync(r)?[3,5]:(h=this.id+"-"+t+"-"+o,[4,d(Math.floor(25*Math.random()))]);case 3:return a.sent(),l.setItemSync(r,JSON.stringify({id:this.id,iat:o,timeoutKey:h,timeAcquired:Date.now(),timeRefreshed:Date.now()})),[4,d(30)];case 4:return a.sent(),null!==(p=l.getItemSync(r))&&(m=JSON.parse(p)).id===this.id&&m.iat===o?(this.acquiredIatSet.add(o),this.refreshLockWhileAcquired(r,o),[2,true]):[3,7];case 5:return e.lockCorrector(void 0===this.storageHandler?c:this.storageHandler),[4,this.waitForSomethingToChange(n)];case 6:a.sent(),a.label=7;case 7:return o=Date.now()+u(4),[3,1];case 8:return [2,false]}}))}))},e.prototype.refreshLockWhileAcquired=function(e,t){return o(this,void 0,void 0,(function(){var i=this;return a(this,(function(r){return setTimeout((function(){return o(i,void 0,void 0,(function(){var i,o,r;return a(this,(function(a){switch(a.label){case 0:return [4,n$6.default().lock(t)];case 1:return a.sent(),this.acquiredIatSet.has(t)?(i=void 0===this.storageHandler?c:this.storageHandler,null===(o=i.getItemSync(e))?(n$6.default().unlock(t),[2]):((r=JSON.parse(o)).timeRefreshed=Date.now(),i.setItemSync(e,JSON.stringify(r)),n$6.default().unlock(t),this.refreshLockWhileAcquired(e,t),[2])):(n$6.default().unlock(t),[2])}}))}))}),1e3),[2]}))}))},e.prototype.waitForSomethingToChange=function(t){return o(this,void 0,void 0,(function(){return a(this,(function(i){switch(i.label){case 0:return [4,new Promise((function(i){var o=false,n=Date.now(),a=false;function r(){if(a||(window.removeEventListener("storage",r),e.removeFromWaiting(r),clearTimeout(s),a=true),!o){o=true;var t=50-(Date.now()-n);t>0?setTimeout(i,t):i(null);}}window.addEventListener("storage",r),e.addToWaiting(r);var s=setTimeout(r,Math.max(0,t-Date.now()));}))];case 1:return i.sent(),[2]}}))}))},e.addToWaiting=function(t){this.removeFromWaiting(t),void 0!==e.waiters&&e.waiters.push(t);},e.removeFromWaiting=function(t){ void 0!==e.waiters&&(e.waiters=e.waiters.filter((function(e){return e!==t})));},e.notifyWaiters=function(){ void 0!==e.waiters&&e.waiters.slice().forEach((function(e){return e()}));},e.prototype.releaseLock=function(e){return o(this,void 0,void 0,(function(){return a(this,(function(t){switch(t.label){case 0:return [4,this.releaseLock__private__(e)];case 1:return [2,t.sent()]}}))}))},e.prototype.releaseLock__private__=function(t){return o(this,void 0,void 0,(function(){var i,o,r,d;return a(this,(function(a){switch(a.label){case 0:return i=void 0===this.storageHandler?c:this.storageHandler,o=s+"-"+t,null===(r=i.getItemSync(o))?[2]:(d=JSON.parse(r)).id!==this.id?[3,2]:[4,n$6.default().lock(d.iat)];case 1:a.sent(),this.acquiredIatSet.delete(d.iat),i.removeItemSync(o),n$6.default().unlock(d.iat),e.notifyWaiters(),a.label=2;case 2:return [2]}}))}))},e.lockCorrector=function(t){for(var i=Date.now()-5e3,o=t,n=[],a=0;;){var r=o.keySync(a);if(null===r)break;n.push(r),a++;}for(var c=false,d=0;d<n.length;d++){var u=n[d];if(u.includes(s)){var l=o.getItemSync(u);if(null!==l){var h=JSON.parse(l);(void 0===h.timeRefreshed&&h.timeAcquired<i||void 0!==h.timeRefreshed&&h.timeRefreshed<i)&&(o.removeItemSync(u),c=true);}}}c&&e.notifyWaiters();},e.waiters=void 0,e}();i.default=l;})));var R$1=o$6((function(e,i){var o=t$6&&t$6.__assign||function(){return o=Object.assign||function(e){for(var t,i=1,o=arguments.length;i<o;i++)for(var n in t=arguments[i])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},o.apply(this,arguments)};function n(e,t){if(!t)return "";var i="; "+e;return true===t?i:i+"="+t}function a(e,t,i){return encodeURIComponent(e).replace(/%(23|24|26|2B|5E|60|7C)/g,decodeURIComponent).replace(/\(/g,"%28").replace(/\)/g,"%29")+"="+encodeURIComponent(t).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,decodeURIComponent)+function(e){if("number"==typeof e.expires){var t=new Date;t.setMilliseconds(t.getMilliseconds()+864e5*e.expires),e.expires=t;}return n("Expires",e.expires?e.expires.toUTCString():"")+n("Domain",e.domain)+n("Path",e.path)+n("Secure",e.secure)+n("SameSite",e.sameSite)}(i)}function r(e){for(var t={},i=e?e.split("; "):[],o=/(%[\dA-F]{2})+/gi,n=0;n<i.length;n++){var a=i[n].split("="),r=a.slice(1).join("=");'"'===r.charAt(0)&&(r=r.slice(1,-1));try{t[a[0].replace(o,decodeURIComponent)]=r.replace(o,decodeURIComponent);}catch(e){}}return t}function s(){return r(document.cookie)}function c(e,t,i){document.cookie=a(e,t,o({path:"/"},i));}i.__esModule=true,i.encode=a,i.parse=r,i.getAll=s,i.get=function(e){return s()[e]},i.set=c,i.remove=function(e,t){c(e,"",o(o({},t),{expires:-1}));};}));i$3(R$1),R$1.encode,R$1.parse,R$1.getAll;R$1.get;R$1.set;R$1.remove;new a$e;
/**
 * The initial auth state.
 */
var initialAuthState = {
    isAuthenticated: false,
    isLoading: true,
};

/**
 * @ignore
 */
var stub = function () {
    throw new Error('You forgot to wrap your component in <Auth0Provider>.');
};
/**
 * @ignore
 */
var initialContext = __assign(__assign({}, initialAuthState), { buildAuthorizeUrl: stub, buildLogoutUrl: stub, getAccessTokenSilently: stub, getAccessTokenWithPopup: stub, getIdTokenClaims: stub, loginWithRedirect: stub, loginWithPopup: stub, logout: stub, handleRedirectCallback: stub });
/**
 * The Auth0 Context
 */
scoping__loadShare__react__loadShare__.createContext(initialContext);

/**
 * An OAuth2 error will come from the authorization server and will have at least an `error` property which will
 * be the error code. And possibly an `error_description` property
 *
 * See: https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.6
 */
/** @class */ ((function (_super) {
    __extends(OAuthError, _super);
    function OAuthError(error, error_description) {
        var _this = _super.call(this, error_description || error) || this;
        _this.error = error;
        _this.error_description = error_description;
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, OAuthError.prototype);
        return _this;
    }
    return OAuthError;
})(Error));

// dev uses dynamic import to separate chunks
    
    const {loadShare: loadShare$1} = index_cjs;
    const {initPromise: initPromise$1} = scoping__mf_v__runtimeInit__mf_v__;
    const res$1 = initPromise$1.then(_ => loadShare$1("react-i18next", {
    customShareInfo: {shareConfig:{
      singleton: false,
      strictVersion: false,
      requiredVersion: "^15.4.1"
    }}}));
    const exportModule$1 = await res$1.then(factory => factory());
    var scoping__loadShare__react_mf_2_i18next__loadShare__ = exportModule$1;

function LocalizationProvider({ i18next, userPreferencesStore, children }) {
  scoping__loadShare__react__loadShare__.useEffect(() => {
    if (userPreferencesStore) {
      userPreferencesStore.subscribe(({ locale }) => {
        i18next.changeLanguage(locale);
      });
    } else {
      console.warn("No jamf:user_preferences_service userPreferencesStore provided to LocalizationProvider");
    }
  }, [userPreferencesStore, i18next]);
  return /* @__PURE__ */ React.createElement(scoping__loadShare__react_mf_2_i18next__loadShare__.I18nextProvider, { i18n: i18next }, children);
}

const FeatureServicesContext = React.createContext(null);
function useFeatureServices() {
  const featureServices = React.useContext(FeatureServicesContext);
  if (!featureServices) {
    throw new Error("You need to provide Feature service context before accessing featureServices");
  }
  return featureServices;
}

const requiredServices = {
  "jamf:groups_service": "^2.0.0",
  "jamf:gateway_base_url_service": "^1.0.0",
  "jamf:user_preferences_service": "^1.0.0",
  "jamf:blueprints-service": "^1.0.0",
  "jamf:auth_service": "^1.0.0",
  "jamf:tenant_service": "^1.0.0"
};

const l$3 = (n, e = "", r = false) => {
  let t;
  return t = e ? `[name="${e}"]` : "slot", (e.includes("slot") || r) && (t = e), r ? !!n?.querySelector(t)?.childNodes.length : !!n?.querySelector(t)?.assignedNodes().length;
};

function a$d(t) {
  if (!t)
    return null;
  const e = t.getRootNode();
  return e && e.host && e || null;
}
const f$f = defineComponent({
  name: "JamfButton",
  components: { JamfSpinner: z$3 },
  props: {
    /** The accessible title of the button if one is set. Note: This will only be set if the `label` is not set */
    accessibleTitle: {
      type: String,
      default: null
    },
    /** Sets button state to disabled. */
    isDisabled: {
      type: Boolean,
      default: false
    },
    /** Type of button to render.
     * @values link, danger, primary, secondary, ghost, ghost-primary, ghost-danger, simple */
    styleType: {
      type: String,
      default: "primary"
    },
    /** Sets the button's action to loading */
    isLoading: {
      type: Boolean,
      default: false
    },
    /** Size of the button.
     * @values default, small */
    size: {
      type: String,
      default: "default"
    },
    /** Sets the button's width to 100%. */
    fullWidth: {
      type: Boolean,
      default: false
    },
    /** Sets the button's semantic type. */
    type: {
      type: String,
      default: "button"
    },
    /** Sets the form id to associate the button with. */
    form: {
      type: String,
      default: null
    },
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula--button"
    },
    /** Optional component identifier that can be set as a unique value on a page for web analytics targeting. */
    waId: String
  },
  data() {
    return {
      refreshKey: 0,
      trailingSlot: null,
      leadingSlot: null,
      labelSlot: null
    };
  },
  computed: {
    hasAccessibleTitle() {
      return !this.hasLabel && this.accessibleTitle ? this.accessibleTitle : void 0;
    },
    hasLabel() {
      return this.refreshKey, this.labelSlot;
    },
    hasTrailingSlot() {
      return this.refreshKey, this.trailingSlot;
    },
    hasLeadingSlot() {
      return this.refreshKey, this.leadingSlot;
    },
    classes() {
      return {
        "jamf-button-v5-9-0": true,
        [this.styleType]: true,
        "is-disabled": this.isDisabled,
        accessibleTitle: this.hasAccessibleTitle,
        "with-icon-only": !this.hasLabel,
        "is-loading": this.isLoading,
        "has-leading-icon": this.hasLeadingSlot && this.hasLabel,
        "has-trailing-icon": this.hasTrailingSlot && this.hasLabel,
        [this.size]: true,
        "full-width": this.fullWidth
      };
    }
  },
  watch: {
    isLoading() {
      this.setSpinnerStyle();
    }
  },
  beforeUpdate() {
    this.forceRecompute(), this.checkSlots();
  },
  created() {
    this.forceRecompute();
  },
  mounted() {
    this.checkSlots(), this.isLoading && this.setSpinnerStyle();
  },
  methods: {
    setSpinnerStyle() {
      this.$refs.spinner && this.styleType === "secondary" && (this.$refs.spinner.style.color = "var(--color-action-secondary-spinner)");
    },
    checkSlots() {
      this.leadingSlot = l$3(this.$refs.button, "leading"), this.trailingSlot = l$3(this.$refs.button, "trailing"), this.labelSlot = l$3(
        this.$refs.button,
        "slot:not([name='leading']):not([name='trailing'])"
      );
    },
    handleClick() {
      if (this.type === "submit") {
        let t = null;
        const i = this.$refs.button.getRootNode().host;
        if (this.form) {
          if (t = document.getElementById(this.form), !t) {
            const l = a$d(i);
            l && (t = l.getElementById(this.form));
          }
        } else
          t = i.closest("form");
        t && t.dispatchEvent(
          new SubmitEvent("submit", {
            bubbles: true,
            cancelable: true,
            submitter: i
          })
        );
      }
    },
    forceRecompute() {
      this.refreshKey++;
    }
  }
});

const o$5 = '@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{0%{opacity:1}to{opacity:0}}@keyframes scaleIn{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer{0%{background-position:200% 0}to{background-position:-200% 0}}.jamf-button-v5-9-0{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-action-base);line-height:var(--size-font-action-height);letter-spacing:var(--size-font-action-spacing);cursor:pointer;width:fit-content;box-sizing:border-box;transition-property:background-color,box-shadow,border;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;background-color:var(--color-action-secondary-base);color:var(--color-font-base);border-radius:var(--size-border-radius-action-base);padding:var(--size-action-padding-base, calc(1px * var(--size-base-spacing)) calc(2px * var(--size-base-spacing)));border:none;display:flex;justify-content:center;align-items:center}.jamf-button-v5-9-0 svg,.jamf-button-v5-9-0 .leading,.jamf-button-v5-9-0 .trailing{fill:currentColor;box-sizing:content-box}.jamf-button-v5-9-0:focus,.jamf-button-v5-9-0:hover{text-decoration:none}.jamf-button-v5-9-0.is-disabled,.jamf-button-v5-9-0:disabled{opacity:var(--opacity-disabled);cursor:not-allowed}.jamf-button-v5-9-0:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-secondary-active)}.jamf-button-v5-9-0:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0:focus:not(:disabled){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}.jamf-button-v5-9-0.small{padding:var(--size-action-padding-base, calc(.5px * var(--size-base-spacing)) calc(1px * var(--size-base-spacing)))}.jamf-button-v5-9-0.full-width{width:100%}.jamf-button-v5-9-0.is-loading.with-icon-only .leading{display:none}.jamf-button-v5-9-0.is-loading:not(.with-icon-only){padding-right:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.is-loading:not(.with-icon-only) *:global(.spinner){margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.is-loading:not(.with-icon-only) .spinner{margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.with-icon-only{border-radius:var(--size-border-radius-action-icon-only);justify-content:center}.jamf-button-v5-9-0.with-icon-only:not(.small){width:var(--size-action-height-base);max-width:var(--size-action-height-base);min-width:var(--size-action-height-base);height:var(--size-action-height-base);max-height:var(--size-action-height-base);min-height:var(--size-action-height-base);padding:var(--size-action-padding-icon-only, calc(1px * var(--size-base-spacing)))}.jamf-button-v5-9-0.with-icon-only *:global(.spinner){margin:0}.jamf-button-v5-9-0.with-icon-only .spinner{margin:0}.jamf-button-v5-9-0.has-leading-icon span,.jamf-button-v5-9-0.has-leading-icon .label{margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.has-trailing-icon span,.jamf-button-v5-9-0.has-trailing-icon .label{margin-right:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0 svg,.jamf-button-v5-9-0 .leading,.jamf-button-v5-9-0 .trailing,.jamf-button-v5-9-0 .spinner{width:calc(var(--size-base-items) * 2px)}.jamf-button-v5-9-0 *:global(.spinner){width:calc(var(--size-base-items) * 3px);margin:-4px 0 -3px}.jamf-button-v5-9-0 .spinner{width:calc(var(--size-base-items) * 3px);margin:-4px 0 -3px}.jamf-button-v5-9-0.primary{background-color:var(--color-action-primary-base);color:var(--color-font-inverse);border:var(--size-border-width-base) solid var(--color-action-primary-base)}.jamf-button-v5-9-0.primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-primary-active)}.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-primary-active);border-color:var(--color-action-primary-active)}.jamf-button-v5-9-0.secondary{background-color:var(--color-action-secondary-base);color:var(--color-font-base);border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.secondary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.secondary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-secondary-active)}.jamf-button-v5-9-0.secondary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.danger{background-color:var(--color-action-danger-base);color:var(--color-font-inverse);border:var(--size-border-width-base) solid var(--color-action-danger-base)}.jamf-button-v5-9-0.danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-danger-active)}.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-danger-active);border-color:var(--color-action-danger-active)}.jamf-button-v5-9-0.ghost{background-color:var(--color-action-ghost-base);color:var(--color-font-base);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.ghost-primary{background-color:var(--color-action-ghost-base);color:var(--color-font-link-base);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost-primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost-primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost-primary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost-primary:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost-primary:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-primary-base)}.jamf-button-v5-9-0.ghost-danger{background-color:var(--color-action-ghost-base);color:var(--color-font-danger);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost-danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost-danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost-danger:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost-danger:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost-danger:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-danger-base)}.jamf-button-v5-9-0.simple:not(.as-button),.jamf-button-v5-9-0.link:not(.as-button){background-color:var(--color-action-ghost-base);color:var(--color-font-link-base);border:var(--size-border-width-base) solid transparent;box-shadow:none;padding:0px calc(.25px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);height:fit-content;border:none!important}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.simple:not(.as-button):active:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.simple:not(.as-button):active:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.simple:not(.as-button):focus:not(:disabled),.jamf-button-v5-9-0.link:not(.as-button):focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:focus):not(:active),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:focus):not(:active){box-shadow:none!important}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):active,.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):active{background-color:var(--color-action-ghost-base)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.simple:not(.as-button):focus:not(:disabled),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.link:not(.as-button):focus:not(:disabled){background-color:var(--color-action-ghost-base);color:var(--color-action-primary-active)}.jamf-button-v5-9-0.simple:not(.as-button):active,.jamf-button-v5-9-0.link:not(.as-button):active{background-color:var(--color-action-ghost-base)}.jamf-button-v5-9-0.link:not(.as-button):hover{text-decoration:underline}.jamf-button-v5-9-0:not(.small){height:var(--size-action-height-base)}.jamf-button-v5-9-0.unstyled:not(.as-button){background:none;border:none;padding:0;margin:0;height:fit-content}.jamf-button-v5-9-0.unstyled:not(.as-button):hover:not(:disabled):not(:focus):not(:active){background-color:unset}.jamf-button-v5-9-0.unstyled:not(.as-button):focus:not(:disabled){background-color:unset}:host{width:fit-content;display:inline-block}:host([full-width]){width:100%}';

const w$7 = ["type", "disabled", "data-wa", "data-wa-id", "aria-label"];
function $$6(e, t, k, y, C, h) {
  const s = resolveComponent("JamfSpinner");
  return openBlock(), createElementBlock("button", mergeProps({
    ref: "button",
    type: e.type,
    class: e.classes,
    disabled: e.isDisabled
  }, e.$attrs, {
    "data-wa": e.waComponent,
    "data-wa-id": e.waId,
    "aria-label": e.hasAccessibleTitle,
    onClick: t[0] || (t[0] = (...o) => e.handleClick && e.handleClick(...o)),
    part: "button"
  }), [
    renderSlot(e.$slots, "leading", {
      class: "leading",
      part: "leading"
    }),
    createBaseVNode("span", null, [
      renderSlot(e.$slots, "default")
    ]),
    withDirectives(createBaseVNode("div", null, [
      renderSlot(e.$slots, "trailing", {
        class: "trailing",
        part: "trailing"
      })
    ], 512), [
      [vShow, !e.isLoading]
    ]),
    e.isLoading ? (openBlock(), createBlock(s, {
      key: 0,
      ref: "spinner",
      class: "trailing"
    }, null, 512)) : createCommentVNode("", true)
  ], 16, w$7);
}
const D$2 = /* @__PURE__ */ s$6(f$f, [["render", $$6], ["styles", [o$5]]]);

const t$5 = r$9(D$2), u$4 = Object.keys(D$2.props), a$c = t$5.prototype.attachShadow;
t$5.prototype.attachShadow = function(e) {
  return a$c.apply(this, [{ ...e, delegatesFocus: true }]);
};
(function() {
  customElements.get("jamf-button-v5-9-0") === void 0 && customElements.define("jamf-button-v5-9-0", t$5);
})();

const { wrap: a$b } = V$1(React), f$e = a$b(t$5, {
  name: "jamf-button-v5-9-0",
  events: {
    onClick: "click"
  },
  properties: [...u$4]
});

// dev uses dynamic import to separate chunks
    
    const {loadShare} = index_cjs;
    const {initPromise} = scoping__mf_v__runtimeInit__mf_v__;
    const res = initPromise.then(_ => loadShare("react-hook-form", {
    customShareInfo: {shareConfig:{
      singleton: false,
      strictVersion: false,
      requiredVersion: "^7.61.1"
    }}}));
    const exportModule = await res.then(factory => factory());
    var scoping__loadShare__react_mf_2_hook_mf_2_form__loadShare__ = exportModule;

function c$6(e,u,c){var i=this,a=scoping__loadShare__react__loadShare__.useRef(null),o=scoping__loadShare__react__loadShare__.useRef(0),f=scoping__loadShare__react__loadShare__.useRef(null),l=scoping__loadShare__react__loadShare__.useRef([]),v=scoping__loadShare__react__loadShare__.useRef(),m=scoping__loadShare__react__loadShare__.useRef(),d=scoping__loadShare__react__loadShare__.useRef(e),g=scoping__loadShare__react__loadShare__.useRef(true);d.current=e;var p="undefined"!=typeof window,w=!u&&0!==u&&p;if("function"!=typeof e)throw new TypeError("Expected a function");u=+u||0;var s=!!(c=c||{}).leading,x=!("trailing"in c)||!!c.trailing,h="maxWait"in c,y="debounceOnServer"in c&&!!c.debounceOnServer,F=h?Math.max(+c.maxWait||0,u):null;scoping__loadShare__react__loadShare__.useEffect(function(){return g.current=true,function(){g.current=false;}},[]);var A=scoping__loadShare__react__loadShare__.useMemo(function(){var r=function(r){var n=l.current,t=v.current;return l.current=v.current=null,o.current=r,m.current=d.current.apply(t,n)},n=function(r,n){w&&cancelAnimationFrame(f.current),f.current=w?requestAnimationFrame(r):setTimeout(r,n);},t=function(r){if(!g.current)return  false;var n=r-a.current;return !a.current||n>=u||n<0||h&&r-o.current>=F},e=function(n){return f.current=null,x&&l.current?r(n):(l.current=v.current=null,m.current)},c=function r(){var c=Date.now();if(t(c))return e(c);if(g.current){var i=u-(c-a.current),f=h?Math.min(i,F-(c-o.current)):i;n(r,f);}},A=function(){if(p||y){var e=Date.now(),d=t(e);if(l.current=[].slice.call(arguments),v.current=i,a.current=e,d){if(!f.current&&g.current)return o.current=a.current,n(c,u),s?r(a.current):m.current;if(h)return n(c,u),r(a.current)}return f.current||n(c,u),m.current}};return A.cancel=function(){f.current&&(w?cancelAnimationFrame(f.current):clearTimeout(f.current)),o.current=0,l.current=a.current=v.current=f.current=null;},A.isPending=function(){return !!f.current},A.flush=function(){return f.current?e(Date.now()):m.current},A},[s,h,u,F,x,w,p,y]);return A}function i$2(r,n){return r===n}function a$a(n,t,a){var o=i$2,f=scoping__loadShare__react__loadShare__.useRef(n),l=scoping__loadShare__react__loadShare__.useState({})[1],v=c$6(scoping__loadShare__react__loadShare__.useCallback(function(r){f.current=r,l({});},[l]),t,a),m=scoping__loadShare__react__loadShare__.useRef(n);return o(m.current,n)||(v(n),m.current=n),[f.current,v]}

const h$5 = defineComponent({
  name: "JamfCheckboxGroup",
  provide() {
    return {
      groupIsDisabled: computed(() => this.isDisabled),
      groupIsReadOnly: computed(() => this.isReadOnly),
      groupHasError: computed(() => this.hasError)
    };
  },
  props: {
    /** Sets the label text. */
    isVertical: Boolean,
    /** Sets the id which binds the label to the input group.
     * Should be unique on the page. */
    id: String,
    /** Sets text for the label. */
    label: String,
    /** Sets the text to display below the field to indicate it simple information */
    descenderText: String,
    /** Sets size for label and helper text */
    labelSize: {
      type: String,
      default: "medium"
    },
    /** Sets size of input */
    size: {
      type: String,
      default: "medium"
    },
    /** Sets error state */
    hasError: Boolean,
    /** Sets error text to display when an error has occurred */
    errorText: String,
    /** Sets disabled state */
    isDisabled: Boolean,
    /** Sets read only state */
    isReadOnly: Boolean,
    /** Sets toggle button group state */
    isToggle: Boolean,
    /** Sets menu list group state */
    isMenuList: Boolean,
    /** Sets the default value of the component,.  */
    value: {
      type: Array,
      default: () => []
    },
    /** Sets data-wa attribute. */
    waComponent: {
      type: String,
      default: "nebula--toggle-group"
    },
    /** Sets data-wa-id attribute. */
    waId: String
  },
  emits: ["change", "input"],
  data() {
    return {
      internalValue: this.value,
      checkboxComponents: [],
      internals: void 0,
      observer: null
    };
  },
  computed: {
    classes() {
      return {
        group: true,
        "checkbox-group": !this.isToggle,
        "toggle-group": this.isToggle,
        "is-vertical": this.isVertical,
        "has-error": this.hasError,
        "is-disabled": this.isDisabled,
        [this.size]: this.size !== "medium"
      };
    },
    disabled() {
      return this.isDisabled || this.isReadOnly;
    },
    includeDescenders() {
      const e = this.$refs.checkboxGroup;
      return !!this.errorText && this.hasError || !!l$3(e, "descenders") || !!this.descenderText;
    },
    descenderId() {
      return this.id ? `${this.id}-descender` : "";
    },
    errorId() {
      return this.id ? `${this.id}-error` : "";
    },
    ariaDescribedById() {
      if (this.hasError && this.errorText && this.errorId) return this.errorId;
      if (this.descenderText && this.descenderId && !this.hasError)
        return this.descenderId;
    },
    groupClass() {
      return {
        label: true,
        "label-container": this.isToggle
      };
    },
    labelClass() {
      return {
        "label-text": !this.isVertical,
        "error-text": this.hasError,
        "label-large": this.labelSize == "large",
        "label-medium": this.labelSize == "medium",
        "label-small": this.labelSize == "small"
      };
    }
  },
  watch: {
    value: {
      handler(e) {
        this.internalValue = e, this.internals && this.internals.setFormValue(e), this.initializeComponent(this.$refs);
      },
      deep: true
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.initializeComponent(this.$refs);
      const e = this.$refs.checkboxGroup.getRootNode()?.host;
      this.observer = new MutationObserver(() => {
        this.initializeComponent(this.$refs);
      }), this.observer.observe(e, { childList: true, subtree: true }), this.internals = this.$refs.checkboxGroup.getRootNode().host.internals_, this.value && this.internals && this.internals.setFormValue(this.value);
    });
  },
  updated() {
    this.initializeComponent(this.$refs);
  },
  methods: {
    initializeComponent(e) {
      this.checkboxComponents = [], (e.checkboxGroup?.querySelector("slot")?.assignedElements() || []).forEach((i) => {
        i.tagName === "JAMF-CHECKBOX-V5-9-0" ? this.checkboxComponents.push(i) : this.checkboxComponents.push(
          ...Array.from(i.getElementsByTagName("jamf-checkbox-v5-9-0"))
        );
      }), this.refreshChildComponents(this.checkboxComponents);
    },
    refreshChildComponents(e) {
      for (let t = 0; t < e.length; t++) {
        let i = e[t].getAttribute("value");
        this.internalValue.includes(i) ? e[t].setAttribute("checked", "") : e[t].removeAttribute("checked"), this.isToggle ? e[t].setAttribute("is-toggle", "") : this.isMenuList && e[t].setAttribute("is-menu-list", "");
      }
    },
    handleChange(e) {
      if (e.target.tagName.includes("JAMF-CHECKBOX-V5-9-0")) {
        if (e.target.checked && this.internalValue.indexOf(e.target.value) && this.internalValue.push(e.target.value), !e.target.checked) {
          let t = this.internalValue.indexOf(e.target.value);
          t !== -1 && this.internalValue.splice(t, 1);
        }
        this.updateValue();
      }
    },
    updateValue() {
      const e = toRaw(this.internalValue), t = this.$refs.checkboxGroup?.getRootNode()?.host;
      t && (t.value = e), this.$emit("input", e), this.$emit("change", e), (typeof e == "string" || e instanceof File || e instanceof FormData || e === null) && this.internals && this.internals.setFormValue(e);
    }
  },
  beforeUnmount() {
    this.observer && this.observer.disconnect();
  }
});

const a$9 = '@keyframes fadeIn-d950627b{0%{opacity:0}to{opacity:1}}@keyframes fadeOut-d950627b{0%{opacity:1}to{opacity:0}}@keyframes scaleIn-d950627b{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut-d950627b{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft-d950627b{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop-d950627b{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse-d950627b{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer-d950627b{0%{background-position:200% 0}to{background-position:-200% 0}}.group .error-text[data-v-d950627b]{color:var(--color-danger-base)}.group .label-container[data-v-d950627b]{display:flex;flex-direction:row;align-items:center}.group .label-text[data-v-d950627b]{padding-right:calc(1px * var(--size-base-spacing))}.group .label-text-vertical[data-v-d950627b]{padding-bottom:calc(1px * var(--size-base-spacing))}.group .is-disabled[data-v-d950627b]{opacity:var(--opacity-disabled);cursor:not-allowed}.group.secondary .slot-container[data-v-d950627b]{padding:0 calc(.25px * var(--size-base-spacing));border-radius:calc(var(--size-border-radius-small, 4px) + 1px);height:var(--size-input-height-base);display:flex;flex-direction:row;gap:calc(1px * var(--size-base-spacing));align-items:center;background-color:var(--color-border-secondary)}.group .label-small[data-v-d950627b]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-small))}.group .label-medium[data-v-d950627b]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-medium))}.group .label-large[data-v-d950627b]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-large))}.checkbox-group[data-v-d950627b] ::slotted(jamf-checkbox-v5-9-0){display:block;margin-top:calc(2px * var(--size-base-spacing))}.toggle-group .slot-container[data-v-d950627b]{display:flex;flex-direction:row;row-gap:calc(1px * var(--size-base-spacing));flex-wrap:wrap}';

const f$d = ["aria-labelledby", "aria-describedby", "disabled", "data-wa", "data-wa-id"], c$5 = {
  key: 0,
  part: "label-vertical",
  class: "label-text-vertical"
}, h$4 = ["for"], y$6 = ["id"], C$4 = ["for"], k$5 = {
  key: 1,
  class: "input-descenders",
  part: "input-descenders"
}, v$4 = ["id"], w$6 = ["id"];
function I$2(e, d, $, g, E, T) {
  return openBlock(), createElementBlock("div", {
    ref: "checkboxGroup",
    class: normalizeClass(e.classes),
    part: "container",
    "aria-labelledby": e.id,
    "aria-describedby": e.ariaDescribedById,
    disabled: e.disabled,
    "data-wa": e.waComponent,
    "data-wa-id": e.waId,
    onInput: d[1] || (d[1] = withModifiers(() => {
    }, ["stop"]))
  }, [
    e.label && e.isVertical ? (openBlock(), createElementBlock("div", c$5, [
      createBaseVNode("label", {
        for: e.id,
        class: normalizeClass(e.labelClass),
        part: "label-text-vertical"
      }, toDisplayString(e.label), 11, h$4)
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      id: e.id,
      class: normalizeClass(e.groupClass),
      part: "label",
      onChange: d[0] || (d[0] = withModifiers((...p) => e.handleChange && e.handleChange(...p), ["stop"]))
    }, [
      e.label && !e.isVertical ? (openBlock(), createElementBlock("label", {
        key: 0,
        for: e.id,
        class: normalizeClass(e.labelClass),
        part: "label-text"
      }, toDisplayString(e.label), 11, C$4)) : createCommentVNode("", true),
      renderSlot(e.$slots, "default", { class: "slot-container" })
    ], 42, y$6),
    e.includeDescenders ? (openBlock(), createElementBlock("div", k$5, [
      !e.hasError && e.descenderText ? (openBlock(), createElementBlock("small", {
        key: 0,
        id: e.descenderId,
        part: "descender-text"
      }, toDisplayString(e.descenderText), 9, v$4)) : createCommentVNode("", true),
      e.hasError ? (openBlock(), createElementBlock("small", {
        key: 1,
        id: e.errorId,
        class: "error-text",
        part: "error-text"
      }, toDisplayString(e.errorText || e.descenderText), 9, w$6)) : createCommentVNode("", true),
      renderSlot(e.$slots, "descenders")
    ])) : createCommentVNode("", true)
  ], 42, f$d);
}
const N$2 = /* @__PURE__ */ s$6(h$5, [["render", I$2], ["styles", [a$9]], ["__scopeId", "data-v-d950627b"]]);

const e$2 = r$9(N$2), m$8 = Object.keys(N$2.props);
let s$3 = class s extends e$2 {
  static {
    this.formAssociated = true;
  }
  constructor() {
    super(), this.internals_ = this.attachInternals();
  }
};
(function() {
  customElements.get("jamf-checkbox-group-v5-9-0") === void 0 && customElements.define("jamf-checkbox-group-v5-9-0", s$3);
})();

const { wrap: a$8 } = V$1(React), f$c = a$8(e$2, {
  name: "jamf-checkbox-group-v5-9-0",
  properties: [...m$8],
  events: {
    onChange: "change"
  }
});

function s$2(t = {}) {
  return t.id || (t.id = o$b()), document.dispatchEvent(
    new CustomEvent("toast", {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail: { config: t }
    })
  ), t.id;
}
function d$2(t) {
  document.dispatchEvent(
    new CustomEvent("toastDismiss", {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail: { id: t }
    })
  );
}
function p$4(t, e) {
  const { loading: i, success: u, error: c } = e, r = o$b();
  return i && s$2({ ...i, type: "loading", autoDismiss: false, id: r }), t().then((n) => {
    if (u) {
      const o = u(n);
      s$2({ ...o, type: "success", id: r });
    }
  }).catch((n) => {
    if (c) {
      const o = c(n);
      s$2({ ...o, type: "error", id: r });
    }
  }), r;
}
const m$7 = Object.assign(
  (t, e = {}) => s$2({ description: t, ...e }),
  {
    success(t, e = {}) {
      return s$2({ description: t, type: "success", ...e });
    },
    error(t, e = {}) {
      return s$2({ description: t, type: "error", ...e });
    },
    warning(t, e = {}) {
      return s$2({ description: t, type: "warning", ...e });
    },
    info(t, e = {}) {
      return s$2({ description: t, type: "info", ...e });
    },
    default(t, e = {}) {
      return s$2({ description: t, ...e });
    },
    loading(t, e = {}) {
      return s$2({ description: t, type: "loading", ...e });
    },
    dismiss(t) {
      d$2(t);
    },
    promise(t, e) {
      return p$4(t, e);
    }
  }
);

const ClientContext = React.createContext(null);

function useClient() {
  const client = scoping__loadShare__react__loadShare__.useContext(ClientContext);
  if (client === null) {
    throw new Error("Client is missing");
  }
  return client;
}

const SCOPING_PREFIX = "/scoping";
function getScopingApi(axios) {
  return {
    createScope(selectedGroups, enabled) {
      return axios.post(`${SCOPING_PREFIX}/api/v1/scope`, {
        include: selectedGroups.map((id) => {
          return {
            type: "groupId",
            value: id
          };
        }),
        enabled
      }).then(({ data }) => data);
    },
    getScope(scopeId) {
      return axios.get(`${SCOPING_PREFIX}/api/v1/scope/${scopeId}`).then(({ data }) => data);
    }
  };
}
function useScopingApi() {
  const client = useClient();
  return scoping__loadShare__react__loadShare__.useMemo(() => getScopingApi(client), [client]);
}

const useCreateScope = () => {
  const { t } = scoping__loadShare__react_mf_2_i18next__loadShare__.useTranslation("app");
  const { createScope } = useScopingApi();
  return useMutation({
    mutationKey: ["createScope"],
    mutationFn: (selectedGroups) => createScope(selectedGroups, false),
    onError() {
      m$7.error(t("create_scope__error__msg"));
    }
  });
};

const useScope = (scopeId) => {
  const { getScope } = useScopingApi();
  return useQuery({
    queryKey: ["scope", scopeId],
    queryFn: ({ queryKey }) => {
      const scopeId2 = queryKey[1];
      return getScope(scopeId2 ?? "");
    },
    enabled: !!scopeId
  });
};

const n$5 = defineComponent({
  name: "JamfIcon",
  components: { icon: b$7 },
  props: {
    /** Sets svg data based on name, can use icons from
     * "@jamf/design-system-web-components-next/icons" or custom svg "path" data
     * @values `@jamf/design-system-web-components-next/icons` */
    data: [String, Object],
    /** Sets width of icon.
     * Set to `default` to use the icons native width.
     * The numerical values are just an example.
     * This prop will accept any positive integer.
     * @values default, 16, 24, 32, 48, 64, 128, 256 */
    width: {
      type: [String, Number],
      default: 16
    },
    /** Sets height of icon.
     * Set to `auto` to use the icons native height
     * The numerical values are just an example.
     * This prop will accept any positive integer.
     * @values auto, 16, 24, 32, 48, 64, 128, 256 */
    height: {
      type: [String, Number],
      default: "auto"
    },
    /** Sets the color of the icon.
     * @values any valid css color value including HSL, RGB, HEX, etc. or success, danger, warning, primary */
    color: {
      type: String,
      default: "currentColor"
    },
    /** Rotates the icon.
     * @values number between 0-360 degrees */
    rotate: {
      type: Number
    },
    /** Sets the title of the icon. */
    title: String,
    /** Sets the icon to be an outline. */
    outline: Boolean,
    /** Sets the icon to use the original svg colors, useful for logos. */
    original: Boolean
  },
  computed: {
    iconColor() {
      return this.color === "success" ? "var(--color-success-base)" : this.color === "warning" ? "var(--color-warning-base)" : this.color === "danger" ? "var(--color-danger-base)" : this.color === "primary" ? "var(--color-primary-base)" : this.color;
    }
  }
});

function l$2(o, p, c, d, h, m) {
  const t = resolveComponent("icon");
  return openBlock(), createBlock(t, {
    data: o.data,
    width: o.width,
    height: o.height,
    rotate: o.rotate,
    title: o.title,
    outline: o.outline,
    original: o.original,
    color: o.iconColor
  }, null, 8, ["data", "width", "height", "rotate", "title", "outline", "original", "color"]);
}
const g$3 = /* @__PURE__ */ s$6(n$5, [["render", l$2]]);

const u$3 = defineComponent({
  name: "JamfAlertBanner",
  components: {
    JamfIcon: g$3
  },
  props: {
    /** Specifies the style of type and icon the component should use.
     * @values info, success, warning, danger
     */
    styleType: {
      type: String,
      default: "info"
    },
    /** Specifies the variant of the alert banner.
     * @values standard, full-width
     */
    variant: {
      type: String,
      default: "standard"
    },
    /** Sets state of icon for the alert banner.
     * Icon name inherits from `styleType` prop.
     */
    withIcon: Boolean,
    /** Sets the button text of the alert banner.
     * This prop will decide if the button should appear and it's label.
     */
    actionLabel: String,
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula-alert-banner"
    },
    /** Component identifier that can be set as a unique value on a page for web analytics targeting. */
    waId: String
  },
  emits: ["action"],
  data() {
    return {
      informationCircleOutline: R7,
      checkCircleOutline: oc,
      exclamationTriangleOutline: D8,
      exclamationCircleOutline: y8,
      titleSlot: null,
      messageSlot: null,
      refreshKey: 0
    };
  },
  computed: {
    classes() {
      return {
        alert: true,
        [this.styleType]: true,
        [this.variant]: true
      };
    },
    computedIcon() {
      let e;
      switch (this.styleType) {
        case "info":
          e = R7;
          break;
        case "success":
          e = oc;
          break;
        case "warning":
          e = D8;
          break;
        case "danger":
          e = y8;
          break;
      }
      return e;
    },
    hasTitle() {
      return this.refreshKey, this.titleSlot;
    },
    hasMessage() {
      return this.refreshKey, this.messageSlot;
    }
  },
  methods: {
    checkSlots() {
      this.titleSlot = l$3(this.$refs.banner, "title"), this.messageSlot = l$3(
        this.$refs.banner,
        "slot:not([name='title'])"
      );
    },
    forceRecompute() {
      this.refreshKey++;
    },
    handleActionClick() {
      this.$emit("action");
    }
  },
  beforeUpdate() {
    this.forceRecompute(), this.checkSlots();
  },
  created() {
    this.forceRecompute();
  },
  mounted() {
    this.checkSlots();
  }
});

const o$4 = '@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{0%{opacity:1}to{opacity:0}}@keyframes scaleIn{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer{0%{background-position:200% 0}to{background-position:-200% 0}}.alert{width:100%;justify-content:space-between;align-items:center;box-sizing:border-box}.alert .container{display:flex;flex-direction:row;height:auto}.alert .message{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-paragraph-base);line-height:var(--size-font-paragraph-height);letter-spacing:var(--size-font-paragraph-spacing);color:var(--color-font-secondary)}.alert .title{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-h5-weight);font-size:var(--size-font-h5-base);line-height:var(--size-font-h5-height);letter-spacing:var(--size-font-h5-spacing);color:var(--color-font-base);margin:0}.alert .icon-container{margin-right:calc(2px * var(--size-base-spacing))}.alert .btn-container{margin-left:calc(2px * var(--size-base-spacing))}.alert.info{display:flex;flex-direction:row;padding:calc(2px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);border:var(--size-border-width-base) solid;border-color:var(--color-info-base);background-color:var(--color-info-secondary);color:var(--color-info-base)}.alert.info a{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-link-base);line-height:var(--size-font-link-height);letter-spacing:var(--size-font-link-spacing);color:var(--color-font-link-wash, var(--color-font-link-base));border-radius:calc(.25px * var(--size-base-spacing))}.alert.info a:hover,.alert.info a:focus{color:var(--color-font-link-wash-active, var(--color-font-link-active))}.alert.success{display:flex;flex-direction:row;padding:calc(2px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);border:var(--size-border-width-base) solid;border-color:var(--color-success-base);background-color:var(--color-success-secondary);color:var(--color-success-base)}.alert.success a{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-link-base);line-height:var(--size-font-link-height);letter-spacing:var(--size-font-link-spacing);color:var(--color-font-link-wash, var(--color-font-link-base));border-radius:calc(.25px * var(--size-base-spacing))}.alert.success a:hover,.alert.success a:focus{color:var(--color-font-link-wash-active, var(--color-font-link-active))}.alert.warning{display:flex;flex-direction:row;padding:calc(2px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);border:var(--size-border-width-base) solid;border-color:var(--color-warning-base);background-color:var(--color-warning-secondary);color:var(--color-warning-base)}.alert.warning a{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-link-base);line-height:var(--size-font-link-height);letter-spacing:var(--size-font-link-spacing);color:var(--color-font-link-wash, var(--color-font-link-base));border-radius:calc(.25px * var(--size-base-spacing))}.alert.warning a:hover,.alert.warning a:focus{color:var(--color-font-link-wash-active, var(--color-font-link-active))}.alert.danger{display:flex;flex-direction:row;padding:calc(2px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);border:var(--size-border-width-base) solid;border-color:var(--color-danger-base);background-color:var(--color-danger-secondary);color:var(--color-danger-base)}.alert.danger a{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-link-base);line-height:var(--size-font-link-height);letter-spacing:var(--size-font-link-spacing);color:var(--color-font-link-wash, var(--color-font-link-base));border-radius:calc(.25px * var(--size-base-spacing))}.alert.danger a:hover,.alert.danger a:focus{color:var(--color-font-link-wash-active, var(--color-font-link-active))}.alert.full-width{width:100vw;border-top:none;border-left:none;border-right:none;border-radius:0;justify-self:center;padding:calc(4px * var(--size-base-spacing))}:host{width:100%}.alert{box-sizing:border-box}.jamf-button-v5-9-0{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-action-base);line-height:var(--size-font-action-height);letter-spacing:var(--size-font-action-spacing);cursor:pointer;width:fit-content;box-sizing:border-box;transition-property:background-color,box-shadow,border;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;background-color:var(--color-action-secondary-base);color:var(--color-font-base);border-radius:var(--size-border-radius-action-base);padding:var(--size-action-padding-base, calc(1px * var(--size-base-spacing)) calc(2px * var(--size-base-spacing)));border:none;display:flex;justify-content:center;align-items:center}.jamf-button-v5-9-0 svg,.jamf-button-v5-9-0 .leading,.jamf-button-v5-9-0 .trailing{fill:currentColor;box-sizing:content-box}.jamf-button-v5-9-0:focus,.jamf-button-v5-9-0:hover{text-decoration:none}.jamf-button-v5-9-0.is-disabled,.jamf-button-v5-9-0:disabled{opacity:var(--opacity-disabled);cursor:not-allowed}.jamf-button-v5-9-0:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-secondary-active)}.jamf-button-v5-9-0:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0:focus:not(:disabled){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}.jamf-button-v5-9-0.small{padding:var(--size-action-padding-base, calc(.5px * var(--size-base-spacing)) calc(1px * var(--size-base-spacing)))}.jamf-button-v5-9-0.full-width{width:100%}.jamf-button-v5-9-0.is-loading.with-icon-only .leading{display:none}.jamf-button-v5-9-0.is-loading:not(.with-icon-only){padding-right:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.is-loading:not(.with-icon-only) *:global(.spinner){margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.is-loading:not(.with-icon-only) .spinner{margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.with-icon-only{border-radius:var(--size-border-radius-action-icon-only);justify-content:center}.jamf-button-v5-9-0.with-icon-only:not(.small){width:var(--size-action-height-base);max-width:var(--size-action-height-base);min-width:var(--size-action-height-base);height:var(--size-action-height-base);max-height:var(--size-action-height-base);min-height:var(--size-action-height-base);padding:var(--size-action-padding-icon-only, calc(1px * var(--size-base-spacing)))}.jamf-button-v5-9-0.with-icon-only *:global(.spinner){margin:0}.jamf-button-v5-9-0.with-icon-only .spinner{margin:0}.jamf-button-v5-9-0.has-leading-icon span,.jamf-button-v5-9-0.has-leading-icon .label{margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.has-trailing-icon span,.jamf-button-v5-9-0.has-trailing-icon .label{margin-right:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0 svg,.jamf-button-v5-9-0 .leading,.jamf-button-v5-9-0 .trailing,.jamf-button-v5-9-0 .spinner{width:calc(var(--size-base-items) * 2px)}.jamf-button-v5-9-0 *:global(.spinner){width:calc(var(--size-base-items) * 3px);margin:-4px 0 -3px}.jamf-button-v5-9-0 .spinner{width:calc(var(--size-base-items) * 3px);margin:-4px 0 -3px}.jamf-button-v5-9-0.primary{background-color:var(--color-action-primary-base);color:var(--color-font-inverse);border:var(--size-border-width-base) solid var(--color-action-primary-base)}.jamf-button-v5-9-0.primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-primary-active)}.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-primary-active);border-color:var(--color-action-primary-active)}.jamf-button-v5-9-0.secondary{background-color:var(--color-action-secondary-base);color:var(--color-font-base);border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.secondary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.secondary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-secondary-active)}.jamf-button-v5-9-0.secondary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.danger{background-color:var(--color-action-danger-base);color:var(--color-font-inverse);border:var(--size-border-width-base) solid var(--color-action-danger-base)}.jamf-button-v5-9-0.danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-danger-active)}.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-danger-active);border-color:var(--color-action-danger-active)}.jamf-button-v5-9-0.ghost{background-color:var(--color-action-ghost-base);color:var(--color-font-base);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.ghost-primary{background-color:var(--color-action-ghost-base);color:var(--color-font-link-base);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost-primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost-primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost-primary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost-primary:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost-primary:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-primary-base)}.jamf-button-v5-9-0.ghost-danger{background-color:var(--color-action-ghost-base);color:var(--color-font-danger);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost-danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost-danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost-danger:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost-danger:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost-danger:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-danger-base)}.jamf-button-v5-9-0.simple:not(.as-button),.jamf-button-v5-9-0.link:not(.as-button){background-color:var(--color-action-ghost-base);color:var(--color-font-link-base);border:var(--size-border-width-base) solid transparent;box-shadow:none;padding:0px calc(.25px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);height:fit-content;border:none!important}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.simple:not(.as-button):active:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.simple:not(.as-button):active:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.simple:not(.as-button):focus:not(:disabled),.jamf-button-v5-9-0.link:not(.as-button):focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:focus):not(:active),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:focus):not(:active){box-shadow:none!important}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):active,.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):active{background-color:var(--color-action-ghost-base)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.simple:not(.as-button):focus:not(:disabled),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.link:not(.as-button):focus:not(:disabled){background-color:var(--color-action-ghost-base);color:var(--color-action-primary-active)}.jamf-button-v5-9-0.simple:not(.as-button):active,.jamf-button-v5-9-0.link:not(.as-button):active{background-color:var(--color-action-ghost-base)}.jamf-button-v5-9-0.link:not(.as-button):hover{text-decoration:underline}.jamf-button-v5-9-0:not(.small){height:var(--size-action-height-base)}.jamf-button-v5-9-0.unstyled:not(.as-button){background:none;border:none;padding:0;margin:0;height:fit-content}.jamf-button-v5-9-0.unstyled:not(.as-button):hover:not(:disabled):not(:focus):not(:active){background-color:unset}.jamf-button-v5-9-0.unstyled:not(.as-button):focus:not(:disabled){background-color:unset}::slotted(a){font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-link-base);line-height:var(--size-font-link-height);letter-spacing:var(--size-font-link-spacing);color:var(--color-font-link-wash, var(--color-font-link-base));border-radius:calc(.25px * var(--size-base-spacing));color:var(--color-font-link-wash)!important}::slotted(a):hover,::slotted(a):focus{color:var(--color-font-link-wash-active, var(--color-font-link-active))}';

const w$5 = ["data-wa", "data-wa-id"], _$2 = { class: "container" }, y$5 = {
  key: 0,
  class: "icon-container",
  part: "icon-container"
}, b$4 = {
  class: "title",
  part: "title"
}, $$5 = {
  class: "message",
  part: "message"
}, k$4 = {
  key: 0,
  class: "btn-container",
  part: "action-button"
};
function C$3(e, s, g, I, B, J) {
  const d = resolveComponent("JamfIcon");
  return openBlock(), createElementBlock("div", {
    "data-wa": e.waComponent,
    "data-wa-id": e.waId,
    class: normalizeClass(e.classes),
    ref: "banner",
    part: "container"
  }, [
    createBaseVNode("div", _$2, [
      e.withIcon ? (openBlock(), createElementBlock("div", y$5, [
        createVNode(d, {
          class: normalizeClass(e.styleType),
          data: e.computedIcon,
          width: "24px",
          height: "24px"
        }, null, 8, ["class", "data"])
      ])) : createCommentVNode("", true),
      createBaseVNode("div", null, [
        withDirectives(createBaseVNode("h4", b$4, [
          renderSlot(e.$slots, "title")
        ], 512), [
          [vShow, e.hasTitle]
        ]),
        withDirectives(createBaseVNode("div", $$5, [
          renderSlot(e.$slots, "default")
        ], 512), [
          [vShow, e.hasMessage]
        ])
      ])
    ]),
    e.actionLabel ? (openBlock(), createElementBlock("div", k$4, [
      createBaseVNode("button", {
        class: "jamf-button-v5-9-0 secondary",
        onClick: s[0] || (s[0] = (N) => e.handleActionClick())
      }, toDisplayString(e.actionLabel), 1)
    ])) : createCommentVNode("", true)
  ], 10, w$5);
}
const E$4 = /* @__PURE__ */ s$6(u$3, [["render", C$3], ["styles", [o$4]]]);

const t$4 = r$9(E$4), m$6 = Object.keys(E$4.props), r$3 = t$4.prototype.attachShadow;
t$4.prototype.attachShadow = function(a) {
  return r$3.apply(this, [{ ...a, delegatesFocus: true }]);
};
(function() {
  customElements.get("jamf-alert-banner-v5-9-0") === void 0 && customElements.define("jamf-alert-banner-v5-9-0", t$4);
})();

const { wrap: t$3 } = V$1(React), f$b = t$3(t$4, {
  name: "jamf-alert-banner-v5-9-0",
  properties: [...m$6],
  events: {
    onAction: "action"
  }
});

const n$4 = defineComponent({
  name: "JamfCheckbox",
  inject: {
    groupHasError: { default: () => false },
    groupIsDisabled: { default: () => false },
    groupIsReadOnly: { default: () => false }
  },
  props: {
    /** Sets the name attribute on the input */
    name: String,
    /** Sets the internal value of the component. */
    checked: [Boolean, String],
    /** Sets the native input value that will match the `value`. */
    value: [String, Number],
    /** Sets size for label */
    labelSize: {
      type: String,
      default: "medium"
    },
    /** Sets size of input */
    size: {
      type: String,
      default: "medium"
    },
    /** Sets the visual style as indeterminate, but does not impact the value of the checkbox (i.e. checked or unchecked). */
    indeterminate: Boolean,
    /** Sets checkbox to disabled state. */
    isDisabled: Boolean,
    /** Sets checkbox to readonly state. */
    isReadOnly: Boolean,
    /** Aligns any provided helper text underneath the label instead of beside it. */
    isVertical: Boolean,
    /** Sets checkbox to error state. */
    hasError: Boolean,
    /** Changes the visual style of checkbox to toggle button. */
    isToggle: Boolean,
    /** Changes the visual style of checkbox to menu list. */
    isMenuList: Boolean,
    /**
     * Sets toggle button style.
     * @values primary, warning, danger, success
     */
    styleType: {
      type: String,
      default: "primary"
    },
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula--checkbox"
    },
    /** Optional component identifier that can be set as a unique value on a page for web analytics targeting. */
    waId: String
  },
  emits: ["change"],
  data() {
    return {
      inputType: "checkbox",
      internals: void 0,
      mouseDownTargetElement: null
    };
  },
  computed: {
    computedValue: {
      get() {
        return this.checked;
      },
      set(e) {
        const t = this.$refs.label?.getRootNode()?.host;
        t && (t.checked = e), this.$refs.label.dispatchEvent(
          new CustomEvent("change", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: e
          })
        ), this.internals && this.internals.setFormValue(e);
      }
    },
    classes() {
      return {
        checkbox: !this.isToggle,
        toggle: this.isToggle,
        "menu-list": this.isMenuList,
        "menu-list-checked": this.isMenuList && this.checked,
        "menu-list-not-checked": this.isMenuList && !this.checked,
        active: this.checked,
        "is-disabled": this.computedIsDisabled,
        "is-read-only": this.computedIsReadOnly,
        "has-error": this.computedHasError,
        "is-vertical": this.isVertical,
        "label-large": this.labelSize == "large",
        "label-medium": this.labelSize == "medium",
        "label-small": this.labelSize == "small",
        [this.size]: this.size !== "medium"
      };
    },
    inputClasses() {
      return {
        "has-danger": this.styleType === "danger",
        "has-warning": this.styleType === "warning",
        "has-success": this.styleType === "success"
      };
    },
    labelClass() {
      return {
        "label-container": !this.isToggle,
        "is-vertical": this.isVertical || this.isMenuList,
        "is-read-only": this.computedIsReadOnly
      };
    },
    indicatorClass() {
      return {
        indicator: true,
        "is-read-only": this.computedIsReadOnly
      };
    },
    helperClasses() {
      return {
        "helper-large": this.labelSize == "large",
        "helper-medium": this.labelSize == "medium",
        "helper-small": this.labelSize == "small"
      };
    },
    computedIsDisabled() {
      return this.groupIsDisabled ? true : this.isDisabled;
    },
    computedIsReadOnly() {
      return this.groupIsReadOnly ? true : this.isReadOnly;
    },
    computedHasError() {
      return this.groupHasError ? true : this.hasError;
    }
  },
  methods: {
    handleClick(e) {
      this.mouseDownTargetElement != e.target && (e.preventDefault(), e.stopPropagation());
    },
    handleMouseDown(e) {
      this.mouseDownTargetElement = e.target;
    },
    handleSlotClick(e) {
      if (!this.computedIsDisabled && !this.computedIsReadOnly) {
        let t = e.target.tagName;
        if (["JAMF-RADIO-V5-9-0", "JAMF-CHECKBOX-V5-9-0", "JAMF-SWITCH-V5-9-0"].includes(t))
          return;
        if (t === "INPUT") {
          const s = e.target;
          if (s.type === "checkbox" || s.type === "radio")
            return;
        }
        e.preventDefault();
      }
    },
    handleKeyUp(e) {
      if (this.computedIsReadOnly || this.computedIsDisabled) {
        e.preventDefault();
        return;
      }
      (e.code === "Enter" || e.code === "NumpadEnter") && this.emitSubmit();
    },
    emitSubmit() {
      const i = this.$refs.checkbox.getRootNode().host.closest("form");
      if (i) {
        const l = new Event("submit", { bubbles: true, cancelable: true });
        i.dispatchEvent(l) && i.requestSubmit();
      }
    }
  },
  mounted() {
    const e = this.$refs.label.getRootNode().children;
    e.length > 2 && e[2].remove(), this.internals = this.$refs.checkbox.getRootNode().host.internals_, this.checked && this.internals && this.internals.setFormValue(this.checked);
  }
});

const a$7 = '@keyframes fadeIn-1f735a01{0%{opacity:0}to{opacity:1}}@keyframes fadeOut-1f735a01{0%{opacity:1}to{opacity:0}}@keyframes scaleIn-1f735a01{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut-1f735a01{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft-1f735a01{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop-1f735a01{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse-1f735a01{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer-1f735a01{0%{background-position:200% 0}to{background-position:-200% 0}}.checkbox[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-input-base);line-height:var(--size-font-input-height);letter-spacing:var(--size-font-input-spacing);transition-property:border,box-shadow;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;position:relative;display:flex;align-items:center;cursor:pointer;user-select:none;width:fit-content;padding-right:calc(2px * var(--size-base-spacing));max-width:100%;margin:0;padding:0}.checkbox input[type=checkbox][data-v-1f735a01],.checkbox input[type=radio][data-v-1f735a01]{opacity:0;width:0;height:0;position:absolute;cursor:pointer}.checkbox input[type=checkbox]:checked~.indicator[data-v-1f735a01]:not(.is-read-only),.checkbox input[type=radio]:checked~.indicator[data-v-1f735a01]:not(.is-read-only){background-color:var(--color-input-primary-base);border-color:var(--color-input-primary-base)}.checkbox input[type=checkbox].has-danger:checked~.indicator[data-v-1f735a01]:not(.is-read-only),.checkbox input[type=radio].has-danger:checked~.indicator[data-v-1f735a01]:not(.is-read-only){background-color:var(--color-danger-base);border-color:var(--color-danger-base)}.checkbox input[type=checkbox].has-warning:checked~.indicator[data-v-1f735a01]:not(.is-read-only),.checkbox input[type=radio].has-warning:checked~.indicator[data-v-1f735a01]:not(.is-read-only){background-color:var(--color-warning-base);border-color:var(--color-warning-base)}.checkbox input[type=checkbox].has-success:checked~.indicator[data-v-1f735a01]:not(.is-read-only),.checkbox input[type=radio].has-success:checked~.indicator[data-v-1f735a01]:not(.is-read-only){background-color:var(--color-success-base);border-color:var(--color-success-base)}.checkbox input[type=checkbox]:checked~.indicator.is-read-only[data-v-1f735a01],.checkbox input[type=radio]:checked~.indicator.is-read-only[data-v-1f735a01]{background-color:var(--color-input-readonly);border-color:var(--color-input-readonly)}.checkbox .indicator[data-v-1f735a01]{border:var(--size-border-width-base) solid var(--color-input-border-base);transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;background-color:var(--color-input-base);display:flex;align-items:center;left:0;height:var(--size-input-height-secondary)}.checkbox:hover input:not(:disabled)~.indicator[data-v-1f735a01],.checkbox:active input:not(:disabled)~.indicator[data-v-1f735a01]{border:var(--size-border-width-base) solid var(--color-input-primary-active)}.checkbox[data-v-1f735a01]:has(>input:focus){outline:none}.checkbox:has(>input:focus) input:not(:disabled)~.indicator[data-v-1f735a01]{transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}.checkbox:hover input:checked:not(:disabled)~.indicator[data-v-1f735a01],.checkbox:active input:checked:not(:disabled)~.indicator[data-v-1f735a01]{background-color:var(--color-input-primary-active)}.checkbox:hover input.has-danger:checked:not(:disabled)~.indicator[data-v-1f735a01],.checkbox:active input.has-danger:checked:not(:disabled)~.indicator[data-v-1f735a01]{background-color:var(--color-danger-active)}.checkbox:hover input.has-success:checked:not(:disabled)~.indicator[data-v-1f735a01],.checkbox:active input.has-success:checked:not(:disabled)~.indicator[data-v-1f735a01]{background-color:var(--color-success-active)}.checkbox:hover input.has-warning:checked:not(:disabled)~.indicator[data-v-1f735a01],.checkbox:active input.has-warning:checked:not(:disabled)~.indicator[data-v-1f735a01]{background-color:var(--color-warning-active)}.checkbox.is-read-only[data-v-1f735a01]{pointer-events:none}.checkbox.is-disabled[data-v-1f735a01]{opacity:var(--opacity-disabled);cursor:not-allowed}.checkbox.is-vertical[data-v-1f735a01]{align-items:flex-start}.checkbox.label-small[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-small))}.checkbox.label-medium[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-medium))}.checkbox.label-large[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-large))}.checkbox.large.toggle span[part=label][data-v-1f735a01]{height:calc(var(--size-input-height-base) + 1px * var(--size-base-spacing))}.checkbox .helper-small[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-small))}.checkbox .helper-medium[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-medium))}.checkbox .helper-large[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-large))}.checkbox.has-error .indicator[data-v-1f735a01],.has-error .checkbox .indicator[data-v-1f735a01]{border-color:var(--color-danger-base)}.checkbox input[type=checkbox]:checked~.indicator[data-v-1f735a01]:not(.svg-check):not(.is-read-only){display:flex}.checkbox input[type=checkbox]:checked~.indicator[data-v-1f735a01]:not(.svg-check):not(.is-read-only):before,.checkbox input[type=checkbox]:checked~.indicator[data-v-1f735a01]:not(.svg-check):not(.is-read-only):after{content:"";background:var(--color-input-base);height:2px;display:flex;position:relative}.checkbox input[type=checkbox]:checked~.indicator[data-v-1f735a01]:not(.svg-check):not(.is-read-only):before{transform:rotate(45deg) translate(calc(var(--size-input-height-secondary) * .14)) translateY(-1px);width:calc(var(--size-input-height-secondary) * .3);border-top-left-radius:2px;border-bottom-left-radius:2px}.checkbox input[type=checkbox]:checked~.indicator[data-v-1f735a01]:not(.svg-check):not(.is-read-only):after{transform:rotate(-45deg) translateY(-.3px);width:calc(var(--size-input-height-secondary) * .71);border-top-right-radius:2px;border-bottom-right-radius:2px;border-bottom-left-radius:2px}.checkbox input[type=checkbox]:checked~.indicator.is-read-only[data-v-1f735a01]:not(.svg-check){display:flex}.checkbox input[type=checkbox]:checked~.indicator.is-read-only[data-v-1f735a01]:not(.svg-check):before,.checkbox input[type=checkbox]:checked~.indicator.is-read-only[data-v-1f735a01]:not(.svg-check):after{content:"";background:var(--color-font-secondary);height:2px;display:flex;position:relative}.checkbox input[type=checkbox]:checked~.indicator.is-read-only[data-v-1f735a01]:not(.svg-check):before{transform:rotate(45deg) translate(calc(var(--size-input-height-secondary) * .14)) translateY(-1px);width:calc(var(--size-input-height-secondary) * .3);border-top-left-radius:2px;border-bottom-left-radius:2px}.checkbox input[type=checkbox]:checked~.indicator.is-read-only[data-v-1f735a01]:not(.svg-check):after{transform:rotate(-45deg) translateY(-.3px);width:calc(var(--size-input-height-secondary) * .71);border-top-right-radius:2px;border-bottom-right-radius:2px;border-bottom-left-radius:2px}.checkbox input[type=checkbox]:checked~.indicator.svg-check svg[data-v-1f735a01]{width:16px;color:var(--color-font-inverse)}.checkbox input[type=checkbox]:checked~.indicator[data-v-1f735a01]:after{opacity:1}.checkbox input[type=checkbox]:indeterminate~.indicator[data-v-1f735a01]:not(.is-read-only){background-color:var(--color-input-primary-base);border-color:var(--color-input-primary-base)}.checkbox input[type=checkbox]:indeterminate~.indicator[data-v-1f735a01]:not(.is-read-only):after{content:"";background:var(--color-input-base);height:2px;width:calc(var(--size-input-height-secondary) * .6);border-radius:2px;display:flex;position:relative}.checkbox input[type=checkbox]:indeterminate~.indicator.is-read-only[data-v-1f735a01]:after{content:"";background:var(--color-font-secondary);height:2px;width:calc(var(--size-input-height-secondary) * .6);border-radius:2px;display:flex;position:relative}.checkbox .indicator[data-v-1f735a01]{border-radius:var(--size-border-radius-small, var(--size-border-radius-base));height:var(--size-input-height-tertiary);min-width:var(--size-input-height-tertiary);max-height:var(--size-input-height-tertiary);max-width:var(--size-input-height-tertiary);justify-content:center;margin-right:calc(1px * var(--size-base-spacing))}.checkbox .label-container[data-v-1f735a01]{color:var(--color-font-base)}.checkbox .label-container.is-vertical[data-v-1f735a01]{display:flex;flex-direction:column}.checkbox .label-container.is-vertical[data-v-1f735a01] ::slotted([slot=description]){margin-left:0}.checkbox.menu-list[data-v-1f735a01]{display:flex;align-items:center;transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s}.toggle[data-v-1f735a01]{transition-property:border,box-shadow;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;position:relative;display:flex;align-items:center;user-select:none;width:fit-content;font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-input-base);line-height:var(--size-font-input-height);letter-spacing:var(--size-font-input-spacing);margin-right:calc(1px * var(--size-base-spacing));display:inline-block;cursor:pointer}.toggle input:not([readonly]):checked~span[data-v-1f735a01]:not(.indicator){color:var(--color-font-inverse)}.toggle span[data-v-1f735a01]:not(.indicator){position:relative;padding:0 calc(1px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);white-space:nowrap}.toggle label:not(.is-read-only) span[data-v-1f735a01]:not(.indicator){cursor:pointer}.toggle input[type=checkbox][data-v-1f735a01],.toggle input[type=radio][data-v-1f735a01]{opacity:0;width:0;height:0;position:absolute;cursor:pointer}.toggle input[type=checkbox]:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only),.toggle input[type=radio]:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only){background-color:var(--color-input-primary-base);border-color:var(--color-input-primary-base)}.toggle input[type=checkbox].has-danger:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only),.toggle input[type=radio].has-danger:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only){background-color:var(--color-danger-base);border-color:var(--color-danger-base)}.toggle input[type=checkbox].has-warning:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only),.toggle input[type=radio].has-warning:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only){background-color:var(--color-warning-base);border-color:var(--color-warning-base)}.toggle input[type=checkbox].has-success:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only),.toggle input[type=radio].has-success:checked~span[data-v-1f735a01]:not(.indicator):not(.is-read-only){background-color:var(--color-success-base);border-color:var(--color-success-base)}.toggle input[type=checkbox]:checked~span:not(.indicator).is-read-only[data-v-1f735a01],.toggle input[type=radio]:checked~span:not(.indicator).is-read-only[data-v-1f735a01]{background-color:var(--color-input-readonly);border-color:var(--color-input-readonly)}.toggle span[data-v-1f735a01]:not(.indicator){border:var(--size-border-width-base) solid var(--color-input-border-base);transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;background-color:var(--color-input-base);display:flex;align-items:center;left:0;height:var(--size-input-height-secondary)}.toggle:hover input:not(:disabled)~span[data-v-1f735a01]:not(.indicator),.toggle:active input:not(:disabled)~span[data-v-1f735a01]:not(.indicator){border:var(--size-border-width-base) solid var(--color-input-primary-active)}.toggle[data-v-1f735a01]:has(>input:focus){outline:none}.toggle:has(>input:focus) input:not(:disabled)~span[data-v-1f735a01]:not(.indicator){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}.toggle:hover input:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator),.toggle:active input:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator){background-color:var(--color-input-primary-active)}.toggle:hover input.has-danger:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator),.toggle:active input.has-danger:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator){background-color:var(--color-danger-active)}.toggle:hover input.has-success:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator),.toggle:active input.has-success:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator){background-color:var(--color-success-active)}.toggle:hover input.has-warning:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator),.toggle:active input.has-warning:checked:not(:disabled)~span[data-v-1f735a01]:not(.indicator){background-color:var(--color-warning-active)}.toggle.is-read-only[data-v-1f735a01]{pointer-events:none}.toggle.is-disabled[data-v-1f735a01]{opacity:var(--opacity-disabled);cursor:not-allowed}.toggle.is-vertical[data-v-1f735a01]{align-items:flex-start}.toggle.label-small[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-small))}.toggle.label-medium[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-medium))}.toggle.label-large[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-large))}.toggle.large.toggle span[part=label][data-v-1f735a01]{height:calc(var(--size-input-height-base) + 1px * var(--size-base-spacing))}.toggle .helper-small[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-small))}.toggle .helper-medium[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-medium))}.toggle .helper-large[data-v-1f735a01]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-large))}.toggle.has-error span[data-v-1f735a01]:not(.indicator){border-color:var(--color-danger-base)}.has-error .toggle span[data-v-1f735a01]:not(.indicator){border-color:var(--color-danger-base)}.toggle span[data-v-1f735a01]:not(.indicator){position:relative;padding:0 calc(1px * var(--size-base-spacing));white-space:nowrap;border-radius:var(--size-border-radius-input)}[data-v-1f735a01]::slotted([slot=description]){margin-left:calc(1px * var(--size-base-spacing));font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-medium))}.helper-small[data-v-1f735a01]::slotted([slot=description]){font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-small))}.helper-large[data-v-1f735a01]::slotted([slot=description]){font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-large))}.menu-list[data-v-1f735a01]{border-radius:var(--size-border-radius-base);border:var(--size-border-width-base) solid var(--color-border-base);width:100%;height:100%;box-sizing:border-box;padding:calc(2px * var(--size-base-spacing));align-items:stretch;border:var(--size-border-width-base) solid var(--color-checkbox-menu-list-border, var(--color-border-base))}.menu-list[data-v-1f735a01]:hover:not([readonly]):not(.is-disabled){box-shadow:var(--size-shadow-action) var(--color-shadow-base)}.menu-list.active[data-v-1f735a01]{border-color:var(--color-checkbox-menu-list-border-active, var(--color-border-base))}.menu-list .label-container[data-v-1f735a01]{margin-left:calc(1px * var(--size-base-spacing));padding-left:calc(2px * var(--size-base-spacing))}.slot-container[data-v-1f735a01]{display:flex;align-items:stretch;justify-content:space-between;align-items:center;width:100%}.checkbox-content[data-v-1f735a01]{flex:1;display:flex;min-width:0;flex-direction:column;align-items:flex-start}.trailing-content-container[data-v-1f735a01]{display:flex}.divider[data-v-1f735a01]{width:var(--size-border-width-base);align-self:stretch;background:var(--color-border-base);margin:0 calc(1px * var(--size-base-spacing))}.trailing[data-v-1f735a01]::slotted(*){margin-left:0}.menu-list-checked[data-v-1f735a01]{background:linear-gradient(to right,var(--color-primary-subdued) 0%,var(--color-primary-subdued) calc(7px * var(--size-base-spacing)),var(--color-structure-base) calc(7px * var(--size-base-spacing)),var(--color-structure-base) 100%);background-origin:border-box}.menu-list-not-checked[data-v-1f735a01]{background:linear-gradient(to right,var(--color-structure-secondary) 0%,var(--color-structure-secondary) calc(7px * var(--size-base-spacing)),var(--color-structure-base) calc(7px * var(--size-base-spacing)),var(--color-structure-base) 100%);background-origin:border-box}[data-v-1f735a01]::slotted(*){color:var(--color-font-base)}.descenders-container[data-v-1f735a01]::slotted(*){margin-top:calc(1px * var(--size-base-spacing))}.is-read-only .indicator[data-v-1f735a01]{background:var(--color-input-readonly);border-color:var(--color-border-base)}.is-read-only .indicator[data-v-1f735a01]:before{background:var(--color-font-secondary)}.is-read-only .indicator[data-v-1f735a01]:after{background:var(--color-font-secondary)}';

const v$3 = ["tabindex", "name", ".indeterminate", "disabled", "readonly", "value", "data-wa", "data-wa-id", "checked"], b$3 = {
  key: 1,
  class: "slot-container",
  part: "slot-container"
}, f$a = { class: "checkbox-content" }, w$4 = { class: "trailing-content-container" }, y$4 = { class: "trailing-content" };
function $$4(e, s, c, h, M, D) {
  return openBlock(), createElementBlock("label", {
    ref: "label",
    class: normalizeClass(e.classes),
    part: "container",
    onMousedown: s[6] || (s[6] = (...l) => e.handleMouseDown && e.handleMouseDown(...l)),
    onClick: s[7] || (s[7] = (...l) => e.handleClick && e.handleClick(...l))
  }, [
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (l) => e.computedValue = l),
      tabindex: e.computedIsDisabled ? -1 : 0,
      type: "checkbox",
      ref: "checkbox",
      name: e.name,
      ".indeterminate": e.indeterminate,
      disabled: e.computedIsDisabled,
      readonly: e.computedIsReadOnly,
      value: e.value,
      "data-wa": e.waComponent,
      "data-wa-id": e.waId,
      class: normalizeClass(e.inputClasses),
      part: "input",
      checked: e.checked,
      onClick: s[1] || (s[1] = withModifiers(() => {
      }, ["stop"])),
      onKeyup: s[2] || (s[2] = (...l) => e.handleKeyUp && e.handleKeyUp(...l))
    }, null, 42, v$3), [
      [vModelCheckbox, e.computedValue]
    ]),
    createBaseVNode("span", {
      class: normalizeClass(e.indicatorClass),
      part: "indicator"
    }, null, 2),
    e.isMenuList ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(e.labelClass),
      part: "label"
    }, [
      renderSlot(e.$slots, "default", {}, void 0, true),
      renderSlot(e.$slots, "description", {}, void 0, true),
      renderSlot(e.$slots, "descenders", {
        class: "descenders-container",
        onClickCapture: s[3] || (s[3] = (l) => e.handleSlotClick(l))
      }, void 0, true)
    ], 2)),
    e.isMenuList ? (openBlock(), createElementBlock("div", b$3, [
      createBaseVNode("div", f$a, [
        createBaseVNode("span", {
          class: normalizeClass(e.labelClass),
          part: "label"
        }, [
          renderSlot(e.$slots, "default", {}, void 0, true),
          renderSlot(e.$slots, "description", {
            class: normalizeClass(e.helperClasses)
          }, void 0, true),
          renderSlot(e.$slots, "descenders", {
            class: "descenders-container",
            onClickCapture: s[4] || (s[4] = (l) => e.handleSlotClick(l))
          }, void 0, true)
        ], 2)
      ]),
      createBaseVNode("div", w$4, [
        s[8] || (s[8] = createBaseVNode("div", {
          class: "divider",
          part: "divider"
        }, null, -1)),
        createBaseVNode("div", y$4, [
          renderSlot(e.$slots, "trailing", {
            class: "trailing",
            onClickCapture: s[5] || (s[5] = (l) => e.handleSlotClick(l))
          }, void 0, true)
        ])
      ])
    ])) : createCommentVNode("", true)
  ], 34);
}
const K$2 = /* @__PURE__ */ s$6(n$4, [["render", $$4], ["styles", [a$7]], ["__scopeId", "data-v-1f735a01"]]);

const c$4 = r$9(K$2), h$3 = Object.keys(K$2.props);
let t$2 = class t extends c$4 {
  static {
    this.formAssociated = true;
  }
  constructor() {
    super(), this.internals_ = this.attachInternals();
  }
};
const a$6 = t$2.prototype.attachShadow;
t$2.prototype.attachShadow = function(e) {
  return a$6.apply(this, [{ ...e, delegatesFocus: true }]);
};
(function() {
  customElements.get("jamf-checkbox-v5-9-0") === void 0 && customElements.define("jamf-checkbox-v5-9-0", t$2);
})();

const { wrap: m$5 } = V$1(React), f$9 = m$5(c$4, {
  name: "jamf-checkbox-v5-9-0",
  properties: [...h$3],
  events: {
    onChange: "change"
  }
});

const skeleton = "_skeleton_hyd73_1";
const skeletonLoading = "_skeleton-loading_hyd73_1";
const card = "_card_hyd73_6";
const input = "_input_hyd73_10";
const inputLabel = "_input-label_hyd73_15";
const p$3 = "_p_hyd73_20";
const h1 = "_h1_hyd73_25";
const menuListItem = "_menu-list-item_hyd73_30";
const styles$1 = {
	skeleton: skeleton,
	skeletonLoading: skeletonLoading,
	card: card,
	input: input,
	inputLabel: inputLabel,
	p: p$3,
	h1: h1,
	menuListItem: menuListItem
};

function SkeletonLoading({ type, width }) {
  return /* @__PURE__ */ React.createElement("div", { className: `${styles$1.skeleton} ${styles$1[type] ?? ""}`, style: { width } });
}

function useGroups(type, nameFilter) {
  const featureServices = useFeatureServices();
  const { getSmartGroups, getStaticGroups, getAllGroups } = featureServices["jamf:groups_service"];
  return useInfiniteQuery({
    queryKey: ["groups", { type, nameFilter }],
    queryFn({ queryKey, pageParam }) {
      const params = queryKey[1];
      const fnMap = {
        all: getAllGroups,
        smart: getSmartGroups,
        static: getStaticGroups
      };
      return fnMap[params.type]({
        page: pageParam,
        pageSize: 10,
        name: params.nameFilter
      });
    },
    getNextPageParam(lastPage, allPages) {
      const loadedItemsLength = allPages.reduce((totalCount, page) => totalCount + page.results.length, 0);
      if (lastPage.totalCount <= loadedItemsLength) {
        return void 0;
      }
      return allPages.length;
    },
    initialPageParam: 0,
    placeholderData: keepPreviousData
  });
}

const groupsWrapper = "_groups-wrapper_k7oyv_1";
const noGroups = "_no-groups_k7oyv_4";
const loadMore = "_load-more_k7oyv_10";
const groups = "_groups_k7oyv_1";
const styles = {
	groupsWrapper: groupsWrapper,
	noGroups: noGroups,
	loadMore: loadMore,
	groups: groups
};

function GroupCheckboxList({ type, filter, isScopeLoading, isReadOnly }) {
  const { t } = scoping__loadShare__react_mf_2_i18next__loadShare__.useTranslation("app");
  const groupsQuery = useGroups(type, filter);
  const groups = groupsQuery.data?.pages.flatMap(({ results }) => results) ?? [];
  if (groupsQuery.isLoadingError) {
    return /* @__PURE__ */ React.createElement("div", { className: styles.groupsWrapper }, /* @__PURE__ */ React.createElement(
      f$b,
      {
        styleType: "danger",
        withIcon: true,
        actionLabel: t("group_list__error_banner__action_label"),
        onAction: () => {
          groupsQuery.refetch();
        }
      },
      /* @__PURE__ */ React.createElement("span", { slot: "title" }, t("group_list__error_banner__title"))
    ));
  }
  if (groupsQuery.isLoading || isScopeLoading) {
    return /* @__PURE__ */ React.createElement("div", { className: styles.groupsWrapper }, /* @__PURE__ */ React.createElement("div", { className: styles.groups }, /* @__PURE__ */ React.createElement(SkeletonLoading, { type: "menuListItem" }), /* @__PURE__ */ React.createElement(SkeletonLoading, { type: "menuListItem" }), /* @__PURE__ */ React.createElement(SkeletonLoading, { type: "menuListItem" })));
  }
  return /* @__PURE__ */ React.createElement("div", { className: styles.groupsWrapper }, groups.length === 0 && /* @__PURE__ */ React.createElement("div", { className: styles.noGroups }, /* @__PURE__ */ React.createElement("h4", null, t("group_list__empty__title")), /* @__PURE__ */ React.createElement("p", null, t("group_list__empty__description"))), /* @__PURE__ */ React.createElement("div", { className: styles.groups }, groups.map(({ groupName, groupId }) => {
    return /* @__PURE__ */ React.createElement(f$9, { key: groupId, value: groupId, isMenuList: true, isReadOnly }, groupName);
  })), /* @__PURE__ */ React.createElement("div", { className: styles.loadMore }, groupsQuery.hasNextPage && /* @__PURE__ */ React.createElement(
    f$e,
    {
      styleType: "link",
      onClick: () => groupsQuery.fetchNextPage(),
      isDisabled: groupsQuery.isFetchingNextPage,
      isLoading: groupsQuery.isFetchingNextPage
    },
    t("group_list__load_more__link")
  )));
}

const n$3 = r$9(g$3), c$3 = Object.keys(g$3.props); (function() {
  customElements.get("jamf-icon-v5-9-0") === void 0 && customElements.define("jamf-icon-v5-9-0", n$3);
})();

const { wrap: p$2 } = V$1(React), f$8 = p$2(n$3, {
  name: "jamf-icon-v5-9-0",
  properties: [...c$3]
});

const n$2 = defineComponent({
  name: "JamfInputGroup",
  props: {
    /** Used to make the input accessible, should be unique on the page */
    id: String,
    /** Optional text to display for the label */
    label: String,
    /** Optional text to display alongide the field label as context for the user */
    helperText: String,
    /** The text to display below the field to indicate it simple information */
    descenderText: String,
    /** Sets size for label and helper text */
    labelSize: {
      type: String,
      default: "medium"
    },
    /** Sets size of input */
    size: {
      type: String,
      default: "medium"
    },
    /** Boolean value for the error state */
    hasError: Boolean,
    /** Boolean value for the warning state */
    hasWarning: Boolean,
    /** Boolean value for the success state */
    hasSuccess: Boolean,
    /** Error text to display when an error has occured via `hasError` */
    errorText: String,
    /** Warning text to display when an error has occured via `hasError` */
    warningText: String,
    /** Success text to display when an error has occured via `hasError` */
    successText: String,
    /** Boolean value for the enabled state */
    isDisabled: Boolean,
    /** Aligns any provided helper text underneath the label instead of beside it */
    isVertical: Boolean,
    /** Inlines any slotted inputs */
    isInline: Boolean,
    /** Boolean value for the readonly state */
    isReadOnly: Boolean,
    /** Optional prop to set the groups role */
    role: String,
    /** Compact layout spacing */
    isCompact: Boolean,
    /** Sets maximum number of characters in text area.  Count displays as user types. */
    maxLength: Number,
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula--input-group"
    },
    /** Optional component identifier that can be set as a unique value on a page for web analytics targeting. */
    waId: String
  },
  computed: {
    classes() {
      return {
        container: true,
        "is-vertical": this.isVertical,
        "has-error": this.hasError,
        "has-warning": this.hasWarning && !this.hasError,
        "has-success": this.hasSuccess && !this.hasWarning && !this.hasError,
        "is-disabled": this.isDisabled,
        "is-inline": this.isInline,
        compact: this.isCompact,
        [this.size]: this.size !== "medium"
      };
    },
    disabled() {
      return this.isDisabled || this.isReadOnly;
    },
    includeDescenders() {
      return !!this.errorText && this.hasError || !!this.warningText && this.hasWarning || !!this.successText && this.hasSuccess || !!this.descenderText || !!this.maxLength || this.hasDescenderSlotContent;
    },
    hasDescenderSlotContent() {
      return this.$slots.descenders ? typeof this.$slots.descenders()?.[0].children != "string" : false;
    },
    includeLabels() {
      return this.label || this.helperText || !!this.$slots.label;
    },
    helperTextID() {
      return this.id ? `helper-text-${this.id}` : "";
    },
    assistiveText() {
      return {
        "error-text": { value: this.hasError, text: this.errorText },
        "warning-text": {
          value: this.hasWarning && !this.hasError,
          text: this.warningText
        },
        "success-text": {
          value: this.hasSuccess && !this.hasWarning && !this.hasError,
          text: this.successText
        },
        "descender-text": {
          value: this.descenderText && !this.hasWarning && !this.hasError && !this.hasSuccess,
          text: this.descenderText
        }
      };
    },
    ariaDescribedById() {
      if (this.id) {
        const e = Object.entries(this.assistiveText).filter(([s, { value: t }]) => t).map(([s]) => `${s}-${this.id}`);
        return e.push(this.helperTextID), e.join(" ");
      }
      return "";
    },
    sizeLabel() {
      return {
        "label-text": true,
        [this.labelSize]: true
      };
    },
    sizeHelperText() {
      return {
        "helper-text": true,
        [this.labelSize]: true
      };
    }
  }
});

const b$2 = ["role", "data-wa", "data-wa-id"], f$7 = {
  key: 0,
  class: "label-container",
  part: "label-container"
}, $$3 = ["for"], g$2 = ["id"], w$3 = {
  class: "input-group",
  part: "slot-container"
}, S$3 = {
  key: 1,
  class: "input-descenders",
  part: "input-descenders"
}, v$2 = ["id"];
function D$1(e, I, y, B, T, k) {
  return openBlock(), createElementBlock("div", {
    role: e.role,
    class: normalizeClass(e.classes),
    "data-wa": e.waComponent,
    "data-wa-id": e.waId
  }, [
    e.includeLabels ? (openBlock(), createElementBlock("div", f$7, [
      e.label ? (openBlock(), createElementBlock("label", {
        key: 0,
        for: e.id,
        class: normalizeClass(e.sizeLabel),
        part: "label"
      }, toDisplayString(e.label), 11, $$3)) : createCommentVNode("", true),
      createBaseVNode("small", {
        id: e.helperTextID,
        class: normalizeClass(["helper-text", e.sizeHelperText]),
        part: "helper-text"
      }, toDisplayString(e.helperText), 11, g$2),
      renderSlot(e.$slots, "label")
    ])) : createCommentVNode("", true),
    createBaseVNode("div", w$3, [
      renderSlot(e.$slots, "default", { ariaDescribedById: e.ariaDescribedById })
    ]),
    e.includeDescenders ? (openBlock(), createElementBlock("div", S$3, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.assistiveText, ({ value: p, text: c }, t) => (openBlock(), createElementBlock(Fragment, null, [
        p && String(t) !== "helper-text" ? (openBlock(), createElementBlock("small", {
          part: "descender-text",
          id: `${String(t)}-${e.id}`,
          key: String(t),
          class: normalizeClass(String(t))
        }, toDisplayString(c), 11, v$2)) : createCommentVNode("", true)
      ], 64))), 256)),
      renderSlot(e.$slots, "descenders")
    ])) : createCommentVNode("", true)
  ], 10, b$2);
}
const _$1 = /* @__PURE__ */ s$6(n$2, [["render", D$1]]);

const l$1 = Math.min, a$5 = Math.max, P$1 = Math.round, O$1 = (t) => ({
  x: t,
  y: t
}), m$4 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, p$1 = {
  start: "end",
  end: "start"
};
function S$2(t, n, o) {
  return a$5(t, l$1(n, o));
}
function w$2(t, n) {
  return typeof t == "function" ? t(n) : t;
}
function f$6(t) {
  return t.split("-")[0];
}
function g$1(t) {
  return t.split("-")[1];
}
function h$2(t) {
  return t === "x" ? "y" : "x";
}
function x(t) {
  return t === "y" ? "height" : "width";
}
function b$1(t) {
  return ["top", "bottom"].includes(f$6(t)) ? "y" : "x";
}
function d$1(t) {
  return h$2(b$1(t));
}
function j$1(t, n, o) {
  o === void 0 && (o = false);
  const s = g$1(t), i = d$1(t), e = x(i);
  let r = i === "x" ? s === (o ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return n.reference[e] > n.floating[e] && (r = u$2(r)), [r, u$2(r)];
}
function C$2(t) {
  const n = u$2(t);
  return [c$2(t), n, c$2(n)];
}
function c$2(t) {
  return t.replace(/start|end/g, (n) => p$1[n]);
}
function A(t, n, o) {
  const s = ["left", "right"], i = ["right", "left"], e = ["top", "bottom"], r = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return o ? n ? i : s : n ? s : i;
    case "left":
    case "right":
      return n ? e : r;
    default:
      return [];
  }
}
function L$2(t, n, o, s) {
  const i = g$1(t);
  let e = A(f$6(t), o === "start", s);
  return i && (e = e.map((r) => r + "-" + i), n && (e = e.concat(e.map(c$2)))), e;
}
function u$2(t) {
  return t.replace(/left|right|bottom|top/g, (n) => m$4[n]);
}
function y$3(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function E$3(t) {
  return typeof t != "number" ? y$3(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function R(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  };
}

function z$1(l, o, d) {
  let {
    reference: i,
    floating: a
  } = l;
  const e = b$1(o), c = d$1(o), s = x(c), n = f$6(o), g = e === "y", u = i.x + i.width / 2 - a.width / 2, f = i.y + i.height / 2 - a.height / 2, m = i[s] / 2 - a[s] / 2;
  let t;
  switch (n) {
    case "top":
      t = {
        x: u,
        y: i.y - a.height
      };
      break;
    case "bottom":
      t = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      t = {
        x: i.x + i.width,
        y: f
      };
      break;
    case "left":
      t = {
        x: i.x - a.width,
        y: f
      };
      break;
    default:
      t = {
        x: i.x,
        y: i.y
      };
  }
  switch (g$1(o)) {
    case "start":
      t[c] -= m * (d && g ? -1 : 1);
      break;
    case "end":
      t[c] += m * (d && g ? -1 : 1);
      break;
  }
  return t;
}
const tt = async (l, o, d) => {
  const {
    placement: i = "bottom",
    strategy: a = "absolute",
    middleware: e = [],
    platform: c
  } = d, s = e.filter(Boolean), n = await (c.isRTL == null ? void 0 : c.isRTL(o));
  let g = await c.getElementRects({
    reference: l,
    floating: o,
    strategy: a
  }), {
    x: u,
    y: f
  } = z$1(g, i, n), m = i, t = {}, r = 0;
  for (let w = 0; w < s.length; w++) {
    const {
      name: v,
      fn: b
    } = s[w], {
      x: A,
      y: p,
      data: y,
      reset: x
    } = await b({
      x: u,
      y: f,
      initialPlacement: i,
      placement: m,
      strategy: a,
      middlewareData: t,
      rects: g,
      platform: c,
      elements: {
        reference: l,
        floating: o
      }
    });
    u = A ?? u, f = p ?? f, t = {
      ...t,
      [v]: {
        ...t[v],
        ...y
      }
    }, x && r <= 50 && (r++, typeof x == "object" && (x.placement && (m = x.placement), x.rects && (g = x.rects === true ? await c.getElementRects({
      reference: l,
      floating: o,
      strategy: a
    }) : x.rects), {
      x: u,
      y: f
    } = z$1(g, m, n)), w = -1);
  }
  return {
    x: u,
    y: f,
    placement: m,
    strategy: a,
    middlewareData: t
  };
};
async function I$1(l, o) {
  var d;
  o === void 0 && (o = {});
  const {
    x: i,
    y: a,
    platform: e,
    rects: c,
    elements: s,
    strategy: n
  } = l, {
    boundary: g = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: f = "floating",
    altBoundary: m = false,
    padding: t = 0
  } = w$2(o, l), r = E$3(t), v = s[m ? f === "floating" ? "reference" : "floating" : f], b = R(await e.getClippingRect({
    element: (d = await (e.isElement == null ? void 0 : e.isElement(v))) == null || d ? v : v.contextElement || await (e.getDocumentElement == null ? void 0 : e.getDocumentElement(s.floating)),
    boundary: g,
    rootBoundary: u,
    strategy: n
  })), A = f === "floating" ? {
    ...c.floating,
    x: i,
    y: a
  } : c.reference, p = await (e.getOffsetParent == null ? void 0 : e.getOffsetParent(s.floating)), y = await (e.isElement == null ? void 0 : e.isElement(p)) ? await (e.getScale == null ? void 0 : e.getScale(p)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = R(e.convertOffsetParentRelativeRectToViewportRelativeRect ? await e.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: A,
    offsetParent: p,
    strategy: n
  }) : A);
  return {
    top: (b.top - x.top + r.top) / y.y,
    bottom: (x.bottom - b.bottom + r.bottom) / y.y,
    left: (b.left - x.left + r.left) / y.x,
    right: (x.right - b.right + r.right) / y.x
  };
}
const et = (l) => ({
  name: "arrow",
  options: l,
  async fn(o) {
    const {
      x: d,
      y: i,
      placement: a,
      rects: e,
      platform: c,
      elements: s,
      middlewareData: n
    } = o, {
      element: g,
      padding: u = 0
    } = w$2(l, o) || {};
    if (g == null)
      return {};
    const f = E$3(u), m = {
      x: d,
      y: i
    }, t = d$1(a), r = x(t), w = await c.getDimensions(g), v = t === "y", b = v ? "top" : "left", A = v ? "bottom" : "right", p = v ? "clientHeight" : "clientWidth", y = e.reference[r] + e.reference[t] - m[t] - e.floating[r], x$1 = m[t] - e.reference[t], h = await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(g));
    let P = h ? h[p] : 0;
    (!P || !await (c.isElement == null ? void 0 : c.isElement(h))) && (P = s.floating[p] || e.floating[r]);
    const D = y / 2 - x$1 / 2, T = P / 2 - w[r] / 2 - 1, L = l$1(f[b], T), M = l$1(f[A], T), O = L, V = P - w[r] - M, R = P / 2 - w[r] / 2 + D, k = S$2(O, R, V), C = !n.arrow && g$1(a) != null && R !== k && e.reference[r] / 2 - (R < O ? L : M) - w[r] / 2 < 0, E = C ? R < O ? R - O : R - V : 0;
    return {
      [t]: m[t] + E,
      data: {
        [t]: k,
        centerOffset: R - k - E,
        ...C && {
          alignmentOffset: E
        }
      },
      reset: C
    };
  }
}), nt = function(l) {
  return l === void 0 && (l = {}), {
    name: "flip",
    options: l,
    async fn(o) {
      var d, i;
      const {
        placement: a,
        middlewareData: e,
        rects: c,
        initialPlacement: s,
        platform: n,
        elements: g
      } = o, {
        mainAxis: u = true,
        crossAxis: f = true,
        fallbackPlacements: m,
        fallbackStrategy: t = "bestFit",
        fallbackAxisSideDirection: r = "none",
        flipAlignment: w = true,
        ...v
      } = w$2(l, o);
      if ((d = e.arrow) != null && d.alignmentOffset)
        return {};
      const b = f$6(a), A = f$6(s) === s, p = await (n.isRTL == null ? void 0 : n.isRTL(g.floating)), y = m || (A || !w ? [u$2(s)] : C$2(s));
      !m && r !== "none" && y.push(...L$2(s, w, r, p));
      const x = [s, ...y], h = await I$1(o, v), P = [];
      let D = ((i = e.flip) == null ? void 0 : i.overflows) || [];
      if (u && P.push(h[b]), f) {
        const O = j$1(a, c, p);
        P.push(h[O[0]], h[O[1]]);
      }
      if (D = [...D, {
        placement: a,
        overflows: P
      }], !P.every((O) => O <= 0)) {
        var T, L;
        const O = (((T = e.flip) == null ? void 0 : T.index) || 0) + 1, V = x[O];
        if (V)
          return {
            data: {
              index: O,
              overflows: D
            },
            reset: {
              placement: V
            }
          };
        let R = (L = D.filter((k) => k.overflows[0] <= 0).sort((k, C) => k.overflows[1] - C.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!R)
          switch (t) {
            case "bestFit": {
              var M;
              const k = (M = D.map((C) => [C.placement, C.overflows.filter((E) => E > 0).reduce((E, q) => E + q, 0)]).sort((C, E) => C[1] - E[1])[0]) == null ? void 0 : M[0];
              k && (R = k);
              break;
            }
            case "initialPlacement":
              R = s;
              break;
          }
        if (a !== R)
          return {
            reset: {
              placement: R
            }
          };
      }
      return {};
    }
  };
};
async function U(l, o) {
  const {
    placement: d,
    platform: i,
    elements: a
  } = l, e = await (i.isRTL == null ? void 0 : i.isRTL(a.floating)), c = f$6(d), s = g$1(d), n = b$1(d) === "y", g = ["left", "top"].includes(c) ? -1 : 1, u = e && n ? -1 : 1, f = w$2(o, l);
  let {
    mainAxis: m,
    crossAxis: t,
    alignmentAxis: r
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...f
  };
  return s && typeof r == "number" && (t = s === "end" ? r * -1 : r), n ? {
    x: t * u,
    y: m * g
  } : {
    x: m * g,
    y: t * u
  };
}
const it = function(l) {
  return {
    name: "offset",
    options: l,
    async fn(o) {
      var d, i;
      const {
        x: a,
        y: e,
        placement: c,
        middlewareData: s
      } = o, n = await U(o, l);
      return c === ((d = s.offset) == null ? void 0 : d.placement) && (i = s.arrow) != null && i.alignmentOffset ? {} : {
        x: a + n.x,
        y: e + n.y,
        data: {
          ...n,
          placement: c
        }
      };
    }
  };
};

function l(n) {
  return a$4(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function i$1(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function y$2(n) {
  var t;
  return (t = (a$4(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
function a$4(n) {
  return n instanceof Node || n instanceof i$1(n).Node;
}
function S$1(n) {
  return n instanceof Element || n instanceof i$1(n).Element;
}
function d(n) {
  return n instanceof HTMLElement || n instanceof i$1(n).HTMLElement;
}
function s$1(n) {
  return typeof ShadowRoot > "u" ? false : n instanceof ShadowRoot || n instanceof i$1(n).ShadowRoot;
}
function m$3(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: o,
    display: r
  } = p(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + e) && !["inline", "contents"].includes(r);
}
function E$2(n) {
  return ["table", "td", "th"].includes(l(n));
}
function N$1(n) {
  const t = h$1(), e = p(n);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : false) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : false) || !t && (e.filter ? e.filter !== "none" : false) || ["transform", "perspective", "filter"].some((o) => (e.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (e.contain || "").includes(o));
}
function T(n) {
  let t = u$1(n);
  for (; d(t) && !w$1(t); ) {
    if (N$1(t))
      return t;
    t = u$1(t);
  }
  return null;
}
function h$1() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function w$1(n) {
  return ["html", "body", "#document"].includes(l(n));
}
function p(n) {
  return i$1(n).getComputedStyle(n);
}
function C$1(n) {
  return S$1(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.pageXOffset,
    scrollTop: n.pageYOffset
  };
}
function u$1(n) {
  if (l(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    s$1(n) && n.host || // Fallback.
    y$2(n)
  );
  return s$1(t) ? t.host : t;
}
function g(n) {
  const t = u$1(n);
  return w$1(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : d(t) && m$3(t) ? t : g(t);
}
function f$5(n, t, e) {
  var o;
  t === void 0 && (t = []), e === void 0 && (e = true);
  const r = g(n), b = r === ((o = n.ownerDocument) == null ? void 0 : o.body), c = i$1(r);
  return b ? t.concat(c, c.visualViewport || [], m$3(r) ? r : [], c.frameElement && e ? f$5(c.frameElement) : []) : t.concat(r, f$5(r, [], e));
}

function j(t) {
  const e = p(t);
  let n = parseFloat(e.width) || 0, o = parseFloat(e.height) || 0;
  const s = d(t), c = s ? t.offsetWidth : n, i = s ? t.offsetHeight : o, r = P$1(n) !== c || P$1(o) !== i;
  return r && (n = c, o = i), {
    width: n,
    height: o,
    $: r
  };
}
function $$2(t) {
  return S$1(t) ? t : t.contextElement;
}
function F(t) {
  const e = $$2(t);
  if (!d(e))
    return O$1(1);
  const n = e.getBoundingClientRect(), {
    width: o,
    height: s,
    $: c
  } = j(e);
  let i = (c ? P$1(n.width) : n.width) / o, r = (c ? P$1(n.height) : n.height) / s;
  return (!i || !Number.isFinite(i)) && (i = 1), (!r || !Number.isFinite(r)) && (r = 1), {
    x: i,
    y: r
  };
}
const st = /* @__PURE__ */ O$1(0);
function G$2(t) {
  const e = i$1(t);
  return !h$1() || !e.visualViewport ? st : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function rt(t, e, n) {
  return e === void 0 && (e = false), !n || e && n !== i$1(t) ? false : e;
}
function L$1(t, e, n, o) {
  e === void 0 && (e = false), n === void 0 && (n = false);
  const s = t.getBoundingClientRect(), c = $$2(t);
  let i = O$1(1);
  e && (o ? S$1(o) && (i = F(o)) : i = F(t));
  const r = rt(c, n, o) ? G$2(c) : O$1(0);
  let l = (s.left + r.x) / i.x, f = (s.top + r.y) / i.y, u = s.width / i.x, a = s.height / i.y;
  if (c) {
    const w = i$1(c), g = o && S$1(o) ? i$1(o) : o;
    let v = w, h = v.frameElement;
    for (; h && o && g !== v; ) {
      const p$1 = F(h), d = h.getBoundingClientRect(), m = p(h), O = d.left + (h.clientLeft + parseFloat(m.paddingLeft)) * p$1.x, B = d.top + (h.clientTop + parseFloat(m.paddingTop)) * p$1.y;
      l *= p$1.x, f *= p$1.y, u *= p$1.x, a *= p$1.y, l += O, f += B, v = i$1(h), h = v.frameElement;
    }
  }
  return R({
    width: u,
    height: a,
    x: l,
    y: f
  });
}
const ct = [":popover-open", ":modal"];
function J$1(t) {
  return ct.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return false;
    }
  });
}
function lt(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: o,
    strategy: s
  } = t;
  const c = s === "fixed", i = y$2(o), r = e ? J$1(e.floating) : false;
  if (o === i || r && c)
    return n;
  let l$1 = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = O$1(1);
  const u = O$1(0), a = d(o);
  if ((a || !a && !c) && ((l(o) !== "body" || m$3(i)) && (l$1 = C$1(o)), d(o))) {
    const w = L$1(o);
    f = F(o), u.x = w.x + o.clientLeft, u.y = w.y + o.clientTop;
  }
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - l$1.scrollLeft * f.x + u.x,
    y: n.y * f.y - l$1.scrollTop * f.y + u.y
  };
}
function ft(t) {
  return Array.from(t.getClientRects());
}
function Q(t) {
  return L$1(y$2(t)).left + C$1(t).scrollLeft;
}
function ut(t) {
  const e = y$2(t), n = C$1(t), o = t.ownerDocument.body, s = a$5(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth), c = a$5(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
  let i = -n.scrollLeft + Q(t);
  const r = -n.scrollTop;
  return p(o).direction === "rtl" && (i += a$5(e.clientWidth, o.clientWidth) - s), {
    width: s,
    height: c,
    x: i,
    y: r
  };
}
function at(t, e) {
  const n = i$1(t), o = y$2(t), s = n.visualViewport;
  let c = o.clientWidth, i = o.clientHeight, r = 0, l = 0;
  if (s) {
    c = s.width, i = s.height;
    const f = h$1();
    (!f || f && e === "fixed") && (r = s.offsetLeft, l = s.offsetTop);
  }
  return {
    width: c,
    height: i,
    x: r,
    y: l
  };
}
function ht(t, e) {
  const n = L$1(t, true, e === "fixed"), o = n.top + t.clientTop, s = n.left + t.clientLeft, c = d(t) ? F(t) : O$1(1), i = t.clientWidth * c.x, r = t.clientHeight * c.y, l = s * c.x, f = o * c.y;
  return {
    width: i,
    height: r,
    x: l,
    y: f
  };
}
function _(t, e, n) {
  let o;
  if (e === "viewport")
    o = at(t, n);
  else if (e === "document")
    o = ut(y$2(t));
  else if (S$1(e))
    o = ht(e, n);
  else {
    const s = G$2(t);
    o = {
      ...e,
      x: e.x - s.x,
      y: e.y - s.y
    };
  }
  return R(o);
}
function Y(t, e) {
  const n = u$1(t);
  return n === e || !S$1(n) || w$1(n) ? false : p(n).position === "fixed" || Y(n, e);
}
function dt(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let o = f$5(t, [], false).filter((r) => S$1(r) && l(r) !== "body"), s = null;
  const c = p(t).position === "fixed";
  let i = c ? u$1(t) : t;
  for (; S$1(i) && !w$1(i); ) {
    const r = p(i), l = N$1(i);
    !l && r.position === "fixed" && (s = null), (c ? !l && !s : !l && r.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || m$3(i) && !l && Y(t, i)) ? o = o.filter((u) => u !== i) : s = r, i = u$1(i);
  }
  return e.set(t, o), o;
}
function gt(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: o,
    strategy: s
  } = t;
  const i = [...n === "clippingAncestors" ? dt(e, this._c) : [].concat(n), o], r = i[0], l = i.reduce((f, u) => {
    const a = _(e, u, s);
    return f.top = a$5(a.top, f.top), f.right = l$1(a.right, f.right), f.bottom = l$1(a.bottom, f.bottom), f.left = a$5(a.left, f.left), f;
  }, _(e, r, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function pt(t) {
  const {
    width: e,
    height: n
  } = j(t);
  return {
    width: e,
    height: n
  };
}
function mt(t, e, n) {
  const o = d(e), s = y$2(e), c = n === "fixed", i = L$1(t, true, c, e);
  let r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l$1 = O$1(0);
  if (o || !o && !c)
    if ((l(e) !== "body" || m$3(s)) && (r = C$1(e)), o) {
      const a = L$1(e, true, c, e);
      l$1.x = a.x + e.clientLeft, l$1.y = a.y + e.clientTop;
    } else s && (l$1.x = Q(s));
  const f = i.left + r.scrollLeft - l$1.x, u = i.top + r.scrollTop - l$1.y;
  return {
    x: f,
    y: u,
    width: i.width,
    height: i.height
  };
}
function k$3(t, e) {
  return !d(t) || p(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function Z(t, e) {
  const n = i$1(t);
  if (!d(t) || J$1(t))
    return n;
  let o = k$3(t, e);
  for (; o && E$2(o) && p(o).position === "static"; )
    o = k$3(o, e);
  return o && (l(o) === "html" || l(o) === "body" && p(o).position === "static" && !N$1(o)) ? n : o || T(t) || n;
}
const wt = async function(t) {
  const e = this.getOffsetParent || Z, n = this.getDimensions;
  return {
    reference: mt(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await n(t.floating)
    }
  };
};
function yt(t) {
  return p(t).direction === "rtl";
}
const vt = {
  convertOffsetParentRelativeRectToViewportRelativeRect: lt,
  getDocumentElement: y$2,
  getClippingRect: gt,
  getOffsetParent: Z,
  getElementRects: wt,
  getClientRects: ft,
  getDimensions: pt,
  getScale: F,
  isElement: S$1,
  isRTL: yt
};
const Et = nt, Tt = et, Ft = (t, e, n) => {
  const o = /* @__PURE__ */ new Map(), s = {
    platform: vt,
    ...n
  }, c = {
    ...s.platform,
    _c: o
  };
  return tt(t, e, {
    ...s,
    platform: c
  });
};

function i(n) {
  return r$2(n);
}
function o$3(n) {
  return n.assignedSlot ? n.assignedSlot : n.parentNode instanceof ShadowRoot ? n.parentNode.host : n.parentNode;
}
function r$2(n) {
  for (let e = n; e; e = o$3(e)) if (e instanceof Element && getComputedStyle(e).display === "none") return null;
  for (let e = o$3(n); e; e = o$3(e)) {
    if (!(e instanceof Element)) continue;
    const t = getComputedStyle(e);
    if (t.display !== "contents" && (t.position !== "static" || t.filter !== "none" || e.tagName === "BODY"))
      return e;
  }
  return null;
}

const $$1 = defineComponent({
  name: "JamfTooltip",
  props: {
    /** (Required) Sets the tooltip message */
    text: {
      type: String,
      required: true
    },
    /** Disables the tooltip */
    isDisabled: {
      type: Boolean
    },
    /**
     * Sets the initial tooltip position
     *  @values top, right, left,bottom, top-start, top-end, bottom-start, bottom-end, right-start, right-end, left-start,  left-end
     */
    openPosition: {
      type: String,
      default: "bottom"
    },
    /** Sets the mouse over delay (milliseconds)*/
    delay: {
      type: Number,
      default: 0
    },
    /** Sets the z-index of the tooltip container*/
    zIndex: {
      type: String,
      default: "999"
    },
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula--tooltip"
    },
    /** Optional component identifier that can be set as a unique value on a page for web analytics targeting. */
    waId: String
  },
  data() {
    return {
      isOpen: false,
      /** disableFadeOut is to ensure that the fade out animation is not applied to the tooltip popover before the user interacts with the trigger element. */
      disableFadeOut: false,
      isMouseLeave: false,
      timeoutId: null,
      target: null,
      tooltipElement: null,
      id: `jamf-tooltip-v5-9-0-${o$b()}`,
      isPopoverSupported: false
    };
  },
  mounted() {
    this.isPopoverSupported = HTMLElement.prototype.hasOwnProperty("popover");
  },
  computed: {
    classes() {
      return {
        tooltip: true,
        "fade-in": this.isOpen,
        "fade-out": !this.isOpen && this.disableFadeOut
      };
    },
    tooltipClass() {
      return {
        "tooltip-container": true,
        "tooltip-popover": this.isPopoverSupported,
        "tooltip-no-popover": !this.isPopoverSupported
      };
    },
    tooltipText() {
      return {
        "tooltip-text": this.isPopoverSupported
      };
    }
  },
  watch: {
    isDisabled(s) {
      s && (this.isOpen = false);
    }
  },
  methods: {
    updateDescribedBy(s = true) {
      const t = this.$refs.target.querySelector(
        "slot"
      )?.assignedNodes().filter((o) => o.nodeType === Node.ELEMENT_NODE);
      if (t?.length) {
        const o = t[0].getAttribute(
          "aria-describedby"
        );
        if (s) {
          const e = o ? `${o} ${this.id}` : this.id;
          t[0].setAttribute(
            "aria-describedby",
            e
          );
        }
        if (!s) {
          const e = new RegExp("\\s*" + this.id, "g"), i = o?.replace(
            e,
            ""
          );
          i && t[0].setAttribute(
            "aria-describedby",
            i
          ), i || t[0].removeAttribute("aria-describedby");
        }
      }
    },
    createTooltip() {
      if (!this.$refs.tooltip)
        return;
      this.isPopoverSupported && this.$refs.tooltip.showPopover(), this.tooltipElement = this.$refs.tooltip, this.applyStylesToTooltip(this.tooltipElement), this.tooltipElement.id = this.id;
      const s = document.createElement("div");
      s.setAttribute("data-popper-arrow", ""), this.applyStylesToArrow(s), this.tooltipElement.appendChild(s), this.fadeIn(this.tooltipElement), Ft(this.$refs.target, this.tooltipElement, {
        platform: {
          ...vt,
          getOffsetParent: (t) => vt.getOffsetParent(t, i)
        },
        middleware: [Tt({ element: s }), Et(), it(0)],
        placement: this.openPosition
      }).then(({ x: t, y: o, middlewareData: e, placement: i }) => {
        if (Object.assign(
          this.tooltipElement.style,
          this.updateTooltipPosition(i, t, o)
        ), e.arrow) {
          const { x: r, y: a } = e.arrow;
          this.isPopoverSupported ? this.updateArrowPosition(i, s, r, a) : this.updateArrowPositionInOldBrowsers(
            i,
            s,
            r,
            a
          );
        }
        this.updateDescribedBy();
      });
    },
    updateTooltipPosition(s, t, o) {
      if (!this.isPopoverSupported)
        return this.updateTooltipPositionOlderBrowser(s, t, o);
      const e = {
        left: `${t}px`,
        top: `${o}px`
      };
      return ["top-start", "bottom-start"].includes(s) && (e.left = `${t - 12}px`), ["top-end", "bottom-end"].includes(s) && (e.left = `${t + 12}px`), e;
    },
    updateTooltipPositionOlderBrowser(s, t, o) {
      const e = {
        left: `${t}px`,
        top: `${o}px`
      };
      return s.startsWith("bottom") && (e.top = `${o + 8}px`), s.startsWith("top") && (e.top = `${o - 8}px`), s.startsWith("left") && (e.left = `${t - 8}px`), s.startsWith("right") && (e.left = `${t + 8}px`), e;
    },
    updateArrowPosition(s, t, o, e) {
      switch (t.style.top = "", t.style.bottom = "", t.style.left = "", t.style.right = "", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent", s) {
        case "top":
          t.style.right = `${o}px`;
          break;
        case "top-start":
          t.style.left = "20px";
          break;
        case "top-end":
          t.style.right = "20px";
          break;
        case "bottom":
          t.style.transform = "rotate(180deg)", t.style.right = `${o}px`, t.style.top = 0;
          break;
        case "bottom-start":
          t.style.transform = "rotate(180deg)", t.style.left = "20px", t.style.top = 0;
          break;
        case "bottom-end":
          t.style.transform = "translateX(-50%) rotate(180deg)", t.style.right = "20px", t.style.top = 0;
          break;
        case "right":
          t.style.transform = "rotate(90deg)", t.style.left = 0, t.style.top = `${e}px`;
          break;
        case "right-start":
          t.style.transform = "rotate(90deg)", t.style.left = 0, t.style.top = "20px";
          break;
        case "right-end":
          t.style.transform = "rotate(90deg)", t.style.left = 0, t.style.bottom = "20px";
          break;
        case "left":
          t.style.transform = "translateX(-50%) rotate(-90deg)", t.style.right = "-6px", t.style.top = `${e}px`;
          break;
        case "left-start":
          t.style.transform = "translateX(-50%) rotate(-90deg)", t.style.right = "-6px", t.style.top = "20px";
          break;
        case "left-end":
          t.style.transform = "translateX(-50%) rotate(-90deg)", t.style.right = "-6px", t.style.bottom = "20px";
          break;
      }
    },
    updateArrowPositionInOldBrowsers(s, t) {
      switch (t.style.top = "", t.style.bottom = "", t.style.left = "", t.style.right = "", s) {
        case "top":
          t.style.bottom = "-12px", t.style.left = "50%", t.style.transform = "translateX(-50%) rotate(180deg)", t.style.borderColor = "transparent transparent var(--color-indicator-tooltip) transparent";
          break;
        case "top-start":
          t.style.bottom = "-12px", t.style.left = "15%", t.style.transform = "translateX(-50%) rotate(180deg)", t.style.borderColor = "transparent transparent var(--color-indicator-tooltip) transparent";
          break;
        case "top-end":
          t.style.bottom = "-12px", t.style.left = "85%", t.style.transform = "translateX(-50%) rotate(180deg)", t.style.borderColor = "transparent transparent var(--color-indicator-tooltip) transparent";
          break;
        case "bottom":
          t.style.top = "-12px", t.style.left = "50%", t.style.transform = "translateX(-50%) rotate(180deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "bottom-start":
          t.style.top = "-12px", t.style.left = "15%", t.style.transform = "translateX(-50%) rotate(180deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "bottom-end":
          t.style.top = "-12px", t.style.left = "85%", t.style.transform = "translateX(-50%) rotate(180deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "right":
          t.style.top = "35%", t.style.left = "-6px", t.style.transform = "translateX(-50%) rotate(90deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "right-start":
          t.style.top = "20%", t.style.left = "-6px", t.style.transform = "translateX(-50%) rotate(90deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "right-end":
          t.style.top = "50%", t.style.left = "-6px", t.style.transform = "translateX(-50%) rotate(90deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "left":
          t.style.top = "35%", t.style.right = "-18px", t.style.transform = "translateX(-50%) rotate(-90deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "left-start":
          t.style.top = "20%", t.style.right = "-18px", t.style.transform = "translateX(-50%) rotate(-90deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
        case "left-end":
          t.style.top = "50%", t.style.right = "-18px", t.style.transform = "translateX(-50%) rotate(-90deg)", t.style.borderColor = "var(--color-indicator-tooltip) transparent transparent transparent";
          break;
      }
    },
    applyStylesToArrow(s) {
      s.style.borderStyle = "solid", s.style.borderWidth = "6px", s.style.position = "absolute", s.style.borderColor = "transparent transparent var(--color-indicator-tooltip) transparent";
    },
    applyStylesToTooltip(s) {
      s.style.zIndex = this.zIndex;
    },
    fadeIn(s, t = 200) {
      s.style.opacity = 0, s.style.display = "block";
      let o = performance.now();
      const e = (i) => {
        const r = Math.min((i - o) / t, 1);
        s.style.opacity = r, r < 1 && window.requestAnimationFrame(e);
      };
      window.requestAnimationFrame(e);
    },
    onMouseEnter() {
      this.isDisabled || this.isOpen || (this.isOpen = true, this.target = this.$refs.target, this.target && this.createTooltip(), this.isMouseLeave = false, this.timeoutId = setTimeout(() => {
        !this.isMouseLeave && !this.isDisabled && this.createTooltip();
      }, this.delay));
    },
    onMouseLeave(s) {
      this.$refs.tooltip && (this.$refs.tooltip === s.relatedTarget || this.$refs.tooltip.contains(s.relatedTarget)) || (this.isPopoverSupported && this.$refs.tooltip && this.$refs.tooltip.hidePopover(), this.isOpen = false, this.isMouseLeave = true, this.updateDescribedBy(false), this.timeoutId !== null && clearTimeout(this.timeoutId));
    }
  }
});

const o$2 = "@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{0%{opacity:1}to{opacity:0}}@keyframes scaleIn{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer{0%{background-position:200% 0}to{background-position:-200% 0}}.tooltip-text{align-items:center;font-size:var(--size-font-helper-base);background-color:var(--color-indicator-tooltip);border-radius:var(--size-border-radius-base);color:var(--color-font-tooltip);padding:calc(1.5px * var(--size-base-spacing));max-width:300px;pointer-events:none;top:0;left:0;border:unset}.tooltip-popover{margin:0;background-color:unset;border:unset;padding:12px;opacity:1!important}.tooltip-no-popover{align-items:center;font-size:var(--size-font-helper-base);background-color:var(--color-indicator-tooltip);border-radius:var(--size-border-radius-base);color:var(--color-font-tooltip);padding:calc(1.5px * var(--size-base-spacing));max-width:300px;pointer-events:none;border:unset;position:absolute;opacity:0}.tooltip-container{position:absolute;overflow-x:hidden}";

const f$4 = ["data-wa", "data-wa-id"];
function v$1(o, e, M, w, E, L) {
  return openBlock(), createElementBlock("div", {
    "data-testid": "tooltip-container",
    ref: "boundary",
    class: "container",
    "data-wa": o.waComponent,
    "data-wa-id": o.waId,
    part: "container"
  }, [
    createBaseVNode("div", {
      ref: "target",
      "data-testid": "tooltip-target",
      onMouseenter: e[0] || (e[0] = (...t) => o.onMouseEnter && o.onMouseEnter(...t)),
      onMouseleave: e[1] || (e[1] = (...t) => o.onMouseLeave && o.onMouseLeave(...t)),
      onFocusin: e[2] || (e[2] = (...t) => o.onMouseEnter && o.onMouseEnter(...t)),
      onFocusout: e[3] || (e[3] = (...t) => o.onMouseLeave && o.onMouseLeave(...t)),
      part: "target"
    }, [
      renderSlot(o.$slots, "default")
    ], 544),
    o.isOpen ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "tooltip",
      popover: "manual",
      class: normalizeClass([o.tooltipClass, o.openPosition]),
      onMouseleave: e[4] || (e[4] = (...t) => o.onMouseLeave && o.onMouseLeave(...t))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(o.tooltipText)
      }, toDisplayString(o.text), 3)
    ], 34)) : createCommentVNode("", true)
  ], 8, f$4);
}
const k$2 = /* @__PURE__ */ s$6($$1, [["render", v$1], ["styles", [o$2]]]);

const E$1 = defineComponent({
  name: "JamfTextInput",
  components: {
    InputGroup: _$1,
    JamfIcon: b$7,
    JamfButton: D$2,
    JamfTooltip: k$2
  },
  inject: { isInternal: { from: "isInternal", default: false } },
  props: {
    /** Contents of text input label. */
    label: String,
    /** Contents of helper text.  Located alongside label text. */
    helperText: String,
    /** Contents of error text.  Displays when 'hasError' is true.  Located under text input. */
    errorText: String,
    /** Contents of warning text.  Displays when 'hasWarning' is true.  Located under text input. */
    warningText: String,
    /** Contents of success text.  Displays when 'hasSuccess' is true.  Located under text input. */
    successText: String,
    /** @deprecated Sets a reduced min-width for the input. */
    isSmall: {
      type: Boolean,
      default: false
    },
    /** Sets size for label and helper text */
    labelSize: {
      type: String,
      default: "medium"
    },
    /** Sets size of input */
    size: {
      type: String,
      default: "medium"
    },
    /** Sets unique id for text input component. */
    id: String,
    /** Sets text input state to disabled. */
    isDisabled: {
      type: Boolean,
      default: false
    },
    /** Sets text input state to 'hasError'.  Overrides 'hasWarning' and 'hasSuccess'. */
    hasError: {
      type: Boolean,
      default: false
    },
    /** Sets text input state to 'hasWarning'.  Overrides 'hasSuccess'. */
    hasWarning: {
      type: Boolean,
      default: false
    },
    /** Sets text input state to 'hasSuccess'. */
    hasSuccess: {
      type: Boolean,
      default: false
    },
    /** Set text input state to required. */
    isRequired: {
      type: Boolean,
      default: false
    },
    /** Set text input state to 'isVertical'.  Aligns helper text underneath label instead of beside it. */
    isVertical: {
      type: Boolean,
      default: false
    },
    /** Contents of additional information text.  Located below the text input.  Overridden by error, warning, and success text. */
    descenderText: String,
    /** Sets text input state to read only. */
    isReadOnly: {
      type: Boolean,
      default: false
    },
    /** Sets placeholder text in text input area. */
    placeholder: String,
    /** Sets mode of text input.  Known valid inputs are `text`, `number`, and `password`. */
    type: {
      type: String,
      default: "text"
    },
    /** Sets maximum number of characters in text input.  Count displays as user types. */
    maxLength: Number,
    /** Sets the value of the component. */
    value: [Number, String],
    /** Sets counter input style */
    isCounter: {
      type: Boolean,
      default: false
    },
    /** Sets minimum value when text input prop 'type' is `number` */
    minValue: {
      type: Number,
      default: 0
    },
    /** Sets maximum value when text input prop 'type' is `number` */
    maxValue: {
      type: Number,
      default: null
    },
    /** The callback function that is triggered when Enter key is pressed */
    onPressEnter: {
      type: Function,
      default: null
    },
    /** Sets step interval when text input prop 'type' is 'number'. */
    step: Number,
    /** Sets showHidePassword state to enabled. */
    showHidePassword: {
      type: Boolean,
      default: false
    },
    /** Sets copyToClipboard state to enabled. */
    copyToClipboard: {
      type: Boolean,
      default: false
    },
    /** Sets the name attribute on the input */
    name: String,
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula--text-input"
    },
    /** Component identifier setting unique page value for web analytics targeting. */
    waId: String,
    /** Sets localized aria label for show password button */
    showPasswordAriaLabel: {
      type: String,
      default: "Show password"
    },
    /** Sets localized aria label for hide password button */
    hidePasswordAriaLabel: {
      type: String,
      default: "Hide password"
    },
    /** Sets localized text for copy to clipboard tooltip */
    copyToClipBoardText: {
      type: String,
      default: "Copy to clipboard"
    },
    /** Configures which key, (plus meta key) to watch for to focus on input */
    focusKey: {
      type: String,
      default: null
    },
    /** Shows the focus key in the trailing slot */
    showFocusKey: {
      type: Boolean,
      default: false
    },
    /** References the id of the form to which the input should be associated. */
    form: String
  },
  emits: ["update:value", "change", "password-visibility", "copied", "input"],
  data() {
    return {
      computedValue: this.value != null ? this.value : "",
      leadingSlot: false,
      trailingSlot: false,
      exclamationCircleOutline: y8,
      exclamationTriangleOutline: D8,
      checkCircleOutline: oc,
      eyeOutline: b8,
      eyeSlashOutline: A8,
      showPassword: false,
      clipboardOutline: I9,
      internals: void 0,
      lowercaseFocusKey: "",
      observer: null,
      uid: o$b()
    };
  },
  computed: {
    classes() {
      return {
        "input-field-container": true,
        "is-number-input": this.type === "number",
        "with-leading-icon": this.leading,
        "with-trailing-icon": this.trailing && this.type !== "number",
        "has-error": this.hasError,
        "has-warning": this.hasWarning && !this.hasError,
        "has-success": this.hasSuccess && !this.hasWarning && !this.hasError,
        [this.size]: this.size !== "medium"
      };
    },
    counterButton() {
      return {
        "is-disabled": this.isDisabled,
        "is-read-only": this.isReadOnly
      };
    },
    leading() {
      return this.leadingSlot;
    },
    trailing() {
      return this.trailingSlot || this.type === "password" && this.showHidePassword || this.copyToClipboard;
    },
    isNumberInput() {
      return this.type === "number";
    },
    stepInterval() {
      return this.isNumberInput ? this.step || 1 : null;
    },
    maximumLength() {
      return this.isNumberInput ? null : this.maxLength;
    },
    isMaxReached() {
      if (this.maxLength !== null && this.maxLength !== void 0) {
        if (typeof this.computedValue == "number")
          return this.computedValue >= this.maxLength;
        if (typeof this.computedValue == "string")
          return this.computedValue.length >= this.maxLength;
      }
      return false;
    },
    isPolite() {
      return this.isMaxReached ? "polite" : "off";
    },
    buildScreenLabel() {
      return this.isMaxReached ? "You have reached your maximum character limit." : "characters allowed.";
    },
    maxLengthId() {
      return this.maxLength ? `max-length-${this.computedId}` : "";
    },
    isStateful() {
      return this.hasSuccess || this.hasWarning || this.hasError;
    },
    inputClass() {
      return {
        small: this.isSmall || this.size === "small",
        "input-small": this.size === "small",
        "input-medium": this.size === "medium",
        "input-large": this.size === "large",
        "counter-input": this.isCounter
      };
    },
    computedType() {
      return this.type === "password" ? this.showPassword ? "text" : "password" : this.type;
    },
    computedIcon() {
      return this.showPassword ? this.eyeSlashOutline : this.eyeOutline;
    },
    computedLabel() {
      return this.showPassword ? this.hidePasswordAriaLabel : this.showPasswordAriaLabel;
    },
    computedId() {
      return this.id ? this.id : this.uid;
    },
    internalUse() {
      return this.isInternal;
    }
  },
  watch: {
    /** When v-model change, set internal value and update internals. */
    value(e) {
      this.computedValue = e ?? "", this.internalUse || this.internals && this.internals.setFormValue(e);
    }
  },
  mounted() {
    const e = this.$refs.input.getRootNode()?.host;
    this.observer = new MutationObserver(this.checkSlots), this.observer.observe(e, { childList: true }), this.$nextTick(() => {
      this.focusKey && (this.lowercaseFocusKey = this.focusKey[0].toLowerCase(), window.addEventListener("keydown", this.handleKeyDown));
    }), this.checkSlots();
    const t = this.$refs.input.getRootNode().children;
    !this.internalUse && t.length === 3 && t[1]?.classList.value === t[2]?.classList.value && (t[1].querySelector("input").setAttribute(
      "value",
      this.computedValue.toString()
    ), this.$nextTick(() => {
      t[2] && t[2].remove();
    })), this.isInternal || (this.internals = this.$refs.input.getRootNode().host.internals_, this.computedValue && this.internals && this.internals.setFormValue(this.computedValue));
  },
  updated() {
    this.checkSlots();
  },
  beforeUnmount() {
    this.focusKey && window.removeEventListener("keydown", this.handleKeyDown), this.observer && this.observer.disconnect();
  },
  methods: {
    handleKeyDown(e) {
      e.metaKey && e.key == this.lowercaseFocusKey && (e.preventDefault(), this.$refs.input?.focus());
    },
    handleKeyUp(e) {
      if (e.code === "Enter" || e.code === "NumpadEnter") {
        if (this.onPressEnter) {
          this.onPressEnter();
          return;
        }
        this.emitSubmit();
      }
    },
    emitSubmit() {
      const s = this.$refs.input.getRootNode().host;
      let i;
      if (s.getRootNode() && (i = this.form ? s.getRootNode().getElementById(this.form) : void 0), !i && s.getRootNode() !== document && (i = document.getElementById(this.form)), i || (i = s.closest("form")), i) {
        const r = new Event("submit", { bubbles: true, cancelable: true });
        i.dispatchEvent(r) && i.requestSubmit();
      }
    },
    handleIncrement() {
      if (this.isReadOnly)
        return;
      const e = this.$refs.input;
      e.stepUp(), this.emitChange(e.value), this.$emit("input", e.value);
    },
    handleDecrement() {
      if (this.isReadOnly)
        return;
      const e = this.$refs.input;
      e.stepDown(), this.emitChange(e.value), this.$emit("input", e.value);
    },
    checkSlots() {
      if (this.internalUse) {
        this.leadingSlot = !!this.$slots.leading, this.trailingSlot = !!this.$slots.trailing;
        return;
      }
      const e = this.$refs.leading, t = this.$refs.trailing;
      this.leadingSlot = l$3(e, "leading"), this.trailingSlot = l$3(t, "trailing") || l$3(t, ".trailing", true);
    },
    inputChange(e) {
      this.emitChange(e.target.value);
    },
    emitChange(e) {
      const t = this.$refs.input?.getRootNode()?.host;
      t && !this.internalUse && (t.value = e), this.$emit("update:value", e), this.$emit("change", e);
    },
    changeType() {
      this.showPassword = !this.showPassword, this.$emit("password-visibility", this.showPassword);
    },
    copyValue() {
      navigator.clipboard.writeText(this.computedValue), this.$emit("copied", this.computedType);
    }
  }
});

const o$1 = '@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{0%{opacity:1}to{opacity:0}}@keyframes scaleIn{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer{0%{background-position:200% 0}to{background-position:-200% 0}}.container{position:relative;height:min-content;display:grid;gap:calc(1.5px * var(--size-base-spacing))}.container .label-container{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);display:flex;flex-wrap:wrap;max-width:100%;align-items:baseline;margin-bottom:calc(.5px * var(--size-base-spacing))}.container .label-container :first-child{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);margin-right:calc(1px * var(--size-base-spacing))}.container .label-container.is-vertical,.is-vertical.container .label-container{flex-direction:column}.container .label-container.is-disabled,.is-disabled.container .label-container{opacity:var(--opacity-disabled);user-select:none}.container .label-container.has-error :first-child,.has-error.container .label-container :first-child{color:var(--color-danger-base)}.container .label-container.has-warning :first-child,.has-warning.container .label-container :first-child{color:var(--color-warning-base)}.container .label-container.has-success :first-child,.has-success.container .label-container :first-child{color:var(--color-green-font)}.container .input-descenders{padding:0 calc(1px * var(--size-base-spacing));display:flex;margin-top:calc(.5px * var(--size-base-spacing));justify-content:space-between;width:100%;box-sizing:border-box}.container .input-descenders>*{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary)}.container .input-descenders.max-only{justify-content:flex-end}.container .input-descenders .success-text,.container .input-descenders .error-text,.container .input-descenders .warning-text{padding-right:calc(.5px * var(--size-base-spacing))}.container .input-descenders .error-text{color:var(--color-danger-base)}.container .input-descenders .warning-text{color:var(--color-warning-base)}.container .input-descenders .success-text{color:var(--color-green-font)}.container .input-descenders.is-disabled,.is-disabled.container .input-descenders{opacity:var(--opacity-disabled);user-select:none}.container .input-group{display:grid;gap:calc(2px * var(--size-base-spacing));grid-auto-flow:row;grid-auto-rows:auto}.container.compact{gap:calc(.5px * var(--size-base-spacing))}.container.is-inline>.input-group{grid-auto-flow:column;grid-auto-columns:min-content;white-space:nowrap}.container.has-error>.input-group input{border-color:var(--color-danger-base)}.container .label-container,.container .input-descenders{margin:0}.container .label-container .label-text,.container .input-descenders .label-text{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base)}.container .label-container .label-text.small,.container .input-descenders .label-text.small{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-small))}.container .label-container .label-text.medium,.container .input-descenders .label-text.medium{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-medium))}.container .label-container .label-text.large,.container .input-descenders .label-text.large{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-large))}.container .helper-text.small{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-small))}.container .helper-text.medium{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-medium))}.container .helper-text.large{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-large))}.container .copy-clipboard-container{position:absolute;right:calc(1px * var(--size-base-spacing));top:calc(4px * var(--size-base-spacing));display:flex;align-items:center}.container .sr-only{position:absolute;height:1px;width:1px;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);clip-path:polygon(0px 0px,0px 0px,0px 0px);-webkit-clip-path:polygon(0px 0px,0px 0px,0px 0px);overflow:hidden!important}.container .copy-button{padding:calc(.5px * var(--size-base-spacing))}.container .textarea.with-copy-clipboard{padding-right:calc(5px * var(--size-base-spacing))}.sr-only{position:absolute;height:1px;width:1px;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);clip-path:polygon(0px 0px,0px 0px,0px 0px);-webkit-clip-path:polygon(0px 0px,0px 0px,0px 0px);overflow:hidden!important}.input-field-container{display:flex;position:relative;align-items:center}.input-field-container .leading,.input-field-container .trailing{display:none;position:absolute;fill:currentColor}.input-field-container .leading:not(.input-button),.input-field-container .trailing:not(.input-button){width:calc(var(--size-base-items) * 2px);height:calc(var(--size-base-items) * 2px)}.input-field-container .leading.copy-clipboard,.input-field-container .trailing.copy-clipboard{right:calc(2px * var(--size-base-spacing))}.input-field-container .leading.error-icon,.input-field-container .trailing.error-icon{display:block;color:var(--color-danger-base)}.input-field-container .leading.warning-icon,.input-field-container .trailing.warning-icon{display:block;color:var(--color-warning-base)}.input-field-container .leading.success-icon,.input-field-container .trailing.success-icon{display:block;color:var(--color-green-font)}.input-field-container .leading{left:calc(1px * var(--size-base-spacing))}.input-field-container .trailing{right:calc(1px * var(--size-base-spacing))}.input-field-container.with-leading-icon .leading,.input-field-container.with-trailing-icon .trailing{display:flex;justify-content:center;align-items:center}.input-field-container.is-number-input .trailing{display:none}.input-field-container.with-leading-icon input{padding-left:var(--size-input-with-leading-icon, calc(var(--size-base-items) * 4px))}.input-field-container.with-trailing-icon input{padding-right:var(--size-input-with-trailing-icon, calc(var(--size-base-items) * 4px))}.input-field-container .trailing.focus-key{display:flex;align-items:center;width:unset;font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-paragraph-base);line-height:var(--size-font-paragraph-height);letter-spacing:var(--size-font-paragraph-spacing);color:var(--color-font-secondary);color:var(--color-font-tertiary)}.input-field-container .input-medium{border:var(--size-border-width-base) solid var(--color-input-border-base);border-radius:var(--size-border-radius-input-custom, var(--size-border-radius-input));transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;border-left-width:var(--border-left-custom, var(--size-border-width-base));border-right-width:var(--border-right-custom, var(--size-border-width-base));display:flex;height:var(--size-input-height-base);padding:0 calc(1px * var(--size-base-spacing));min-width:var(--size-input-width-base);color:var(--color-font-base);font-size:var(--size-font-input-base);box-sizing:border-box;max-width:100%;background-color:var(--color-input-base);width:100%}.input-field-container .input-medium:hover:not([readonly]):not(:disabled){border-color:var(--color-input-primary-base)}.input-field-container .input-medium:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px;background-color:var(--color-input-base)}.input-field-container .input-medium.small{min-width:unset}.input-field-container .input-medium[readonly]{background:var(--color-input-readonly);border-color:var(--color-border-secondary)}.input-field-container .input-medium:disabled:not([readonly]){opacity:var(--opacity-disabled);cursor:not-allowed}.input-field-container .input-medium::placeholder{color:var(--color-font-placeholder)}.input-field-container .input-medium.has-error{border-color:var(--color-danger-base)}.input-field-container .input-medium.has-error:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-danger) 0 0 0 4px}.input-field-container .input-medium.has-error:hover:not([readonly]):not(:disabled){border-color:var(--color-danger-active)}.has-error.input-field-container .input-medium{border-color:var(--color-danger-base)}.has-error.input-field-container .input-medium:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-danger) 0 0 0 4px}.has-error.input-field-container .input-medium:hover:not([readonly]):not(:disabled){border-color:var(--color-danger-active)}.input-field-container .input-medium.has-warning{border-color:var(--color-warning-base)}.input-field-container .input-medium.has-warning:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-warning) 0 0 0 4px}.input-field-container .input-medium.has-warning:hover:not([readonly]):not(:disabled){border-color:var(--color-warning-active)}.has-warning.input-field-container .input-medium{border-color:var(--color-warning-base)}.has-warning.input-field-container .input-medium:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-warning) 0 0 0 4px}.has-warning.input-field-container .input-medium:hover:not([readonly]):not(:disabled){border-color:var(--color-warning-active)}.input-field-container .input-medium.has-success{border-color:var(--color-border-success-base)}.input-field-container .input-medium.has-success:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-success) 0 0 0 4px}.input-field-container .input-medium.has-success:hover:not([readonly]):not(:disabled){border-color:var(--color-success-active)}.has-success.input-field-container .input-medium{border-color:var(--color-border-success-base)}.has-success.input-field-container .input-medium:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-success) 0 0 0 4px}.has-success.input-field-container .input-medium:hover:not([readonly]):not(:disabled){border-color:var(--color-success-active)}@media only screen and (max-width: 812px){.input-field-container .input-medium{min-width:unset;width:100%}}.input-field-container .input-small{border:var(--size-border-width-base) solid var(--color-input-border-base);border-radius:var(--size-border-radius-input-custom, var(--size-border-radius-input));transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;border-left-width:var(--border-left-custom, var(--size-border-width-base));border-right-width:var(--border-right-custom, var(--size-border-width-base));display:flex;height:var(--size-input-height-base);padding:0 calc(1px * var(--size-base-spacing));min-width:var(--size-input-width-base);color:var(--color-font-base);font-size:var(--size-font-input-base);box-sizing:border-box;max-width:100%;background-color:var(--color-input-base);height:calc(var(--size-input-height-base) + -1px * var(--size-base-spacing));width:100%}.input-field-container .input-small:hover:not([readonly]):not(:disabled){border-color:var(--color-input-primary-base)}.input-field-container .input-small:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px;background-color:var(--color-input-base)}.input-field-container .input-small.small{min-width:unset}.input-field-container .input-small[readonly]{background:var(--color-input-readonly);border-color:var(--color-border-secondary)}.input-field-container .input-small:disabled:not([readonly]){opacity:var(--opacity-disabled);cursor:not-allowed}.input-field-container .input-small::placeholder{color:var(--color-font-placeholder)}.input-field-container .input-small.has-error{border-color:var(--color-danger-base)}.input-field-container .input-small.has-error:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-danger) 0 0 0 4px}.input-field-container .input-small.has-error:hover:not([readonly]):not(:disabled){border-color:var(--color-danger-active)}.has-error.input-field-container .input-small{border-color:var(--color-danger-base)}.has-error.input-field-container .input-small:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-danger) 0 0 0 4px}.has-error.input-field-container .input-small:hover:not([readonly]):not(:disabled){border-color:var(--color-danger-active)}.input-field-container .input-small.has-warning{border-color:var(--color-warning-base)}.input-field-container .input-small.has-warning:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-warning) 0 0 0 4px}.input-field-container .input-small.has-warning:hover:not([readonly]):not(:disabled){border-color:var(--color-warning-active)}.has-warning.input-field-container .input-small{border-color:var(--color-warning-base)}.has-warning.input-field-container .input-small:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-warning) 0 0 0 4px}.has-warning.input-field-container .input-small:hover:not([readonly]):not(:disabled){border-color:var(--color-warning-active)}.input-field-container .input-small.has-success{border-color:var(--color-border-success-base)}.input-field-container .input-small.has-success:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-success) 0 0 0 4px}.input-field-container .input-small.has-success:hover:not([readonly]):not(:disabled){border-color:var(--color-success-active)}.has-success.input-field-container .input-small{border-color:var(--color-border-success-base)}.has-success.input-field-container .input-small:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-success) 0 0 0 4px}.has-success.input-field-container .input-small:hover:not([readonly]):not(:disabled){border-color:var(--color-success-active)}@media only screen and (max-width: 812px){.input-field-container .input-small{min-width:unset;width:100%}}.input-field-container .input-large{border:var(--size-border-width-base) solid var(--color-input-border-base);border-radius:var(--size-border-radius-input-custom, var(--size-border-radius-input));transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;border-left-width:var(--border-left-custom, var(--size-border-width-base));border-right-width:var(--border-right-custom, var(--size-border-width-base));display:flex;height:var(--size-input-height-base);padding:0 calc(1px * var(--size-base-spacing));min-width:var(--size-input-width-base);color:var(--color-font-base);font-size:var(--size-font-input-base);box-sizing:border-box;max-width:100%;background-color:var(--color-input-base);height:calc(var(--size-input-height-base) + 1px * var(--size-base-spacing));width:100%}.input-field-container .input-large:hover:not([readonly]):not(:disabled){border-color:var(--color-input-primary-base)}.input-field-container .input-large:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px;background-color:var(--color-input-base)}.input-field-container .input-large.small{min-width:unset}.input-field-container .input-large[readonly]{background:var(--color-input-readonly);border-color:var(--color-border-secondary)}.input-field-container .input-large:disabled:not([readonly]){opacity:var(--opacity-disabled);cursor:not-allowed}.input-field-container .input-large::placeholder{color:var(--color-font-placeholder)}.input-field-container .input-large.has-error{border-color:var(--color-danger-base)}.input-field-container .input-large.has-error:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-danger) 0 0 0 4px}.input-field-container .input-large.has-error:hover:not([readonly]):not(:disabled){border-color:var(--color-danger-active)}.has-error.input-field-container .input-large{border-color:var(--color-danger-base)}.has-error.input-field-container .input-large:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-danger) 0 0 0 4px}.has-error.input-field-container .input-large:hover:not([readonly]):not(:disabled){border-color:var(--color-danger-active)}.input-field-container .input-large.has-warning{border-color:var(--color-warning-base)}.input-field-container .input-large.has-warning:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-warning) 0 0 0 4px}.input-field-container .input-large.has-warning:hover:not([readonly]):not(:disabled){border-color:var(--color-warning-active)}.has-warning.input-field-container .input-large{border-color:var(--color-warning-base)}.has-warning.input-field-container .input-large:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-warning) 0 0 0 4px}.has-warning.input-field-container .input-large:hover:not([readonly]):not(:disabled){border-color:var(--color-warning-active)}.input-field-container .input-large.has-success{border-color:var(--color-border-success-base)}.input-field-container .input-large.has-success:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-success) 0 0 0 4px}.input-field-container .input-large.has-success:hover:not([readonly]):not(:disabled){border-color:var(--color-success-active)}.has-success.input-field-container .input-large{border-color:var(--color-border-success-base)}.has-success.input-field-container .input-large:focus:not([readonly]){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-success) 0 0 0 4px}.has-success.input-field-container .input-large:hover:not([readonly]):not(:disabled){border-color:var(--color-success-active)}@media only screen and (max-width: 812px){.input-field-container .input-large{min-width:unset;width:100%}}.input-field-container.is-number-input{max-width:var(--size-input-width-base)}.input-field-container.is-number-input input::-webkit-outer-spin-button,.input-field-container.is-number-input input::-webkit-inner-spin-button{appearance:none;margin:0}.input-field-container.is-number-input input[type=number]{-moz-appearance:textfield;margin-right:0;flex:1}.input-field-container.is-number-input .counter-container{display:flex;flex-direction:column;position:absolute;right:1px}.input-field-container.is-number-input .counter-container button{border:none;border-left:var(--size-border-width-input) solid var(--color-input-border-base);color:var(--color-font-base);margin:0;height:calc(var(--size-input-height-base) / 2.2);background-color:var(--color-input-base);padding:0 calc(1px * var(--size-base-spacing));position:relative;display:flex;align-items:center}.input-field-container.is-number-input .counter-container button:first-of-type{border-bottom:var(--size-border-width-input) solid var(--color-input-border-base);border-top-right-radius:var(--size-border-radius-input)}.input-field-container.is-number-input .counter-container button:first-of-type:before,.input-field-container.is-number-input .counter-container button:first-of-type:after{content:"";background:var(--color-font-base);height:1px;border-radius:1px;display:flex}.input-field-container.is-number-input .counter-container button:first-of-type:before{width:calc(var(--size-input-height-base) * .25)}.input-field-container.is-number-input .counter-container button:first-of-type:after{height:calc(var(--size-input-height-base) * .25);transform:translate(calc(var(--size-input-height-base) / 2.2 * -.3));width:1px}.input-field-container.is-number-input .counter-container button:nth-of-type(2){border-bottom-right-radius:var(--size-border-radius-input)}.input-field-container.is-number-input .counter-container button:nth-of-type(2):before{content:"";background:var(--color-font-base);height:1px;border-radius:1px;margin-top:1px;width:calc(var(--size-input-height-base) * .25)}.input-field-container.is-number-input .counter-container button:hover:enabled{cursor:pointer}.input-field-container.is-number-input .counter-container button:focus{outline:none}.input-field-container.is-number-input .counter-container button.is-read-only{opacity:var(--opacity-disabled);user-select:none;background:var(--color-input-readonly);border-color:var(--color-border-secondary)}.input-field-container.is-number-input .counter-container:hover~input:enabled:not([readonly]){border-color:var(--color-input-primary-base)}.input-field-container.is-number-input .counter-container .is-disabled{opacity:var(--opacity-disabled);user-select:none}.input-field-container.is-number-input .counter-container{position:relative;margin-left:-28px}.input-field-container .counter-input{width:var(--size-input-width-counter);min-width:var(--size-input-width-counter)}.input-field-container .max-length{margin-left:auto}.input-field-container .text-input-preview--icon-button:focus{transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}::slotted(*){color:var(--color-font-base)}.tooltip-text{align-items:center;font-size:var(--size-font-helper-base);background-color:var(--color-indicator-tooltip);border-radius:var(--size-border-radius-base);color:var(--color-font-tooltip);padding:calc(1.5px * var(--size-base-spacing));max-width:300px;pointer-events:none;top:0;left:0;border:unset}.tooltip-popover{margin:0;background-color:unset;border:unset;padding:12px;opacity:1!important}.tooltip-no-popover{align-items:center;font-size:var(--size-font-helper-base);background-color:var(--color-indicator-tooltip);border-radius:var(--size-border-radius-base);color:var(--color-font-tooltip);padding:calc(1.5px * var(--size-base-spacing));max-width:300px;pointer-events:none;border:unset;position:absolute;opacity:0}.tooltip-container{position:absolute;overflow-x:hidden}.jamf-button-v5-9-0{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-action-base);line-height:var(--size-font-action-height);letter-spacing:var(--size-font-action-spacing);cursor:pointer;width:fit-content;box-sizing:border-box;transition-property:background-color,box-shadow,border;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;background-color:var(--color-action-secondary-base);color:var(--color-font-base);border-radius:var(--size-border-radius-action-base);padding:var(--size-action-padding-base, calc(1px * var(--size-base-spacing)) calc(2px * var(--size-base-spacing)));border:none;display:flex;justify-content:center;align-items:center}.jamf-button-v5-9-0 svg,.jamf-button-v5-9-0 .leading,.jamf-button-v5-9-0 .trailing{fill:currentColor;box-sizing:content-box}.jamf-button-v5-9-0:focus,.jamf-button-v5-9-0:hover{text-decoration:none}.jamf-button-v5-9-0.is-disabled,.jamf-button-v5-9-0:disabled{opacity:var(--opacity-disabled);cursor:not-allowed}.jamf-button-v5-9-0:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-secondary-active)}.jamf-button-v5-9-0:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0:focus:not(:disabled){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}.jamf-button-v5-9-0.small{padding:var(--size-action-padding-base, calc(.5px * var(--size-base-spacing)) calc(1px * var(--size-base-spacing)))}.jamf-button-v5-9-0.full-width{width:100%}.jamf-button-v5-9-0.is-loading.with-icon-only .leading{display:none}.jamf-button-v5-9-0.is-loading:not(.with-icon-only){padding-right:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.is-loading:not(.with-icon-only) *:global(.spinner){margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.is-loading:not(.with-icon-only) .spinner{margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.with-icon-only{border-radius:var(--size-border-radius-action-icon-only);justify-content:center}.jamf-button-v5-9-0.with-icon-only:not(.small){width:var(--size-action-height-base);max-width:var(--size-action-height-base);min-width:var(--size-action-height-base);height:var(--size-action-height-base);max-height:var(--size-action-height-base);min-height:var(--size-action-height-base);padding:var(--size-action-padding-icon-only, calc(1px * var(--size-base-spacing)))}.jamf-button-v5-9-0.with-icon-only *:global(.spinner){margin:0}.jamf-button-v5-9-0.with-icon-only .spinner{margin:0}.jamf-button-v5-9-0.has-leading-icon span,.jamf-button-v5-9-0.has-leading-icon .label{margin-left:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0.has-trailing-icon span,.jamf-button-v5-9-0.has-trailing-icon .label{margin-right:calc(1px * var(--size-base-spacing))}.jamf-button-v5-9-0 svg,.jamf-button-v5-9-0 .leading,.jamf-button-v5-9-0 .trailing,.jamf-button-v5-9-0 .spinner{width:calc(var(--size-base-items) * 2px)}.jamf-button-v5-9-0 *:global(.spinner){width:calc(var(--size-base-items) * 3px);margin:-4px 0 -3px}.jamf-button-v5-9-0 .spinner{width:calc(var(--size-base-items) * 3px);margin:-4px 0 -3px}.jamf-button-v5-9-0.primary{background-color:var(--color-action-primary-base);color:var(--color-font-inverse);border:var(--size-border-width-base) solid var(--color-action-primary-base)}.jamf-button-v5-9-0.primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-primary-active)}.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-primary-active);border-color:var(--color-action-primary-active)}.jamf-button-v5-9-0.secondary{background-color:var(--color-action-secondary-base);color:var(--color-font-base);border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.secondary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.secondary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-secondary-active)}.jamf-button-v5-9-0.secondary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.danger{background-color:var(--color-action-danger-base);color:var(--color-font-inverse);border:var(--size-border-width-base) solid var(--color-action-danger-base)}.jamf-button-v5-9-0.danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-danger-active)}.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-danger-active);border-color:var(--color-action-danger-active)}.jamf-button-v5-9-0.ghost{background-color:var(--color-action-ghost-base);color:var(--color-font-base);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.ghost-primary{background-color:var(--color-action-ghost-base);color:var(--color-font-link-base);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost-primary:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost-primary:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost-primary:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost-primary:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost-primary:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-primary-base)}.jamf-button-v5-9-0.ghost-danger{background-color:var(--color-action-ghost-base);color:var(--color-font-danger);border:var(--size-border-width-base) solid transparent;box-shadow:none}.jamf-button-v5-9-0.ghost-danger:hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.ghost-danger:active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.ghost-danger:active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.ghost-danger:focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.ghost-danger:hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-danger-base)}.jamf-button-v5-9-0.simple:not(.as-button),.jamf-button-v5-9-0.link:not(.as-button){background-color:var(--color-action-ghost-base);color:var(--color-font-link-base);border:var(--size-border-width-base) solid transparent;box-shadow:none;padding:0px calc(.25px * var(--size-base-spacing));border-radius:var(--size-border-radius-base);height:fit-content;border:none!important}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.simple:not(.as-button):active:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):active:not(:disabled):not(.is-disabled){background-color:var(--color-action-ghost-active)}.jamf-button-v5-9-0.simple:not(.as-button):active:not(:disabled):not(.is-disabled),.jamf-button-v5-9-0.link:not(.as-button):active:not(:disabled):not(.is-disabled){box-shadow:none}.jamf-button-v5-9-0.simple:not(.as-button):focus:not(:disabled),.jamf-button-v5-9-0.link:not(.as-button):focus:not(:disabled){background-color:var(--color-action-ghost-focus)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:active){border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:focus):not(:active),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:focus):not(:active){box-shadow:none!important}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):active,.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):active{background-color:var(--color-action-ghost-base)}.jamf-button-v5-9-0.simple:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.simple:not(.as-button):focus:not(:disabled),.jamf-button-v5-9-0.link:not(.as-button):hover:not(:disabled):not(:active),.jamf-button-v5-9-0.link:not(.as-button):focus:not(:disabled){background-color:var(--color-action-ghost-base);color:var(--color-action-primary-active)}.jamf-button-v5-9-0.simple:not(.as-button):active,.jamf-button-v5-9-0.link:not(.as-button):active{background-color:var(--color-action-ghost-base)}.jamf-button-v5-9-0.link:not(.as-button):hover{text-decoration:underline}.jamf-button-v5-9-0:not(.small){height:var(--size-action-height-base)}.jamf-button-v5-9-0.unstyled:not(.as-button){background:none;border:none;padding:0;margin:0;height:fit-content}.jamf-button-v5-9-0.unstyled:not(.as-button):hover:not(:disabled):not(:focus):not(:active){background-color:unset}.jamf-button-v5-9-0.unstyled:not(.as-button):focus:not(:disabled){background-color:unset}.jamf-button-v5-9-0.small{padding:calc(.5px * var(--size-base-spacing))}:host([type=number]){display:inline-block}';

const V = {
  class: "leading",
  part: "leading"
}, $ = ["id", "value", "disabled", "readOnly", "placeholder", "type", "required", "maxLength", "step", "aria-describedby", "aria-invalid", "aria-readonly", "data-wa", "data-wa-id", "max", "min", "name"], L = {
  key: 0,
  class: "counter-container",
  part: "counter-container"
}, B = ["disabled"], K$1 = ["disabled"], N = {
  key: 1,
  ref: "trailing",
  class: "trailing",
  part: "trailing"
}, D = {
  key: 2,
  class: "trailing focus-key",
  part: "focus-key"
}, O = {
  key: 3,
  class: "trailing show-password",
  part: "show-password"
}, S = {
  key: 4,
  class: "trailing copy-clipboard"
}, E = { class: "sr-only" }, P = {
  key: 5,
  class: "trailing error-icon",
  part: "error-icon"
}, J = {
  key: 6,
  class: "trailing warning-icon",
  part: "warning-icon"
}, z = {
  key: 7,
  class: "trailing success-icon",
  part: "success-icon"
}, H = ["id"], q = ["aria-live"];
function G$1(e, a, R, W, F, U) {
  const t = resolveComponent("JamfIcon"), y = resolveComponent("JamfButton"), b = resolveComponent("JamfTooltip"), g = resolveComponent("InputGroup");
  return openBlock(), createBlock(g, {
    id: e.computedId,
    label: e.label,
    "helper-text": e.helperText,
    "label-size": e.labelSize,
    "has-error": e.hasError,
    "has-warning": e.hasWarning,
    "has-success": e.hasSuccess,
    "error-text": e.errorText,
    "warning-text": e.warningText,
    "success-text": e.successText,
    "is-vertical": e.isVertical,
    "is-disabled": e.isDisabled,
    "descender-text": e.descenderText,
    "is-compact": true,
    ref: "inputGroup"
  }, {
    default: withCtx(({ ariaDescribedById: w }) => [
      createBaseVNode("div", {
        ref: "leading",
        class: normalizeClass(e.classes)
      }, [
        createBaseVNode("span", V, [
          renderSlot(e.$slots, "leading")
        ]),
        createBaseVNode("input", mergeProps(e.$attrs, {
          id: e.computedId,
          part: "input",
          ref: "input",
          value: e.computedValue,
          disabled: e.isDisabled || void 0,
          readOnly: e.isReadOnly || void 0,
          placeholder: e.placeholder || "",
          type: e.computedType,
          required: e.isRequired || void 0,
          maxLength: e.maximumLength || void 0,
          step: e.stepInterval || void 0,
          "aria-describedby": `${w} ${e.maxLengthId}`,
          "aria-invalid": e.hasError || void 0,
          "aria-readonly": e.isReadOnly || void 0,
          "data-wa": e.waComponent || void 0,
          "data-wa-id": e.waId || void 0,
          class: e.inputClass || void 0,
          max: e.maxValue !== null ? e.maxValue : void 0,
          min: e.minValue !== null ? e.minValue : void 0,
          name: e.name,
          onKeyup: a[0] || (a[0] = (...s) => e.handleKeyUp && e.handleKeyUp(...s)),
          onInput: a[1] || (a[1] = (...s) => e.inputChange && e.inputChange(...s))
        }), null, 16, $),
        e.isNumberInput ? (openBlock(), createElementBlock("span", L, [
          createBaseVNode("button", {
            disabled: e.isDisabled,
            class: normalizeClass(e.counterButton),
            onClick: a[2] || (a[2] = (...s) => e.handleIncrement && e.handleIncrement(...s)),
            "aria-label": "Increment"
          }, null, 10, B),
          createBaseVNode("button", {
            disabled: e.isDisabled,
            class: normalizeClass(e.counterButton),
            onClick: a[3] || (a[3] = (...s) => e.handleDecrement && e.handleDecrement(...s)),
            "aria-label": "Decrement"
          }, null, 10, K$1)
        ])) : createCommentVNode("", !0),
        !e.isNumberInput && !e.isStateful && !(e.type === "password" && e.showHidePassword) && !e.copyToClipboard && !e.showFocusKey ? (openBlock(), createElementBlock("span", N, [
          renderSlot(e.$slots, "trailing")
        ], 512)) : createCommentVNode("", !0),
        e.showFocusKey && e.focusKey && !e.isNumberInput && !e.isStateful && !(e.type === "password" && e.showHidePassword) && !e.copyToClipboard ? (openBlock(), createElementBlock("span", D, [
          createBaseVNode("span", null, "" + toDisplayString(e.focusKey), 1)
        ])) : createCommentVNode("", !0),
        e.type === "password" && e.showHidePassword ? (openBlock(), createElementBlock("span", O, [
          createVNode(t, {
            tabindex: "0",
            class: "text-input-preview--icon-button",
            role: "button",
            "aria-label": e.computedLabel,
            onClick: a[4] || (a[4] = (s) => e.changeType()),
            onKeyup: a[5] || (a[5] = withKeys((s) => e.changeType(), ["enter"])),
            data: e.computedIcon
          }, null, 8, ["aria-label", "data"])
        ])) : createCommentVNode("", !0),
        e.copyToClipboard && !e.showHidePassword ? (openBlock(), createElementBlock("span", S, [
          createVNode(b, {
            "open-position": "top",
            text: e.copyToClipBoardText
          }, {
            default: withCtx(() => [
              createVNode(y, {
                onClick: a[6] || (a[6] = (s) => e.copyValue()),
                class: "copy-button",
                "style-type": "ghost",
                size: "small"
              }, {
                default: withCtx(() => [
                  createBaseVNode("span", E, toDisplayString(e.copyToClipBoardText), 1),
                  createVNode(t, { data: e.clipboardOutline }, null, 8, ["data"])
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["text"])
        ])) : createCommentVNode("", !0),
        e.hasError && !e.isNumberInput && !e.showHidePassword ? (openBlock(), createElementBlock("span", P, [
          createVNode(t, { data: e.exclamationCircleOutline }, null, 8, ["data"])
        ])) : createCommentVNode("", !0),
        e.hasWarning && !e.hasError ? (openBlock(), createElementBlock("span", J, [
          createVNode(t, { data: e.exclamationTriangleOutline }, null, 8, ["data"])
        ])) : createCommentVNode("", !0),
        e.hasSuccess && !e.hasError && !e.hasWarning ? (openBlock(), createElementBlock("span", z, [
          createVNode(t, { data: e.checkCircleOutline }, null, 8, ["data"])
        ])) : createCommentVNode("", !0)
      ], 2)
    ]),
    descenders: withCtx(() => [
      typeof e.computedValue == "string" && e.maxLength && e.maxLength > 0 && !e.isNumberInput ? (openBlock(), createElementBlock("small", {
        key: 0,
        id: e.maxLengthId,
        class: "max-length",
        part: "max-length"
      }, [
        createTextVNode(toDisplayString(typeof e.computedValue == "string" ? e.computedValue.length : 0) + "/" + toDisplayString(e.maxLength) + " ", 1),
        createBaseVNode("span", {
          "aria-live": e.isPolite,
          class: "sr-only"
        }, toDisplayString(e.buildScreenLabel), 9, q)
      ], 8, H)) : createCommentVNode("", !0)
    ]),
    _: 3
  }, 8, ["id", "label", "helper-text", "label-size", "has-error", "has-warning", "has-success", "error-text", "warning-text", "success-text", "is-vertical", "is-disabled", "descender-text"]);
}
const X = /* @__PURE__ */ s$6(E$1, [["render", G$1], ["styles", [o$1]]]);

const n$1 = r$9(X), u = Object.keys(X.props);
let t$1 = class t extends n$1 {
  static {
    this.formAssociated = true;
  }
  constructor() {
    super(), this.internals_ = this.attachInternals();
  }
};
const a$3 = t$1.prototype.attachShadow;
t$1.prototype.attachShadow = function(e) {
  return a$3.apply(this, [{ ...e, delegatesFocus: true }]);
};
(function() {
  customElements.get("jamf-input-v5-9-0") === void 0 && customElements.define("jamf-input-v5-9-0", t$1);
})();

const { wrap: m$2 } = V$1(React), f$3 = m$2(n$1, {
  name: "jamf-input-v5-9-0",
  events: {
    onChange: "change"
  },
  properties: [...u]
});

const o = defineComponent({
  name: "JamfRadio",
  inject: {
    groupModelValue: { default: () => false },
    groupIsDisabled: { default: () => false },
    groupIsReadOnly: { default: () => false },
    groupHasError: { default: () => false },
    toggleStyleType: { default: () => false }
  },
  props: {
    /** Sets the name attribute on the input */
    name: {
      type: String
    },
    /** Sets the internal value of the component. */
    checked: [Boolean, String],
    /** Sets the native input value that will match the `value`. */
    value: [String, Number],
    /** Sets disabled state. */
    isDisabled: Boolean,
    /** Sets readonly state. */
    isReadOnly: Boolean,
    /** Sets error state. */
    hasError: Boolean,
    /** Sets size for label */
    labelSize: {
      type: String,
      default: "medium"
    },
    /** Sets size of input */
    size: {
      type: String,
      default: "medium"
    },
    /** Gets set by parent radio group component on toggle mode */
    firstToggle: Boolean,
    /** Gets set by parent radio group component on toggle mode */
    lastToggle: Boolean,
    /** Aligns any provided helper text underneath the label instead of beside it */
    isVertical: Boolean,
    /** Changes the visual style of radio to toggle button. */
    isToggle: Boolean,
    /** Changes the visual style of radio to menu list. */
    isMenuList: Boolean,
    /**
     * Sets toggle button style.
     * @values primary, warning, danger, success
     */
    styleType: {
      type: String,
      default: "primary"
    },
    /** Generic component identifier for web analytics targeting. */
    waComponent: {
      type: String,
      default: "nebula--radio"
    },
    /** Optional component identifier that can be set as a unique value on a page for web analytics targeting. */
    waId: String
  },
  emits: ["change"],
  data() {
    return {
      inputType: "radio",
      internals: void 0
    };
  },
  computed: {
    computedValue: {
      get() {
        return this.groupModelValue !== void 0 ? this.groupModelValue : this.checked;
      },
      set(e) {
        this.$refs.label.getRootNode().host.checked = e, this.$refs.label.dispatchEvent(
          new CustomEvent("change", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: e
          })
        ), this.internals && this.internals.setFormValue(e);
      }
    },
    classes() {
      return {
        radio: !this.isToggle,
        toggle: this.isToggle,
        "is-disabled": this.computedIsDisabled,
        "is-read-only": this.computedIsReadOnly,
        "has-error": this.computedHasError,
        "is-vertical": this.isVertical || this.isMenuList,
        "menu-list": this.isMenuList,
        "menu-list-checked": this.isMenuList && this.checked,
        "menu-list-not-checked": this.isMenuList && !this.checked,
        active: this.checked,
        [this.toggleStyleType]: this.isToggle,
        "label-large": this.labelSize == "large",
        "label-medium": this.labelSize == "medium",
        "label-small": this.labelSize == "small",
        [this.size]: this.size !== "medium"
      };
    },
    helperClasses() {
      return {
        "helper-large": this.labelSize == "large",
        "helper-medium": this.labelSize == "medium",
        "helper-small": this.labelSize == "small"
      };
    },
    inputClasses() {
      return {
        "has-danger": this.styleType === "danger",
        "has-warning": this.styleType === "warning",
        "has-success": this.styleType === "success"
      };
    },
    toggleClasses() {
      return {
        "first-toggle": this.firstToggle,
        "last-toggle": this.lastToggle,
        "middle-toggle": !this.firstToggle && !this.lastToggle,
        "label-container": !this.isToggle,
        "is-vertical": this.isVertical || this.isMenuList,
        "toggle-label": this.isToggle,
        "is-read-only": this.computedIsReadOnly
      };
    },
    computedIsDisabled() {
      return this.groupIsDisabled ? true : this.isDisabled;
    },
    computedIsReadOnly() {
      return this.groupIsReadOnly ? true : this.isReadOnly;
    },
    computedHasError() {
      return this.groupHasError ? true : this.hasError;
    }
  },
  methods: {
    handleKeyUp(e) {
      if (this.computedIsReadOnly) {
        e.preventDefault();
        return;
      }
      this.$refs.label.dispatchEvent(
        new CustomEvent("keyup", {
          bubbles: true,
          cancelable: true,
          composed: true
        })
      ), (e.code === "Enter" || e.code === "NumpadEnter") && this.emitSubmit();
    },
    emitSubmit() {
      const i = this.$refs.radio.getRootNode().host.closest("form");
      if (i) {
        const l = new Event("submit", { bubbles: true, cancelable: true });
        i.dispatchEvent(l) && i.requestSubmit();
      }
    },
    handleSlotClick(e) {
      if (!this.computedIsDisabled && !this.computedIsReadOnly) {
        let t = e.target.tagName;
        if (["JAMF-RADIO-V5-9-0", "JAMF-CHECKBOX-V5-9-0", "JAMF-SWITCH-V5-9-0"].includes(t))
          return;
        if (t === "INPUT") {
          const s = e.target;
          if (s.type === "checkbox" || s.type === "radio")
            return;
        }
        e.preventDefault();
      }
    }
  },
  mounted() {
    this.internals = this.$refs.radio.getRootNode().host.internals_, this.value && this.internals && this.internals.setFormValue(this.value);
  }
});

const a$2 = '@keyframes fadeIn-01b36b4c{0%{opacity:0}to{opacity:1}}@keyframes fadeOut-01b36b4c{0%{opacity:1}to{opacity:0}}@keyframes scaleIn-01b36b4c{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut-01b36b4c{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft-01b36b4c{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop-01b36b4c{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse-01b36b4c{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer-01b36b4c{0%{background-position:200% 0}to{background-position:-200% 0}}.radio[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-input-base);line-height:var(--size-font-input-height);letter-spacing:var(--size-font-input-spacing);transition-property:border,box-shadow;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;position:relative;display:flex;align-items:center;cursor:pointer;user-select:none;width:fit-content;margin:calc(1px * var(--size-base-spacing)) 0;margin:0;padding:0}.radio:hover input[data-v-01b36b4c]:not(:disabled),.radio:active input[data-v-01b36b4c]:not(:disabled){border:var(--size-border-width-base) solid var(--color-input-primary-active)}.radio[data-v-01b36b4c]:has(>input:focus){outline:none}.radio:has(>input:focus) input[data-v-01b36b4c]:not(:disabled){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}.radio:hover input[data-v-01b36b4c]:checked:not(:disabled),.radio:active input[data-v-01b36b4c]:checked:not(:disabled){background-color:var(--color-input-primary-active)}.radio:hover input.has-danger[data-v-01b36b4c]:checked:not(:disabled),.radio:active input.has-danger[data-v-01b36b4c]:checked:not(:disabled){background-color:var(--color-danger-active)}.radio:hover input.has-success[data-v-01b36b4c]:checked:not(:disabled),.radio:active input.has-success[data-v-01b36b4c]:checked:not(:disabled){background-color:var(--color-success-active)}.radio:hover input.has-warning[data-v-01b36b4c]:checked:not(:disabled),.radio:active input.has-warning[data-v-01b36b4c]:checked:not(:disabled){background-color:var(--color-warning-active)}.radio.is-read-only[data-v-01b36b4c]{pointer-events:none}.radio.is-disabled[data-v-01b36b4c]{opacity:var(--opacity-disabled);cursor:not-allowed}.radio.is-vertical[data-v-01b36b4c]{align-items:flex-start}.radio.label-small[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-small))}.radio.label-medium[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-medium))}.radio.label-large[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-large))}.radio.large.toggle span[part=label][data-v-01b36b4c]{height:calc(var(--size-input-height-base) + 1px * var(--size-base-spacing))}.radio .helper-small[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-small))}.radio .helper-medium[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-medium))}.radio .helper-large[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-large))}.radio.has-error input[data-v-01b36b4c],.has-error .radio input[data-v-01b36b4c]{border-color:var(--color-danger-base)}.radio[data-v-01b36b4c]:last-of-type{margin-bottom:0}.radio input[data-v-01b36b4c]{transition-property:border-color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;border:var(--size-border-width-base) solid var(--color-input-border-base);border-radius:100%;appearance:none;background-color:transparent;outline:none;display:inline-block;width:var(--size-input-height-tertiary);height:var(--size-input-height-tertiary);margin:0 calc(1px * var(--size-base-spacing)) 0 0;cursor:pointer;flex-shrink:0}.radio input[data-v-01b36b4c]:checked{border-color:var(--color-input-primary-base);overflow:hidden;position:relative}.radio input[data-v-01b36b4c]:checked:after{content:"";transition-property:background-color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;animation:scaleIn-01b36b4c ease-in-out .15s;position:absolute;border-radius:50%;inset:3px;background:var(--color-input-primary-base)}.radio input[data-v-01b36b4c]:disabled{cursor:not-allowed}.radio:hover input[data-v-01b36b4c]:checked:not(:disabled){background-color:inherit;border-color:var(--color-input-primary-active)}.radio:hover input[data-v-01b36b4c]:checked:not(:disabled):after{background-color:var(--color-input-primary-active)}.is-inline .radio[data-v-01b36b4c]{display:inline;padding:0 calc(2px * var(--size-base-spacing)) 0 0}.is-inline .radio input[data-v-01b36b4c],.is-inline .radio span[data-v-01b36b4c]{vertical-align:middle}.radio input[readonly][data-v-01b36b4c]{background-color:var(--color-input-readonly)!important;border-color:var(--color-border-secondary)!important}.radio input[readonly][data-v-01b36b4c]:checked:after{background:var(--color-font-base)}.radio input[data-v-01b36b4c]:not([readonly]){background-color:var(--color-structure-base)!important}.radio .label-container.is-vertical[data-v-01b36b4c]{display:flex;flex-direction:column}.radio .label-container.is-vertical[data-v-01b36b4c] ::slotted([slot=description]){margin-left:0}.radio.menu-list[data-v-01b36b4c]{display:flex;align-items:center;transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s}.radio[data-v-01b36b4c] ::slotted(*){color:var(--color-font-base)}.toggle.primary[data-v-01b36b4c]{transition-property:border,box-shadow;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;position:relative;display:flex;align-items:center;user-select:none;width:fit-content;font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-input-base);line-height:var(--size-font-input-height);letter-spacing:var(--size-font-input-spacing);display:inline-block;cursor:pointer;margin-right:0}.toggle.primary input[type=checkbox][data-v-01b36b4c],.toggle.primary input[type=radio][data-v-01b36b4c]{opacity:0;width:0;height:0;position:absolute;cursor:pointer}.toggle.primary input[type=checkbox]:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only),.toggle.primary input[type=radio]:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only){background-color:var(--color-input-primary-base);border-color:var(--color-input-primary-base)}.toggle.primary input[type=checkbox].has-danger:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only),.toggle.primary input[type=radio].has-danger:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only){background-color:var(--color-danger-base);border-color:var(--color-danger-base)}.toggle.primary input[type=checkbox].has-warning:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only),.toggle.primary input[type=radio].has-warning:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only){background-color:var(--color-warning-base);border-color:var(--color-warning-base)}.toggle.primary input[type=checkbox].has-success:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only),.toggle.primary input[type=radio].has-success:checked~span[data-v-01b36b4c]:not(.indicator):not(.is-read-only){background-color:var(--color-success-base);border-color:var(--color-success-base)}.toggle.primary input[type=checkbox]:checked~span:not(.indicator).is-read-only[data-v-01b36b4c],.toggle.primary input[type=radio]:checked~span:not(.indicator).is-read-only[data-v-01b36b4c]{background-color:var(--color-input-readonly);border-color:var(--color-input-readonly)}.toggle.primary span[data-v-01b36b4c]:not(.indicator){border:var(--size-border-width-base) solid var(--color-input-border-base);transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;background-color:var(--color-input-base);display:flex;align-items:center;left:0;height:var(--size-input-height-secondary)}.toggle.primary:hover input:not(:disabled)~span[data-v-01b36b4c]:not(.indicator),.toggle.primary:active input:not(:disabled)~span[data-v-01b36b4c]:not(.indicator){border:var(--size-border-width-base) solid var(--color-input-primary-active)}.toggle.primary[data-v-01b36b4c]:has(>input:focus){outline:none}.toggle.primary:has(>input:focus) input:not(:disabled)~span[data-v-01b36b4c]:not(.indicator){transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px}.toggle.primary:hover input:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator),.toggle.primary:active input:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator){background-color:var(--color-input-primary-active)}.toggle.primary:hover input.has-danger:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator),.toggle.primary:active input.has-danger:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator){background-color:var(--color-danger-active)}.toggle.primary:hover input.has-success:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator),.toggle.primary:active input.has-success:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator){background-color:var(--color-success-active)}.toggle.primary:hover input.has-warning:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator),.toggle.primary:active input.has-warning:checked:not(:disabled)~span[data-v-01b36b4c]:not(.indicator){background-color:var(--color-warning-active)}.toggle.primary.is-read-only[data-v-01b36b4c]{pointer-events:none}.toggle.primary.is-disabled[data-v-01b36b4c]{opacity:var(--opacity-disabled);cursor:not-allowed}.toggle.primary.is-vertical[data-v-01b36b4c]{align-items:flex-start}.toggle.primary.label-small[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-small))}.toggle.primary.label-medium[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-medium))}.toggle.primary.label-large[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-large))}.toggle.primary.large.toggle span[part=label][data-v-01b36b4c]{height:calc(var(--size-input-height-base) + 1px * var(--size-base-spacing))}.toggle.primary .helper-small[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-small))}.toggle.primary .helper-medium[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-medium))}.toggle.primary .helper-large[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-large))}.toggle.primary.has-error span[data-v-01b36b4c]:not(.indicator){border-color:var(--color-danger-base)}.has-error .toggle.primary span[data-v-01b36b4c]:not(.indicator){border-color:var(--color-danger-base)}.toggle.primary input:not([readonly]):checked~span[data-v-01b36b4c]:not(.indicator){color:var(--color-font-inverse)}.toggle.primary span[data-v-01b36b4c]:not(.indicator){position:relative;padding:0 calc(1px * var(--size-base-spacing));white-space:nowrap}.toggle.primary .first-toggle[data-v-01b36b4c]{margin-right:-1px;border-radius:var(--size-border-radius-input) 0 0 var(--size-border-radius-input)}.toggle.primary .middle-toggle[data-v-01b36b4c]{margin-right:-1px}.toggle.primary .middle-toggle:hover:not(:last-of-type)+.toggle span[data-v-01b36b4c]:not(.indicator){border-left-color:var(--color-input-border-active)}.toggle.primary .last-toggle[data-v-01b36b4c]{border-radius:0 var(--size-border-radius-input) var(--size-border-radius-input) 0}.toggle.secondary[data-v-01b36b4c]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-input-base);line-height:var(--size-font-input-height);letter-spacing:var(--size-font-input-spacing);cursor:pointer;color:var(--color-font-base)}.toggle.secondary:focus .toggle-label[data-v-01b36b4c],.toggle.secondary:focus-within .toggle-label[data-v-01b36b4c]{transition-property:all;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;outline:none;box-shadow:var(--color-focus-secondary) 0 0 0 2px,var(--color-focus-base) 0 0 0 4px;padding:calc(.75px * var(--size-base-spacing)) calc(1.25px * var(--size-base-spacing))}.toggle.secondary input[type=radio][data-v-01b36b4c]{opacity:0;width:0;height:0;position:absolute}.toggle.secondary span[data-v-01b36b4c]:not(.indicator){display:inline-flex;align-items:center;padding:calc(.75px * var(--size-base-spacing)) calc(1.25px * var(--size-base-spacing));background-color:transparent;white-space:nowrap;transition-property:background-color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;border-radius:calc(var(--size-border-radius-input) / 2)}.toggle.secondary span[data-v-01b36b4c]:not(.indicator):hover{background-color:rgba(var(--color-structure-base-rgb),.5)}.toggle.secondary.active .toggle-label[data-v-01b36b4c]{background-color:var(--color-structure-base);border:var(--size-border-width-base) solid var(--color-border-neutral-base)}.toggle.secondary.is-disabled[data-v-01b36b4c]{opacity:var(--opacity-disabled);cursor:not-allowed}[data-v-01b36b4c]::slotted([slot=description]){margin-left:calc(1px * var(--size-base-spacing));font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-medium))}.helper-small[data-v-01b36b4c]::slotted([slot=description]){font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-small))}.helper-large[data-v-01b36b4c]::slotted([slot=description]){font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-weight-normal);font-size:var(--size-font-helper-base);line-height:var(--size-font-helper-height);letter-spacing:var(--size-font-helper-spacing);color:var(--color-font-secondary);font-size:calc(var(--size-font-helper-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-helper-height) + var(--size-type-scaler-large))}.menu-list[data-v-01b36b4c]{border-radius:var(--size-border-radius-base);border:var(--size-border-width-base) solid var(--color-border-base);width:100%;padding:calc(2px * var(--size-base-spacing));align-items:stretch;border:var(--size-border-width-base) solid var(--color-radio-menu-list-border, var(--color-border-base))}.menu-list[data-v-01b36b4c]:hover:not([readonly]):not(.is-disabled){box-shadow:var(--size-shadow-action) var(--color-shadow-base)}.menu-list.active[data-v-01b36b4c]{border-color:var(--color-checkbox-menu-list-border-active, var(--color-border-base))}.menu-list .label-container[data-v-01b36b4c]{margin-left:calc(1px * var(--size-base-spacing));padding-left:calc(2px * var(--size-base-spacing))}.slot-container[data-v-01b36b4c]{display:flex;justify-content:space-between;align-items:center;width:100%}.trailing[data-v-01b36b4c]::slotted(*){margin-left:calc(5px * var(--size-base-spacing))}.menu-list-checked[data-v-01b36b4c]{background:linear-gradient(to right,var(--color-primary-subdued) 0%,var(--color-primary-subdued) calc(7px * var(--size-base-spacing)),var(--color-structure-base) calc(7px * var(--size-base-spacing)),var(--color-structure-base) 100%);background-origin:border-box}.menu-list-not-checked[data-v-01b36b4c]{background:linear-gradient(to right,var(--color-structure-secondary) 0%,var(--color-structure-secondary) calc(7px * var(--size-base-spacing)),var(--color-structure-base) calc(7px * var(--size-base-spacing)),var(--color-structure-base) 100%);background-origin:border-box}.label-container[data-v-01b36b4c]{color:var(--color-font-base)}.descenders-container[data-v-01b36b4c]::slotted(*){margin-top:calc(1px * var(--size-base-spacing))}';

const a$1 = "@keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeOut{0%{opacity:1}to{opacity:0}}@keyframes scaleIn{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer{0%{background-position:200% 0}to{background-position:-200% 0}}:host([is-toggle]) :focus-within{z-index:1;position:relative}";

const k$1 = ["tabindex", "name", "value", "disabled", "readonly", "data-wa", "data-wa-id", "checked"], b = {
  key: 1,
  class: "slot-container",
  part: "slot-container"
};
function y$1(e, s, $, w, g, I) {
  return openBlock(), createElementBlock("label", {
    ref: "label",
    class: normalizeClass(e.classes),
    part: "container"
  }, [
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": s[0] || (s[0] = (l) => e.computedValue = l),
      tabindex: e.computedIsDisabled ? -1 : 0,
      type: "radio",
      ref: "radio",
      name: e.name,
      value: e.value,
      disabled: e.computedIsDisabled,
      readonly: e.computedIsReadOnly,
      "data-wa": e.waComponent,
      "data-wa-id": e.waId,
      onClick: s[1] || (s[1] = withModifiers(() => {
      }, ["stop"])),
      onKeyup: s[2] || (s[2] = (...l) => e.handleKeyUp && e.handleKeyUp(...l)),
      class: normalizeClass(e.inputClasses),
      part: "input",
      checked: e.checked
    }, null, 42, k$1), [
      [vModelRadio, e.computedValue]
    ]),
    s[6] || (s[6] = createBaseVNode("span", {
      class: "indicator",
      part: "indicator"
    }, null, -1)),
    e.isMenuList ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(e.toggleClasses),
      part: "label"
    }, [
      renderSlot(e.$slots, "default", {}, void 0, true),
      renderSlot(e.$slots, "description", {}, void 0, true),
      renderSlot(e.$slots, "descenders", {
        class: "descenders-container",
        onClickCapture: s[3] || (s[3] = (l) => e.handleSlotClick(l))
      }, void 0, true)
    ], 2)),
    e.isMenuList ? (openBlock(), createElementBlock("div", b, [
      createBaseVNode("div", null, [
        createBaseVNode("span", {
          class: normalizeClass(e.toggleClasses),
          part: "label"
        }, [
          renderSlot(e.$slots, "default", {}, void 0, true),
          renderSlot(e.$slots, "description", {
            class: normalizeClass(e.helperClasses)
          }, void 0, true),
          renderSlot(e.$slots, "descenders", {
            class: "descenders-container",
            onClickCapture: s[4] || (s[4] = (l) => e.handleSlotClick(l))
          }, void 0, true)
        ], 2)
      ]),
      renderSlot(e.$slots, "trailing", {
        class: "trailing",
        onClickCapture: s[5] || (s[5] = (l) => e.handleSlotClick(l))
      }, void 0, true)
    ])) : createCommentVNode("", true)
  ], 2);
}
const K = /* @__PURE__ */ s$6(o, [["render", y$1], ["styles", [a$2, a$1]], ["__scopeId", "data-v-01b36b4c"]]);

const s = r$9(K), c$1 = Object.keys(K.props);
class t extends s {
  static {
    this.formAssociated = true;
  }
  constructor() {
    super(), this.internals_ = this.attachInternals();
  }
}
const r$1 = t.prototype.attachShadow;
t.prototype.attachShadow = function(o) {
  return r$1.apply(this, [{ ...o, delegatesFocus: true }]);
};
(function() {
  customElements.get("jamf-radio-v5-9-0") === void 0 && customElements.define("jamf-radio-v5-9-0", t);
})();

const { wrap: m$1 } = V$1(React), f$2 = m$1(s, {
  name: "jamf-radio-v5-9-0",
  properties: [...c$1],
  events: {
    onChange: "change"
  }
});

const f$1 = defineComponent({
  name: "JamfRadioGroup",
  provide() {
    return {
      groupModelValue: computed(() => this.internalValue),
      groupIsDisabled: computed(() => this.isDisabled),
      groupIsReadOnly: computed(() => this.isReadOnly),
      groupHasError: computed(() => this.hasError),
      toggleStyleType: computed(() => this.toggleStyleType)
    };
  },
  props: {
    /** Sets the label text. */
    isVertical: Boolean,
    /** Sets the id which binds the label to the input group.
     *  Should be unique on the page. */
    id: String,
    /** Sets text for the label. */
    label: String,
    /** Sets text to display below the field. */
    descenderText: String,
    /** Sets error state. */
    hasError: Boolean,
    /** Sets text to display when hasError is true. */
    errorText: String,
    /** Sets disabled state. */
    isDisabled: Boolean,
    /** Sets read only state. */
    isReadOnly: Boolean,
    /** Sets toggle button group state. */
    isToggle: Boolean,
    /**
     * Sets toggle button style.
     * @values primary, secondary
     */
    toggleStyleType: {
      type: String,
      default: "primary"
    },
    /** Sets size for label */
    labelSize: {
      type: String,
      default: "medium"
    },
    /** Sets size of input */
    size: {
      type: String,
      default: "medium"
    },
    /** Sets menu list group state */
    isMenuList: Boolean,
    /** Set as a normal v-model would be. */
    value: {
      type: String,
      default: ""
    },
    /** Sets data-wa attribute. */
    waComponent: {
      type: String,
      default: "nebula--toggle-group"
    },
    /** Sets data-wa-id attribute. */
    waId: String
  },
  emits: ["input", "change"],
  data() {
    return {
      radioComponents: [],
      internalValue: this.value,
      internals: void 0,
      observer: null
    };
  },
  computed: {
    classes() {
      return {
        group: true,
        "radio-group": !this.isToggle,
        "toggle-group": this.isToggle,
        "is-vertical": this.isVertical,
        "has-error": this.hasError,
        "is-disabled": this.isDisabled,
        [this.toggleStyleType]: this.isToggle,
        [this.size]: this.size !== "medium"
      };
    },
    disabled() {
      return this.isDisabled || this.isReadOnly;
    },
    includeDescenders() {
      const e = this.$refs.radioGroup;
      return !!this.errorText && this.hasError || !!l$3(e ? e.$el : null, "descenders") || !!this.descenderText;
    },
    descenderId() {
      return this.id ? `${this.id}-descender` : "";
    },
    errorId() {
      return this.id ? `${this.id}-error` : "";
    },
    ariaDescribedById() {
      return this.hasError && this.errorText && this.errorId ? this.errorId : this.descenderText && this.descenderId && !this.hasError ? this.descenderId : null;
    },
    groupClass() {
      return {
        label: true,
        "label-container": this.isToggle
      };
    },
    labelClass() {
      return {
        "label-text": !this.isVertical,
        "error-text": this.hasError,
        "label-large": this.labelSize == "large",
        "label-medium": this.labelSize == "medium",
        "label-small": this.labelSize == "small"
      };
    }
  },
  watch: {
    value(e) {
      this.internalValue = e, this.internals && this.internals.setFormValue(e), this.initializeComponent(this.$refs);
    },
    isToggle() {
      this.updateChildComponents(this.radioComponents);
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.initializeComponent(this.$refs), this.internals = this.$refs.radioGroup.getRootNode().host.internals_, this.value && this.internals && this.internals.setFormValue(this.value);
    });
  },
  methods: {
    initializeComponent(e) {
      const t = this.$refs.radioGroup.getRootNode()?.host;
      this.observer = new MutationObserver(() => {
        this.initializeComponent(this.$refs);
      }), this.observer.observe(t, { childList: true, subtree: true }), this.radioComponents = [];
      const i = e.radioGroup?.querySelector("slot");
      if (!i) return;
      i.assignedElements().forEach((r) => {
        r.tagName === "JAMF-RADIO-V5-9-0" ? this.radioComponents.push(r) : this.radioComponents.push(
          ...Array.from(r.getElementsByTagName("jamf-radio-v5-9-0"))
        );
      }), this.updateChildComponents(this.radioComponents);
    },
    updateChildComponents(e) {
      e.forEach((t, i) => {
        let s = e[i].getAttribute("value");
        this.internalValue === s ? e[i].setAttribute("checked", "") : e[i].removeAttribute("checked"), this.isToggle ? (["first-toggle", "middle-toggle", "last-toggle"].forEach((r) => {
          t.removeAttribute(r);
        }), i === 0 ? t.setAttribute("first-toggle", "") : i === e.length - 1 ? t.setAttribute("last-toggle", "") : t.setAttribute("middle-toggle", ""), t.setAttribute("is-toggle", "")) : this.isMenuList && t.setAttribute("is-menu-list", "");
      });
    },
    changeEvent(e) {
      e.target.tagName.includes("JAMF-RADIO-V5-9-0") && this.updateValue(e.target.checked);
    },
    updateValue(e) {
      this.internalValue = e;
      const t = this.$refs.radioGroup?.getRootNode()?.host;
      t && (t.value = this.internalValue), this.$emit("input", e), this.$emit("change", e);
    },
    handleKeyUp(e) {
      let t = null;
      for (const i of this.radioComponents) {
        const s = i, r = s.hasAttribute("is-disabled"), u = s.hasAttribute("is-read-only");
        if (r || u) continue;
        const a = e.target, l = a ? a.value : null;
        if (!l)
          continue;
        const d = s.value;
        if (r$8.RIGHT.includes(e.code)) {
          if (t && t.value === l) {
            this.setFocusAndValue(s);
            return;
          }
        } else if (r$8.LEFT.includes(e.code) && d === l) {
          this.setFocusAndValue(t);
          return;
        }
        t = s;
      }
    },
    setFocusAndValue(e) {
      if (!e) return;
      this.updateValue(e.value);
      const t = e.shadowRoot?.querySelector("label");
      t && t.focus();
    }
  },
  beforeUnmount() {
    this.observer && this.observer.disconnect();
  }
});

const a = '@keyframes fadeIn-3496fe15{0%{opacity:0}to{opacity:1}}@keyframes fadeOut-3496fe15{0%{opacity:1}to{opacity:0}}@keyframes scaleIn-3496fe15{0%{transform:scale(.65)}to{transform:scale(1)}}@keyframes scaleOut-3496fe15{0%{transform:scale(1)}to{transform:scale(0)}}@keyframes microSlideInLeft-3496fe15{0%{transform:translate(-4px)}to{transform:translate(0)}}@keyframes slideInTop-3496fe15{0%{transform:translateY(-16px)}to{transform:translateY(0)}}@keyframes pulse-3496fe15{0%{transform:scale(.95);opacity:.7}50%{transform:scale(1.05);opacity:1}to{transform:scale(.95);opacity:.7}}@keyframes subtleShimmer-3496fe15{0%{background-position:200% 0}to{background-position:-200% 0}}.group .error-text[data-v-3496fe15]{color:var(--color-danger-base)}.group .label-container[data-v-3496fe15]{display:flex;flex-direction:row;align-items:center}.group .label-text[data-v-3496fe15]{padding-right:calc(1px * var(--size-base-spacing))}.group .label-text-vertical[data-v-3496fe15]{padding-bottom:calc(1px * var(--size-base-spacing))}.group .is-disabled[data-v-3496fe15]{opacity:var(--opacity-disabled);cursor:not-allowed}.group.secondary .slot-container[data-v-3496fe15]{padding:0 calc(.25px * var(--size-base-spacing));border-radius:calc(var(--size-border-radius-small, 4px) + 1px);height:var(--size-input-height-base);display:flex;flex-direction:row;gap:calc(1px * var(--size-base-spacing));align-items:center;background-color:var(--color-border-secondary)}.group .label-small[data-v-3496fe15]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-small));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-small))}.group .label-medium[data-v-3496fe15]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-medium));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-medium))}.group .label-large[data-v-3496fe15]{font-family:var(--font-family),"Helvetica Neue",Helvetica,Lucida Grande,sans-serif;font-weight:var(--size-font-label-weight);transition-property:color;transition-duration:.2s;transition-timing-function:linear;transition-delay:0s;font-size:var(--size-font-label-base);line-height:var(--size-font-label-height);letter-spacing:var(--size-font-label-spacing);color:var(--color-font-base);font-size:calc(var(--size-font-label-base) + var(--size-type-scaler-large));line-height:calc(var(--size-font-label-height) + var(--size-type-scaler-large))}.radio-group[data-v-3496fe15] ::slotted(jamf-radio-v5-9-0){display:block;margin-top:calc(2px * var(--size-base-spacing))}';

const m = ["aria-labelledby", "aria-describedby", "data-wa", "data-wa-id"], y = {
  key: 0,
  class: "label-vertical",
  part: "label-vertical"
}, c = ["for"], h = ["id"], v = ["for"], I = {
  key: 1,
  class: "input-descenders",
  part: "input-descenders"
}, k = ["id"], w = ["id"];
function C(e, d, D, E, $, g) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(e.classes),
    part: "container",
    "aria-labelledby": e.id || "defaultID",
    "aria-describedby": e.ariaDescribedById || "defaultDescID",
    "data-wa": e.waComponent,
    "data-wa-id": e.waId || "defaultWaId",
    ref: "radioGroup"
  }, [
    e.label && e.isVertical ? (openBlock(), createElementBlock("div", y, [
      createBaseVNode("label", {
        for: e.id,
        class: normalizeClass(e.labelClass),
        part: "label-text-vertical"
      }, toDisplayString(e.label), 11, c)
    ])) : createCommentVNode("", true),
    createBaseVNode("div", {
      id: e.id,
      class: normalizeClass(e.groupClass),
      part: "label"
    }, [
      e.label && !e.isVertical ? (openBlock(), createElementBlock("label", {
        key: 0,
        for: e.id,
        class: normalizeClass(e.labelClass),
        part: "label-text"
      }, toDisplayString(e.label), 11, v)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: "slot-container",
        onKeyup: d[0] || (d[0] = withModifiers((...t) => e.handleKeyUp && e.handleKeyUp(...t), ["stop"])),
        onChange: d[1] || (d[1] = withModifiers((...t) => e.changeEvent && e.changeEvent(...t), ["stop"])),
        part: "slot-container"
      }, [
        renderSlot(e.$slots, "default")
      ], 32)
    ], 10, h),
    e.includeDescenders ? (openBlock(), createElementBlock("div", I, [
      !e.hasError && e.descenderText ? (openBlock(), createElementBlock("small", {
        key: 0,
        id: e.descenderId,
        part: "descender-text"
      }, toDisplayString(e.descenderText), 9, k)) : createCommentVNode("", true),
      e.hasError ? (openBlock(), createElementBlock("small", {
        key: 1,
        id: e.errorId,
        class: "error-text",
        part: "error-text"
      }, toDisplayString(e.errorText || e.descenderText), 9, w)) : createCommentVNode("", true),
      renderSlot(e.$slots, "descenders")
    ])) : createCommentVNode("", true)
  ], 10, m);
}
const G = /* @__PURE__ */ s$6(f$1, [["render", C], ["styles", [a]], ["__scopeId", "data-v-3496fe15"]]);

const e$1 = r$9(G), n = Object.keys(G.props);
class r extends e$1 {
  static {
    this.formAssociated = true;
  }
  constructor() {
    super(), this.internals_ = this.attachInternals();
  }
}
(function() {
  customElements.get("jamf-radio-group-v5-9-0") === void 0 && customElements.define("jamf-radio-group-v5-9-0", r);
})();

const { wrap: e } = V$1(React), f = e(e$1, {
  name: "jamf-radio-group-v5-9-0",
  properties: [...n],
  events: {
    onChange: "change"
  }
});

const filter = "_filter_14hvy_1";
const search = "_search_14hvy_5";
const classnames = {
	filter: filter,
	search: search
};

const availableGroupTypes = ["smart", "static", "all"];
function useGroupTypeFilterOptions() {
  const { t } = scoping__loadShare__react_mf_2_i18next__loadShare__.useTranslation("app");
  return [
    {
      type: "all",
      label: t("search_form__groups__all__label")
    },
    {
      type: "smart",
      label: t("search_form__groups__smart__label")
    },
    {
      type: "static",
      label: t("search_form__groups__static__label")
    }
  ];
}
function isAvailableGroupType(v) {
  return availableGroupTypes.includes(v);
}
function ScopeFormFilter({ filter, onFilterChange }) {
  const { t } = scoping__loadShare__react_mf_2_i18next__loadShare__.useTranslation("app");
  const groupsTypeFilterOptions = useGroupTypeFilterOptions();
  return /* @__PURE__ */ React.createElement(
    "form",
    {
      onSubmit: (e) => {
        e.preventDefault();
        e.stopPropagation();
      }
    },
    /* @__PURE__ */ React.createElement("fieldset", { className: classnames.filter }, /* @__PURE__ */ React.createElement(f, { isToggle: true, isMenuList: true, toggleStyleType: "secondary", value: filter.groupType }, groupsTypeFilterOptions.map((option) => /* @__PURE__ */ React.createElement(
      f$2,
      {
        isToggle: true,
        key: option.type,
        value: option.type,
        onChange: (e) => {
          const newValue = e.target.value;
          if (isAvailableGroupType(newValue)) {
            onFilterChange({
              ...filter,
              groupType: newValue
            });
          }
        }
      },
      option.label
    ))), /* @__PURE__ */ React.createElement(
      f$3,
      {
        className: `input-alternate-border ${classnames.search}`,
        placeholder: t("search_form__search__placeholder"),
        type: "text",
        value: filter.search,
        onChange: (e) => onFilterChange({
          ...filter,
          search: e.target.value
        }),
        focusKey: "K",
        showFocusKey: true
      },
      /* @__PURE__ */ React.createElement("span", { slot: "leading" }, /* @__PURE__ */ React.createElement(f$8, { data: X1, width: "16" }))
    ))
  );
}

function areArraysEqual(a, b) {
  const setB = new Set(b);
  return a.length === setB.size && a.every((v) => setB.has(v));
}
function getGroupIdsFromScopeDefinition(scopeDefinition) {
  return scopeDefinition?.scope.include.filter(({ type }) => type === "groupId").map(({ value }) => value) ?? [];
}
const ScopeForm = ({ defaultScopeId, onSubmit, formId, onPendingChange, isReadOnly }) => {
  const [filter, setFilter] = scoping__loadShare__react__loadShare__.useState({
    search: "",
    groupType: "all"
  });
  const [debouncedSearch] = a$a(filter.search, 200);
  const form = scoping__loadShare__react_mf_2_hook_mf_2_form__loadShare__.useForm({
    defaultValues: {
      groupsInScope: []
    }
  });
  const scopeId = defaultScopeId.get();
  const id = typeof scopeId === "string" || scopeId === null ? scopeId : null;
  const { data: scopeDefinitionData, isLoading: isScopeLoading } = useScope(id);
  scoping__loadShare__react__loadShare__.useEffect(() => {
    const savedGroups = getGroupIdsFromScopeDefinition(scopeDefinitionData);
    form.setValue("groupsInScope", savedGroups);
  }, [scopeDefinitionData, form]);
  const { mutateAsync: createScope, isPending } = useCreateScope();
  scoping__loadShare__react__loadShare__.useEffect(() => {
    onPendingChange(isPending ?? false);
  }, [isPending, onPendingChange]);
  const onSubmitInternal = form.handleSubmit(({ groupsInScope }) => {
    if (groupsInScope.length === 0) {
      onSubmit(null);
      return;
    }
    if (defaultScopeId != null && areArraysEqual(groupsInScope, getGroupIdsFromScopeDefinition(scopeDefinitionData))) {
      onSubmit(id);
      return;
    }
    return createScope(groupsInScope).then(({ scopeId: scopeId2 }) => {
      onSubmit(scopeId2);
    });
  });
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(ScopeFormFilter, { filter, onFilterChange: setFilter }), /* @__PURE__ */ React.createElement(
    "form",
    {
      id: formId,
      onSubmit: (e) => {
        e.stopPropagation();
        onSubmitInternal(e);
      }
    },
    /* @__PURE__ */ React.createElement("fieldset", { className: classnames.groupsWrapper }, /* @__PURE__ */ React.createElement(
      scoping__loadShare__react_mf_2_hook_mf_2_form__loadShare__.Controller,
      {
        control: form.control,
        name: "groupsInScope",
        render: ({ field }) => /* @__PURE__ */ React.createElement(f$c, { ...field, isMenuList: true, isReadOnly }, /* @__PURE__ */ React.createElement(
          GroupCheckboxList,
          {
            type: filter.groupType,
            filter: debouncedSearch,
            isScopeLoading,
            isReadOnly
          }
        ))
      }
    ))
  ));
};

var ReactQueryDevtools2 = function() {
  return null;
} ;

function App({ client, queryClient, children }) {
  return /* @__PURE__ */ React.createElement(QueryClientProvider, { client: queryClient }, /* @__PURE__ */ React.createElement(ClientContext.Provider, { value: client }, children), /* @__PURE__ */ React.createElement(ReactQueryDevtools2, { initialIsOpen: false }));
}

export { l$3 as A, withDirectives as B, vShow as C, D8 as D, withKeys as E, Fragment as F, f$e as G, initializeI18n as H, axios as I, qs as J, App as K, LocalizationProvider as L, SkeletonLoading as M, QueryClient as Q, R7 as R, ScopeForm as S, TransitionGroup as T, V$1 as V, b4 as a, b$7 as b, resolveComponent as c, defineComponent as d, createElementBlock as e, openBlock as f, createBlock as g, createCommentVNode as h, createBaseVNode as i, renderSlot as j, createVNode as k, renderList as l, createSlots as m, normalizeClass as n, oc as o, Transition as p, r$9 as q, r$8 as r, s$6 as s, toDisplayString as t, requiredServices as u, mockServices as v, withCtx as w, FeatureServicesContext as x, y8 as y, z$3 as z };
